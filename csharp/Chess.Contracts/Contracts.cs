// Generated by ProtoGen, Version=2.4.1.473, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Chess.Contracts {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public static partial class Contracts {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Envelope__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.Envelope, global::Chess.Contracts.Envelope.Builder> internal__static_com_richardpianka_chess_network_Envelope__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Version__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.Version, global::Chess.Contracts.Version.Builder> internal__static_com_richardpianka_chess_network_Version__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Room__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.Room, global::Chess.Contracts.Room.Builder> internal__static_com_richardpianka_chess_network_Room__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Record__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.Record, global::Chess.Contracts.Record.Builder> internal__static_com_richardpianka_chess_network_Record__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_User__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.User, global::Chess.Contracts.User.Builder> internal__static_com_richardpianka_chess_network_User__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Game__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.Game, global::Chess.Contracts.Game.Builder> internal__static_com_richardpianka_chess_network_Game__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_HandshakeRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.HandshakeRequest, global::Chess.Contracts.HandshakeRequest.Builder> internal__static_com_richardpianka_chess_network_HandshakeRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_HandshakeResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.HandshakeResponse, global::Chess.Contracts.HandshakeResponse.Builder> internal__static_com_richardpianka_chess_network_HandshakeResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_IdentifyRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.IdentifyRequest, global::Chess.Contracts.IdentifyRequest.Builder> internal__static_com_richardpianka_chess_network_IdentifyRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_IdentifyResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.IdentifyResponse, global::Chess.Contracts.IdentifyResponse.Builder> internal__static_com_richardpianka_chess_network_IdentifyResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinChatRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinChatRequest, global::Chess.Contracts.JoinChatRequest.Builder> internal__static_com_richardpianka_chess_network_JoinChatRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinChatResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinChatResponse, global::Chess.Contracts.JoinChatResponse.Builder> internal__static_com_richardpianka_chess_network_JoinChatResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_RoomListRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.RoomListRequest, global::Chess.Contracts.RoomListRequest.Builder> internal__static_com_richardpianka_chess_network_RoomListRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_RoomListResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.RoomListResponse, global::Chess.Contracts.RoomListResponse.Builder> internal__static_com_richardpianka_chess_network_RoomListResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinRoomRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinRoomRequest, global::Chess.Contracts.JoinRoomRequest.Builder> internal__static_com_richardpianka_chess_network_JoinRoomRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinRoomResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinRoomResponse, global::Chess.Contracts.JoinRoomResponse.Builder> internal__static_com_richardpianka_chess_network_JoinRoomResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_SpeakRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.SpeakRequest, global::Chess.Contracts.SpeakRequest.Builder> internal__static_com_richardpianka_chess_network_SpeakRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_OperatorRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.OperatorRequest, global::Chess.Contracts.OperatorRequest.Builder> internal__static_com_richardpianka_chess_network_OperatorRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_OperatorResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.OperatorResponse, global::Chess.Contracts.OperatorResponse.Builder> internal__static_com_richardpianka_chess_network_OperatorResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_ChatRoomEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.ChatRoomEvent, global::Chess.Contracts.ChatRoomEvent.Builder> internal__static_com_richardpianka_chess_network_ChatRoomEvent__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_ChatUserEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.ChatUserEvent, global::Chess.Contracts.ChatUserEvent.Builder> internal__static_com_richardpianka_chess_network_ChatUserEvent__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_ChatSpeakEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.ChatSpeakEvent, global::Chess.Contracts.ChatSpeakEvent.Builder> internal__static_com_richardpianka_chess_network_ChatSpeakEvent__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_GameListRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.GameListRequest, global::Chess.Contracts.GameListRequest.Builder> internal__static_com_richardpianka_chess_network_GameListRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_GameListResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.GameListResponse, global::Chess.Contracts.GameListResponse.Builder> internal__static_com_richardpianka_chess_network_GameListResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_CreateGameRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.CreateGameRequest, global::Chess.Contracts.CreateGameRequest.Builder> internal__static_com_richardpianka_chess_network_CreateGameRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_CreateGameResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.CreateGameResponse, global::Chess.Contracts.CreateGameResponse.Builder> internal__static_com_richardpianka_chess_network_CreateGameResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinGameRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinGameRequest, global::Chess.Contracts.JoinGameRequest.Builder> internal__static_com_richardpianka_chess_network_JoinGameRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinGameResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinGameResponse, global::Chess.Contracts.JoinGameResponse.Builder> internal__static_com_richardpianka_chess_network_JoinGameResponse__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static Contracts() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "Ch5wcm90b2J1Zi9jaGVzcy9jb250cmFjdHMucHJvdG8SH2NvbS5yaWNoYXJk" + 
          "cGlhbmthLmNoZXNzLm5ldHdvcmsaJHByb3RvYnVmL2dvb2dsZS9jc2hhcnBf" + 
          "b3B0aW9ucy5wcm90byKKBwoIRW52ZWxvcGUSSwoQSGFuZHNoYWtlUmVxdWVz" + 
          "dBgBIAEoCzIxLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuSGFu" + 
          "ZHNoYWtlUmVxdWVzdBJNChFIYW5kc2hha2VSZXNwb25zZRgCIAEoCzIyLmNv" + 
          "bS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuSGFuZHNoYWtlUmVzcG9u" + 
          "c2USSQoPSWRlbnRpZnlSZXF1ZXN0GAMgASgLMjAuY29tLnJpY2hhcmRwaWFu" + 
          "a2EuY2hlc3MubmV0d29yay5JZGVudGlmeVJlcXVlc3QSSwoQSWRlbnRpZnlS" + 
          "ZXNwb25zZRgEIAEoCzIxLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdv" + 
          "cmsuSWRlbnRpZnlSZXNwb25zZRJJCg9Kb2luQ2hhdFJlcXVlc3QYBSABKAsy" + 
          "MC5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLkpvaW5DaGF0UmVx" + 
          "dWVzdBJLChBKb2luQ2hhdFJlc3BvbnNlGAYgASgLMjEuY29tLnJpY2hhcmRw" + 
          "aWFua2EuY2hlc3MubmV0d29yay5Kb2luQ2hhdFJlc3BvbnNlEkkKD0pvaW5S" + 
          "b29tUmVxdWVzdBgHIAEoCzIwLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5l" + 
          "dHdvcmsuSm9pblJvb21SZXF1ZXN0EksKEEpvaW5Sb29tUmVzcG9uc2UYCCAB" + 
          "KAsyMS5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLkpvaW5Sb29t" + 
          "UmVzcG9uc2USQwoMU3BlYWtSZXF1ZXN0GAkgASgLMi0uY29tLnJpY2hhcmRw" + 
          "aWFua2EuY2hlc3MubmV0d29yay5TcGVha1JlcXVlc3QSRQoNQ2hhdFJvb21F" + 
          "dmVudBgKIAEoCzIuLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsu" + 
          "Q2hhdFJvb21FdmVudBJFCg1DaGF0VXNlckV2ZW50GAsgASgLMi4uY29tLnJp" + 
          "Y2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5DaGF0VXNlckV2ZW50EkcKDkNo" + 
          "YXRTcGVha0V2ZW50GAwgASgLMi8uY29tLnJpY2hhcmRwaWFua2EuY2hlc3Mu" + 
          "bmV0d29yay5DaGF0U3BlYWtFdmVudCJXCgdWZXJzaW9uEhcKDFZlcnNpb25N" + 
          "YWpvchgBIAEoDToBMRIXCgxWZXJzaW9uTWlub3IYAiABKA06ATASGgoPVmVy" + 
          "c2lvblJldmlzaW9uGAMgASgNOgEwIk8KBFJvb20SDAoETmFtZRgBIAIoCRI5" + 
          "CgVGbGFncxgCIAIoDjIqLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdv" + 
          "cmsuUm9vbUZsYWdzIk8KBlJlY29yZBIMCgRXaW5zGAEgAigNEg4KBkxvc3Nl" + 
          "cxgCIAIoDRISCgpTdGFsZW1hdGVzGAMgAigNEhMKC0Rpc2Nvbm5lY3RzGAQg" + 
          "AigNIogBCgRVc2VyEgwKBE5hbWUYASACKAkSOQoFRmxhZ3MYAiACKA4yKi5j" + 
          "b20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLlVzZXJGbGFncxI3CgZS" + 
          "ZWNvcmQYAyACKAsyJy5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3Jr" + 
          "LlJlY29yZCKUAQoER2FtZRIMCgROYW1lGAEgAigJEg8KB1ByaXZhdGUYAiAC" + 
          "KAgSNgoHQ3JlYXRvchgDIAEoCzIlLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNz" + 
          "Lm5ldHdvcmsuVXNlchI1CgZKb2luZXIYBCABKAsyJS5jb20ucmljaGFyZHBp" + 
          "YW5rYS5jaGVzcy5uZXR3b3JrLlVzZXIiTQoQSGFuZHNoYWtlUmVxdWVzdBI5" + 
          "CgdWZXJzaW9uGAEgAigLMiguY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0" + 
          "d29yay5WZXJzaW9uIkwKEUhhbmRzaGFrZVJlc3BvbnNlEjcKBlJlc3VsdBgB" + 
          "IAIoDjInLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUmVzdWx0" + 
          "IjUKD0lkZW50aWZ5UmVxdWVzdBIQCghVc2VybmFtZRgBIAIoCRIQCghQYXNz" + 
          "d29yZBgCIAEoCSJcChBJZGVudGlmeVJlc3BvbnNlEjcKBlJlc3VsdBgBIAIo" + 
          "DjInLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUmVzdWx0Eg8K" + 
          "B01lc3NhZ2UYAiABKAkiEQoPSm9pbkNoYXRSZXF1ZXN0IksKEEpvaW5DaGF0" + 
          "UmVzcG9uc2USNwoGUmVzdWx0GAEgAigOMicuY29tLnJpY2hhcmRwaWFua2Eu" + 
          "Y2hlc3MubmV0d29yay5SZXN1bHQiEQoPUm9vbUxpc3RSZXF1ZXN0IkgKEFJv" + 
          "b21MaXN0UmVzcG9uc2USNAoFUm9vbXMYASADKAsyJS5jb20ucmljaGFyZHBp" + 
          "YW5rYS5jaGVzcy5uZXR3b3JrLlJvb20iRgoPSm9pblJvb21SZXF1ZXN0EjMK" + 
          "BFJvb20YASACKAsyJS5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3Jr" + 
          "LlJvb20iSwoQSm9pblJvb21SZXNwb25zZRI3CgZSZXN1bHQYASACKA4yJy5j" + 
          "b20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLlJlc3VsdCKTAQoMU3Bl" + 
          "YWtSZXF1ZXN0EjgKBE1vZGUYASACKA4yKi5jb20ucmljaGFyZHBpYW5rYS5j" + 
          "aGVzcy5uZXR3b3JrLlNwZWFrTW9kZRIPCgdNZXNzYWdlGAIgAigJEjgKCVJl" + 
          "Y2lwaWVudBgDIAEoCzIlLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdv" + 
          "cmsuVXNlciKHAQoPT3BlcmF0b3JSZXF1ZXN0Ej8KBkFjdGlvbhgBIAIoDjIv" + 
          "LmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuT3BlcmF0b3JBY3Rp" + 
          "b24SMwoEVXNlchgCIAEoCzIlLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5l" + 
          "dHdvcmsuVXNlciJLChBPcGVyYXRvclJlc3BvbnNlEjcKBlJlc3VsdBgBIAIo" + 
          "DjInLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUmVzdWx0InoK" + 
          "DUNoYXRSb29tRXZlbnQSMwoEUm9vbRgBIAIoCzIlLmNvbS5yaWNoYXJkcGlh" + 
          "bmthLmNoZXNzLm5ldHdvcmsuUm9vbRI0CgVVc2VycxgCIAMoCzIlLmNvbS5y" + 
          "aWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuVXNlciLQAQoNQ2hhdFVzZXJF" + 
          "dmVudBIzCgRVc2VyGAEgAigLMiUuY29tLnJpY2hhcmRwaWFua2EuY2hlc3Mu" + 
          "bmV0d29yay5Vc2VyEkkKBlN0YXR1cxgCIAIoDjI5LmNvbS5yaWNoYXJkcGlh" + 
          "bmthLmNoZXNzLm5ldHdvcmsuQ2hhdFVzZXJFdmVudC5Vc2VyU3RhdHVzEg8K" + 
          "B01lc3NhZ2UYAyABKAkiLgoKVXNlclN0YXR1cxIKCgZKb2luZWQQABIICgRM" + 
          "ZWZ0EAESCgoGVXBkYXRlEAIikAEKDkNoYXRTcGVha0V2ZW50EjMKBFVzZXIY" + 
          "ASACKAsyJS5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLlVzZXIS" + 
          "DwoHTWVzc2FnZRgCIAIoCRI4CgRNb2RlGAMgAigOMiouY29tLnJpY2hhcmRw" + 
          "aWFua2EuY2hlc3MubmV0d29yay5TcGVha01vZGUiEQoPR2FtZUxpc3RSZXF1" + 
          "ZXN0IkgKEEdhbWVMaXN0UmVzcG9uc2USNAoFR2FtZXMYASADKAsyJS5jb20u" + 
          "cmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLkdhbWUiMwoRQ3JlYXRlR2Ft" + 
          "ZVJlcXVlc3QSDAoETmFtZRgBIAIoCRIQCghQYXNzd29yZBgCIAEoCSKTAQoS" + 
          "Q3JlYXRlR2FtZVJlc3BvbnNlEjcKBlJlc3VsdBgBIAIoDjInLmNvbS5yaWNo" + 
          "YXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUmVzdWx0EjMKBEdhbWUYAiABKAsy" + 
          "JS5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLkdhbWUSDwoHTWVz" + 
          "c2FnZRgDIAEoCSJYCg9Kb2luR2FtZVJlcXVlc3QSMwoER2FtZRgBIAIoCzIl" + 
          "LmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuR2FtZRIQCghQYXNz" + 
          "d29yZBgCIAEoCSJLChBKb2luR2FtZVJlc3BvbnNlEjcKBlJlc3VsdBgBIAIo" + 
          "DjInLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUmVzdWx0KiIK" + 
          "BlJlc3VsdBILCgdTdWNjZXNzEAASCwoHRmFpbHVyZRABKjQKCVJvb21GbGFn" + 
          "cxIKCgZQdWJsaWMQABILCgdQcml2YXRlEAESDgoKUmVzdHJpY3RlZBACKjQK" + 
          "CVVzZXJGbGFncxIOCgpQZWRlc3RyaWFuEAASDAoIT3BlcmF0b3IQARIJCgVB" + 
          "ZG1pbhACKi8KCVNwZWFrTW9kZRIKCgZOb3JtYWwQABILCgdXaGlzcGVyEAES" + 
          "CQoFRW1vdGUQAio+Cg5PcGVyYXRvckFjdGlvbhINCglEZXNpZ25hdGUQABIK" + 
          "CgZSZXNpZ24QARIICgRLaWNrEAISBwoDQmFuEANCTgofY29tLnJpY2hhcmRw" + 
          "aWFua2EuY2hlc3MubmV0d29ya0IJQ29udHJhY3Rzwj4fCg9DaGVzcy5Db250" + 
          "cmFjdHMSCUNvbnRyYWN0c4AOAQ==");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_com_richardpianka_chess_network_Envelope__Descriptor = Descriptor.MessageTypes[0];
        internal__static_com_richardpianka_chess_network_Envelope__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.Envelope, global::Chess.Contracts.Envelope.Builder>(internal__static_com_richardpianka_chess_network_Envelope__Descriptor,
                new string[] { "HandshakeRequest", "HandshakeResponse", "IdentifyRequest", "IdentifyResponse", "JoinChatRequest", "JoinChatResponse", "JoinRoomRequest", "JoinRoomResponse", "SpeakRequest", "ChatRoomEvent", "ChatUserEvent", "ChatSpeakEvent", });
        internal__static_com_richardpianka_chess_network_Version__Descriptor = Descriptor.MessageTypes[1];
        internal__static_com_richardpianka_chess_network_Version__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.Version, global::Chess.Contracts.Version.Builder>(internal__static_com_richardpianka_chess_network_Version__Descriptor,
                new string[] { "VersionMajor", "VersionMinor", "VersionRevision", });
        internal__static_com_richardpianka_chess_network_Room__Descriptor = Descriptor.MessageTypes[2];
        internal__static_com_richardpianka_chess_network_Room__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.Room, global::Chess.Contracts.Room.Builder>(internal__static_com_richardpianka_chess_network_Room__Descriptor,
                new string[] { "Name", "Flags", });
        internal__static_com_richardpianka_chess_network_Record__Descriptor = Descriptor.MessageTypes[3];
        internal__static_com_richardpianka_chess_network_Record__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.Record, global::Chess.Contracts.Record.Builder>(internal__static_com_richardpianka_chess_network_Record__Descriptor,
                new string[] { "Wins", "Losses", "Stalemates", "Disconnects", });
        internal__static_com_richardpianka_chess_network_User__Descriptor = Descriptor.MessageTypes[4];
        internal__static_com_richardpianka_chess_network_User__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.User, global::Chess.Contracts.User.Builder>(internal__static_com_richardpianka_chess_network_User__Descriptor,
                new string[] { "Name", "Flags", "Record", });
        internal__static_com_richardpianka_chess_network_Game__Descriptor = Descriptor.MessageTypes[5];
        internal__static_com_richardpianka_chess_network_Game__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.Game, global::Chess.Contracts.Game.Builder>(internal__static_com_richardpianka_chess_network_Game__Descriptor,
                new string[] { "Name", "Private", "Creator", "Joiner", });
        internal__static_com_richardpianka_chess_network_HandshakeRequest__Descriptor = Descriptor.MessageTypes[6];
        internal__static_com_richardpianka_chess_network_HandshakeRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.HandshakeRequest, global::Chess.Contracts.HandshakeRequest.Builder>(internal__static_com_richardpianka_chess_network_HandshakeRequest__Descriptor,
                new string[] { "Version", });
        internal__static_com_richardpianka_chess_network_HandshakeResponse__Descriptor = Descriptor.MessageTypes[7];
        internal__static_com_richardpianka_chess_network_HandshakeResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.HandshakeResponse, global::Chess.Contracts.HandshakeResponse.Builder>(internal__static_com_richardpianka_chess_network_HandshakeResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_IdentifyRequest__Descriptor = Descriptor.MessageTypes[8];
        internal__static_com_richardpianka_chess_network_IdentifyRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.IdentifyRequest, global::Chess.Contracts.IdentifyRequest.Builder>(internal__static_com_richardpianka_chess_network_IdentifyRequest__Descriptor,
                new string[] { "Username", "Password", });
        internal__static_com_richardpianka_chess_network_IdentifyResponse__Descriptor = Descriptor.MessageTypes[9];
        internal__static_com_richardpianka_chess_network_IdentifyResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.IdentifyResponse, global::Chess.Contracts.IdentifyResponse.Builder>(internal__static_com_richardpianka_chess_network_IdentifyResponse__Descriptor,
                new string[] { "Result", "Message", });
        internal__static_com_richardpianka_chess_network_JoinChatRequest__Descriptor = Descriptor.MessageTypes[10];
        internal__static_com_richardpianka_chess_network_JoinChatRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinChatRequest, global::Chess.Contracts.JoinChatRequest.Builder>(internal__static_com_richardpianka_chess_network_JoinChatRequest__Descriptor,
                new string[] { });
        internal__static_com_richardpianka_chess_network_JoinChatResponse__Descriptor = Descriptor.MessageTypes[11];
        internal__static_com_richardpianka_chess_network_JoinChatResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinChatResponse, global::Chess.Contracts.JoinChatResponse.Builder>(internal__static_com_richardpianka_chess_network_JoinChatResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_RoomListRequest__Descriptor = Descriptor.MessageTypes[12];
        internal__static_com_richardpianka_chess_network_RoomListRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.RoomListRequest, global::Chess.Contracts.RoomListRequest.Builder>(internal__static_com_richardpianka_chess_network_RoomListRequest__Descriptor,
                new string[] { });
        internal__static_com_richardpianka_chess_network_RoomListResponse__Descriptor = Descriptor.MessageTypes[13];
        internal__static_com_richardpianka_chess_network_RoomListResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.RoomListResponse, global::Chess.Contracts.RoomListResponse.Builder>(internal__static_com_richardpianka_chess_network_RoomListResponse__Descriptor,
                new string[] { "Rooms", });
        internal__static_com_richardpianka_chess_network_JoinRoomRequest__Descriptor = Descriptor.MessageTypes[14];
        internal__static_com_richardpianka_chess_network_JoinRoomRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinRoomRequest, global::Chess.Contracts.JoinRoomRequest.Builder>(internal__static_com_richardpianka_chess_network_JoinRoomRequest__Descriptor,
                new string[] { "Room", });
        internal__static_com_richardpianka_chess_network_JoinRoomResponse__Descriptor = Descriptor.MessageTypes[15];
        internal__static_com_richardpianka_chess_network_JoinRoomResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinRoomResponse, global::Chess.Contracts.JoinRoomResponse.Builder>(internal__static_com_richardpianka_chess_network_JoinRoomResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_SpeakRequest__Descriptor = Descriptor.MessageTypes[16];
        internal__static_com_richardpianka_chess_network_SpeakRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.SpeakRequest, global::Chess.Contracts.SpeakRequest.Builder>(internal__static_com_richardpianka_chess_network_SpeakRequest__Descriptor,
                new string[] { "Mode", "Message", "Recipient", });
        internal__static_com_richardpianka_chess_network_OperatorRequest__Descriptor = Descriptor.MessageTypes[17];
        internal__static_com_richardpianka_chess_network_OperatorRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.OperatorRequest, global::Chess.Contracts.OperatorRequest.Builder>(internal__static_com_richardpianka_chess_network_OperatorRequest__Descriptor,
                new string[] { "Action", "User", });
        internal__static_com_richardpianka_chess_network_OperatorResponse__Descriptor = Descriptor.MessageTypes[18];
        internal__static_com_richardpianka_chess_network_OperatorResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.OperatorResponse, global::Chess.Contracts.OperatorResponse.Builder>(internal__static_com_richardpianka_chess_network_OperatorResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_ChatRoomEvent__Descriptor = Descriptor.MessageTypes[19];
        internal__static_com_richardpianka_chess_network_ChatRoomEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.ChatRoomEvent, global::Chess.Contracts.ChatRoomEvent.Builder>(internal__static_com_richardpianka_chess_network_ChatRoomEvent__Descriptor,
                new string[] { "Room", "Users", });
        internal__static_com_richardpianka_chess_network_ChatUserEvent__Descriptor = Descriptor.MessageTypes[20];
        internal__static_com_richardpianka_chess_network_ChatUserEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.ChatUserEvent, global::Chess.Contracts.ChatUserEvent.Builder>(internal__static_com_richardpianka_chess_network_ChatUserEvent__Descriptor,
                new string[] { "User", "Status", "Message", });
        internal__static_com_richardpianka_chess_network_ChatSpeakEvent__Descriptor = Descriptor.MessageTypes[21];
        internal__static_com_richardpianka_chess_network_ChatSpeakEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.ChatSpeakEvent, global::Chess.Contracts.ChatSpeakEvent.Builder>(internal__static_com_richardpianka_chess_network_ChatSpeakEvent__Descriptor,
                new string[] { "User", "Message", "Mode", });
        internal__static_com_richardpianka_chess_network_GameListRequest__Descriptor = Descriptor.MessageTypes[22];
        internal__static_com_richardpianka_chess_network_GameListRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.GameListRequest, global::Chess.Contracts.GameListRequest.Builder>(internal__static_com_richardpianka_chess_network_GameListRequest__Descriptor,
                new string[] { });
        internal__static_com_richardpianka_chess_network_GameListResponse__Descriptor = Descriptor.MessageTypes[23];
        internal__static_com_richardpianka_chess_network_GameListResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.GameListResponse, global::Chess.Contracts.GameListResponse.Builder>(internal__static_com_richardpianka_chess_network_GameListResponse__Descriptor,
                new string[] { "Games", });
        internal__static_com_richardpianka_chess_network_CreateGameRequest__Descriptor = Descriptor.MessageTypes[24];
        internal__static_com_richardpianka_chess_network_CreateGameRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.CreateGameRequest, global::Chess.Contracts.CreateGameRequest.Builder>(internal__static_com_richardpianka_chess_network_CreateGameRequest__Descriptor,
                new string[] { "Name", "Password", });
        internal__static_com_richardpianka_chess_network_CreateGameResponse__Descriptor = Descriptor.MessageTypes[25];
        internal__static_com_richardpianka_chess_network_CreateGameResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.CreateGameResponse, global::Chess.Contracts.CreateGameResponse.Builder>(internal__static_com_richardpianka_chess_network_CreateGameResponse__Descriptor,
                new string[] { "Result", "Game", "Message", });
        internal__static_com_richardpianka_chess_network_JoinGameRequest__Descriptor = Descriptor.MessageTypes[26];
        internal__static_com_richardpianka_chess_network_JoinGameRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinGameRequest, global::Chess.Contracts.JoinGameRequest.Builder>(internal__static_com_richardpianka_chess_network_JoinGameRequest__Descriptor,
                new string[] { "Game", "Password", });
        internal__static_com_richardpianka_chess_network_JoinGameResponse__Descriptor = Descriptor.MessageTypes[27];
        internal__static_com_richardpianka_chess_network_JoinGameResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Chess.Contracts.JoinGameResponse, global::Chess.Contracts.JoinGameResponse.Builder>(internal__static_com_richardpianka_chess_network_JoinGameResponse__Descriptor,
                new string[] { "Result", });
        pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();
        RegisterAllExtensions(registry);
        global::Google.ProtocolBuffers.DescriptorProtos.CSharpOptions.RegisterAllExtensions(registry);
        return registry;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          global::Google.ProtocolBuffers.DescriptorProtos.CSharpOptions.Descriptor, 
          }, assigner);
    }
    #endregion
    
  }
  #region Enums
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum Result {
    Success = 0,
    Failure = 1,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum RoomFlags {
    Public = 0,
    Private = 1,
    Restricted = 2,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum UserFlags {
    Pedestrian = 0,
    Operator = 1,
    Admin = 2,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum SpeakMode {
    Normal = 0,
    Whisper = 1,
    Emote = 2,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum OperatorAction {
    Designate = 0,
    Resign = 1,
    Kick = 2,
    Ban = 3,
  }
  
  #endregion
  
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Envelope : pb::GeneratedMessage<Envelope, Envelope.Builder> {
    private Envelope() { }
    private static readonly Envelope defaultInstance = new Envelope().MakeReadOnly();
    private static readonly string[] _envelopeFieldNames = new string[] { "ChatRoomEvent", "ChatSpeakEvent", "ChatUserEvent", "HandshakeRequest", "HandshakeResponse", "IdentifyRequest", "IdentifyResponse", "JoinChatRequest", "JoinChatResponse", "JoinRoomRequest", "JoinRoomResponse", "SpeakRequest" };
    private static readonly uint[] _envelopeFieldTags = new uint[] { 82, 98, 90, 10, 18, 26, 34, 42, 50, 58, 66, 74 };
    public static Envelope DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Envelope DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Envelope ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_Envelope__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Envelope, Envelope.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_Envelope__FieldAccessorTable; }
    }
    
    public const int HandshakeRequestFieldNumber = 1;
    private bool hasHandshakeRequest;
    private global::Chess.Contracts.HandshakeRequest handshakeRequest_;
    public bool HasHandshakeRequest {
      get { return hasHandshakeRequest; }
    }
    public global::Chess.Contracts.HandshakeRequest HandshakeRequest {
      get { return handshakeRequest_ ?? global::Chess.Contracts.HandshakeRequest.DefaultInstance; }
    }
    
    public const int HandshakeResponseFieldNumber = 2;
    private bool hasHandshakeResponse;
    private global::Chess.Contracts.HandshakeResponse handshakeResponse_;
    public bool HasHandshakeResponse {
      get { return hasHandshakeResponse; }
    }
    public global::Chess.Contracts.HandshakeResponse HandshakeResponse {
      get { return handshakeResponse_ ?? global::Chess.Contracts.HandshakeResponse.DefaultInstance; }
    }
    
    public const int IdentifyRequestFieldNumber = 3;
    private bool hasIdentifyRequest;
    private global::Chess.Contracts.IdentifyRequest identifyRequest_;
    public bool HasIdentifyRequest {
      get { return hasIdentifyRequest; }
    }
    public global::Chess.Contracts.IdentifyRequest IdentifyRequest {
      get { return identifyRequest_ ?? global::Chess.Contracts.IdentifyRequest.DefaultInstance; }
    }
    
    public const int IdentifyResponseFieldNumber = 4;
    private bool hasIdentifyResponse;
    private global::Chess.Contracts.IdentifyResponse identifyResponse_;
    public bool HasIdentifyResponse {
      get { return hasIdentifyResponse; }
    }
    public global::Chess.Contracts.IdentifyResponse IdentifyResponse {
      get { return identifyResponse_ ?? global::Chess.Contracts.IdentifyResponse.DefaultInstance; }
    }
    
    public const int JoinChatRequestFieldNumber = 5;
    private bool hasJoinChatRequest;
    private global::Chess.Contracts.JoinChatRequest joinChatRequest_;
    public bool HasJoinChatRequest {
      get { return hasJoinChatRequest; }
    }
    public global::Chess.Contracts.JoinChatRequest JoinChatRequest {
      get { return joinChatRequest_ ?? global::Chess.Contracts.JoinChatRequest.DefaultInstance; }
    }
    
    public const int JoinChatResponseFieldNumber = 6;
    private bool hasJoinChatResponse;
    private global::Chess.Contracts.JoinChatResponse joinChatResponse_;
    public bool HasJoinChatResponse {
      get { return hasJoinChatResponse; }
    }
    public global::Chess.Contracts.JoinChatResponse JoinChatResponse {
      get { return joinChatResponse_ ?? global::Chess.Contracts.JoinChatResponse.DefaultInstance; }
    }
    
    public const int JoinRoomRequestFieldNumber = 7;
    private bool hasJoinRoomRequest;
    private global::Chess.Contracts.JoinRoomRequest joinRoomRequest_;
    public bool HasJoinRoomRequest {
      get { return hasJoinRoomRequest; }
    }
    public global::Chess.Contracts.JoinRoomRequest JoinRoomRequest {
      get { return joinRoomRequest_ ?? global::Chess.Contracts.JoinRoomRequest.DefaultInstance; }
    }
    
    public const int JoinRoomResponseFieldNumber = 8;
    private bool hasJoinRoomResponse;
    private global::Chess.Contracts.JoinRoomResponse joinRoomResponse_;
    public bool HasJoinRoomResponse {
      get { return hasJoinRoomResponse; }
    }
    public global::Chess.Contracts.JoinRoomResponse JoinRoomResponse {
      get { return joinRoomResponse_ ?? global::Chess.Contracts.JoinRoomResponse.DefaultInstance; }
    }
    
    public const int SpeakRequestFieldNumber = 9;
    private bool hasSpeakRequest;
    private global::Chess.Contracts.SpeakRequest speakRequest_;
    public bool HasSpeakRequest {
      get { return hasSpeakRequest; }
    }
    public global::Chess.Contracts.SpeakRequest SpeakRequest {
      get { return speakRequest_ ?? global::Chess.Contracts.SpeakRequest.DefaultInstance; }
    }
    
    public const int ChatRoomEventFieldNumber = 10;
    private bool hasChatRoomEvent;
    private global::Chess.Contracts.ChatRoomEvent chatRoomEvent_;
    public bool HasChatRoomEvent {
      get { return hasChatRoomEvent; }
    }
    public global::Chess.Contracts.ChatRoomEvent ChatRoomEvent {
      get { return chatRoomEvent_ ?? global::Chess.Contracts.ChatRoomEvent.DefaultInstance; }
    }
    
    public const int ChatUserEventFieldNumber = 11;
    private bool hasChatUserEvent;
    private global::Chess.Contracts.ChatUserEvent chatUserEvent_;
    public bool HasChatUserEvent {
      get { return hasChatUserEvent; }
    }
    public global::Chess.Contracts.ChatUserEvent ChatUserEvent {
      get { return chatUserEvent_ ?? global::Chess.Contracts.ChatUserEvent.DefaultInstance; }
    }
    
    public const int ChatSpeakEventFieldNumber = 12;
    private bool hasChatSpeakEvent;
    private global::Chess.Contracts.ChatSpeakEvent chatSpeakEvent_;
    public bool HasChatSpeakEvent {
      get { return hasChatSpeakEvent; }
    }
    public global::Chess.Contracts.ChatSpeakEvent ChatSpeakEvent {
      get { return chatSpeakEvent_ ?? global::Chess.Contracts.ChatSpeakEvent.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasHandshakeRequest) {
          if (!HandshakeRequest.IsInitialized) return false;
        }
        if (HasHandshakeResponse) {
          if (!HandshakeResponse.IsInitialized) return false;
        }
        if (HasIdentifyRequest) {
          if (!IdentifyRequest.IsInitialized) return false;
        }
        if (HasIdentifyResponse) {
          if (!IdentifyResponse.IsInitialized) return false;
        }
        if (HasJoinChatResponse) {
          if (!JoinChatResponse.IsInitialized) return false;
        }
        if (HasJoinRoomRequest) {
          if (!JoinRoomRequest.IsInitialized) return false;
        }
        if (HasJoinRoomResponse) {
          if (!JoinRoomResponse.IsInitialized) return false;
        }
        if (HasSpeakRequest) {
          if (!SpeakRequest.IsInitialized) return false;
        }
        if (HasChatRoomEvent) {
          if (!ChatRoomEvent.IsInitialized) return false;
        }
        if (HasChatUserEvent) {
          if (!ChatUserEvent.IsInitialized) return false;
        }
        if (HasChatSpeakEvent) {
          if (!ChatSpeakEvent.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _envelopeFieldNames;
      if (hasHandshakeRequest) {
        output.WriteMessage(1, field_names[3], HandshakeRequest);
      }
      if (hasHandshakeResponse) {
        output.WriteMessage(2, field_names[4], HandshakeResponse);
      }
      if (hasIdentifyRequest) {
        output.WriteMessage(3, field_names[5], IdentifyRequest);
      }
      if (hasIdentifyResponse) {
        output.WriteMessage(4, field_names[6], IdentifyResponse);
      }
      if (hasJoinChatRequest) {
        output.WriteMessage(5, field_names[7], JoinChatRequest);
      }
      if (hasJoinChatResponse) {
        output.WriteMessage(6, field_names[8], JoinChatResponse);
      }
      if (hasJoinRoomRequest) {
        output.WriteMessage(7, field_names[9], JoinRoomRequest);
      }
      if (hasJoinRoomResponse) {
        output.WriteMessage(8, field_names[10], JoinRoomResponse);
      }
      if (hasSpeakRequest) {
        output.WriteMessage(9, field_names[11], SpeakRequest);
      }
      if (hasChatRoomEvent) {
        output.WriteMessage(10, field_names[0], ChatRoomEvent);
      }
      if (hasChatUserEvent) {
        output.WriteMessage(11, field_names[2], ChatUserEvent);
      }
      if (hasChatSpeakEvent) {
        output.WriteMessage(12, field_names[1], ChatSpeakEvent);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasHandshakeRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, HandshakeRequest);
        }
        if (hasHandshakeResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, HandshakeResponse);
        }
        if (hasIdentifyRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, IdentifyRequest);
        }
        if (hasIdentifyResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, IdentifyResponse);
        }
        if (hasJoinChatRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(5, JoinChatRequest);
        }
        if (hasJoinChatResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(6, JoinChatResponse);
        }
        if (hasJoinRoomRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(7, JoinRoomRequest);
        }
        if (hasJoinRoomResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(8, JoinRoomResponse);
        }
        if (hasSpeakRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(9, SpeakRequest);
        }
        if (hasChatRoomEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(10, ChatRoomEvent);
        }
        if (hasChatUserEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(11, ChatUserEvent);
        }
        if (hasChatSpeakEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(12, ChatSpeakEvent);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Envelope ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Envelope ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Envelope ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Envelope ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Envelope ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Envelope ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Envelope ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Envelope ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Envelope ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Envelope ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Envelope MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Envelope prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Envelope, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Envelope cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Envelope result;
      
      private Envelope PrepareBuilder() {
        if (resultIsReadOnly) {
          Envelope original = result;
          result = new Envelope();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Envelope MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.Envelope.Descriptor; }
      }
      
      public override Envelope DefaultInstanceForType {
        get { return global::Chess.Contracts.Envelope.DefaultInstance; }
      }
      
      public override Envelope BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Envelope) {
          return MergeFrom((Envelope) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Envelope other) {
        if (other == global::Chess.Contracts.Envelope.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasHandshakeRequest) {
          MergeHandshakeRequest(other.HandshakeRequest);
        }
        if (other.HasHandshakeResponse) {
          MergeHandshakeResponse(other.HandshakeResponse);
        }
        if (other.HasIdentifyRequest) {
          MergeIdentifyRequest(other.IdentifyRequest);
        }
        if (other.HasIdentifyResponse) {
          MergeIdentifyResponse(other.IdentifyResponse);
        }
        if (other.HasJoinChatRequest) {
          MergeJoinChatRequest(other.JoinChatRequest);
        }
        if (other.HasJoinChatResponse) {
          MergeJoinChatResponse(other.JoinChatResponse);
        }
        if (other.HasJoinRoomRequest) {
          MergeJoinRoomRequest(other.JoinRoomRequest);
        }
        if (other.HasJoinRoomResponse) {
          MergeJoinRoomResponse(other.JoinRoomResponse);
        }
        if (other.HasSpeakRequest) {
          MergeSpeakRequest(other.SpeakRequest);
        }
        if (other.HasChatRoomEvent) {
          MergeChatRoomEvent(other.ChatRoomEvent);
        }
        if (other.HasChatUserEvent) {
          MergeChatUserEvent(other.ChatUserEvent);
        }
        if (other.HasChatSpeakEvent) {
          MergeChatSpeakEvent(other.ChatSpeakEvent);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_envelopeFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _envelopeFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Chess.Contracts.HandshakeRequest.Builder subBuilder = global::Chess.Contracts.HandshakeRequest.CreateBuilder();
              if (result.hasHandshakeRequest) {
                subBuilder.MergeFrom(HandshakeRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              HandshakeRequest = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::Chess.Contracts.HandshakeResponse.Builder subBuilder = global::Chess.Contracts.HandshakeResponse.CreateBuilder();
              if (result.hasHandshakeResponse) {
                subBuilder.MergeFrom(HandshakeResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              HandshakeResponse = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::Chess.Contracts.IdentifyRequest.Builder subBuilder = global::Chess.Contracts.IdentifyRequest.CreateBuilder();
              if (result.hasIdentifyRequest) {
                subBuilder.MergeFrom(IdentifyRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              IdentifyRequest = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::Chess.Contracts.IdentifyResponse.Builder subBuilder = global::Chess.Contracts.IdentifyResponse.CreateBuilder();
              if (result.hasIdentifyResponse) {
                subBuilder.MergeFrom(IdentifyResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              IdentifyResponse = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              global::Chess.Contracts.JoinChatRequest.Builder subBuilder = global::Chess.Contracts.JoinChatRequest.CreateBuilder();
              if (result.hasJoinChatRequest) {
                subBuilder.MergeFrom(JoinChatRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JoinChatRequest = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              global::Chess.Contracts.JoinChatResponse.Builder subBuilder = global::Chess.Contracts.JoinChatResponse.CreateBuilder();
              if (result.hasJoinChatResponse) {
                subBuilder.MergeFrom(JoinChatResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JoinChatResponse = subBuilder.BuildPartial();
              break;
            }
            case 58: {
              global::Chess.Contracts.JoinRoomRequest.Builder subBuilder = global::Chess.Contracts.JoinRoomRequest.CreateBuilder();
              if (result.hasJoinRoomRequest) {
                subBuilder.MergeFrom(JoinRoomRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JoinRoomRequest = subBuilder.BuildPartial();
              break;
            }
            case 66: {
              global::Chess.Contracts.JoinRoomResponse.Builder subBuilder = global::Chess.Contracts.JoinRoomResponse.CreateBuilder();
              if (result.hasJoinRoomResponse) {
                subBuilder.MergeFrom(JoinRoomResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JoinRoomResponse = subBuilder.BuildPartial();
              break;
            }
            case 74: {
              global::Chess.Contracts.SpeakRequest.Builder subBuilder = global::Chess.Contracts.SpeakRequest.CreateBuilder();
              if (result.hasSpeakRequest) {
                subBuilder.MergeFrom(SpeakRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              SpeakRequest = subBuilder.BuildPartial();
              break;
            }
            case 82: {
              global::Chess.Contracts.ChatRoomEvent.Builder subBuilder = global::Chess.Contracts.ChatRoomEvent.CreateBuilder();
              if (result.hasChatRoomEvent) {
                subBuilder.MergeFrom(ChatRoomEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ChatRoomEvent = subBuilder.BuildPartial();
              break;
            }
            case 90: {
              global::Chess.Contracts.ChatUserEvent.Builder subBuilder = global::Chess.Contracts.ChatUserEvent.CreateBuilder();
              if (result.hasChatUserEvent) {
                subBuilder.MergeFrom(ChatUserEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ChatUserEvent = subBuilder.BuildPartial();
              break;
            }
            case 98: {
              global::Chess.Contracts.ChatSpeakEvent.Builder subBuilder = global::Chess.Contracts.ChatSpeakEvent.CreateBuilder();
              if (result.hasChatSpeakEvent) {
                subBuilder.MergeFrom(ChatSpeakEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ChatSpeakEvent = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasHandshakeRequest {
       get { return result.hasHandshakeRequest; }
      }
      public global::Chess.Contracts.HandshakeRequest HandshakeRequest {
        get { return result.HandshakeRequest; }
        set { SetHandshakeRequest(value); }
      }
      public Builder SetHandshakeRequest(global::Chess.Contracts.HandshakeRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHandshakeRequest = true;
        result.handshakeRequest_ = value;
        return this;
      }
      public Builder SetHandshakeRequest(global::Chess.Contracts.HandshakeRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHandshakeRequest = true;
        result.handshakeRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHandshakeRequest(global::Chess.Contracts.HandshakeRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasHandshakeRequest &&
            result.handshakeRequest_ != global::Chess.Contracts.HandshakeRequest.DefaultInstance) {
            result.handshakeRequest_ = global::Chess.Contracts.HandshakeRequest.CreateBuilder(result.handshakeRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.handshakeRequest_ = value;
        }
        result.hasHandshakeRequest = true;
        return this;
      }
      public Builder ClearHandshakeRequest() {
        PrepareBuilder();
        result.hasHandshakeRequest = false;
        result.handshakeRequest_ = null;
        return this;
      }
      
      public bool HasHandshakeResponse {
       get { return result.hasHandshakeResponse; }
      }
      public global::Chess.Contracts.HandshakeResponse HandshakeResponse {
        get { return result.HandshakeResponse; }
        set { SetHandshakeResponse(value); }
      }
      public Builder SetHandshakeResponse(global::Chess.Contracts.HandshakeResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHandshakeResponse = true;
        result.handshakeResponse_ = value;
        return this;
      }
      public Builder SetHandshakeResponse(global::Chess.Contracts.HandshakeResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHandshakeResponse = true;
        result.handshakeResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHandshakeResponse(global::Chess.Contracts.HandshakeResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasHandshakeResponse &&
            result.handshakeResponse_ != global::Chess.Contracts.HandshakeResponse.DefaultInstance) {
            result.handshakeResponse_ = global::Chess.Contracts.HandshakeResponse.CreateBuilder(result.handshakeResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.handshakeResponse_ = value;
        }
        result.hasHandshakeResponse = true;
        return this;
      }
      public Builder ClearHandshakeResponse() {
        PrepareBuilder();
        result.hasHandshakeResponse = false;
        result.handshakeResponse_ = null;
        return this;
      }
      
      public bool HasIdentifyRequest {
       get { return result.hasIdentifyRequest; }
      }
      public global::Chess.Contracts.IdentifyRequest IdentifyRequest {
        get { return result.IdentifyRequest; }
        set { SetIdentifyRequest(value); }
      }
      public Builder SetIdentifyRequest(global::Chess.Contracts.IdentifyRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasIdentifyRequest = true;
        result.identifyRequest_ = value;
        return this;
      }
      public Builder SetIdentifyRequest(global::Chess.Contracts.IdentifyRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasIdentifyRequest = true;
        result.identifyRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeIdentifyRequest(global::Chess.Contracts.IdentifyRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasIdentifyRequest &&
            result.identifyRequest_ != global::Chess.Contracts.IdentifyRequest.DefaultInstance) {
            result.identifyRequest_ = global::Chess.Contracts.IdentifyRequest.CreateBuilder(result.identifyRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.identifyRequest_ = value;
        }
        result.hasIdentifyRequest = true;
        return this;
      }
      public Builder ClearIdentifyRequest() {
        PrepareBuilder();
        result.hasIdentifyRequest = false;
        result.identifyRequest_ = null;
        return this;
      }
      
      public bool HasIdentifyResponse {
       get { return result.hasIdentifyResponse; }
      }
      public global::Chess.Contracts.IdentifyResponse IdentifyResponse {
        get { return result.IdentifyResponse; }
        set { SetIdentifyResponse(value); }
      }
      public Builder SetIdentifyResponse(global::Chess.Contracts.IdentifyResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasIdentifyResponse = true;
        result.identifyResponse_ = value;
        return this;
      }
      public Builder SetIdentifyResponse(global::Chess.Contracts.IdentifyResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasIdentifyResponse = true;
        result.identifyResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeIdentifyResponse(global::Chess.Contracts.IdentifyResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasIdentifyResponse &&
            result.identifyResponse_ != global::Chess.Contracts.IdentifyResponse.DefaultInstance) {
            result.identifyResponse_ = global::Chess.Contracts.IdentifyResponse.CreateBuilder(result.identifyResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.identifyResponse_ = value;
        }
        result.hasIdentifyResponse = true;
        return this;
      }
      public Builder ClearIdentifyResponse() {
        PrepareBuilder();
        result.hasIdentifyResponse = false;
        result.identifyResponse_ = null;
        return this;
      }
      
      public bool HasJoinChatRequest {
       get { return result.hasJoinChatRequest; }
      }
      public global::Chess.Contracts.JoinChatRequest JoinChatRequest {
        get { return result.JoinChatRequest; }
        set { SetJoinChatRequest(value); }
      }
      public Builder SetJoinChatRequest(global::Chess.Contracts.JoinChatRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoinChatRequest = true;
        result.joinChatRequest_ = value;
        return this;
      }
      public Builder SetJoinChatRequest(global::Chess.Contracts.JoinChatRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoinChatRequest = true;
        result.joinChatRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoinChatRequest(global::Chess.Contracts.JoinChatRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoinChatRequest &&
            result.joinChatRequest_ != global::Chess.Contracts.JoinChatRequest.DefaultInstance) {
            result.joinChatRequest_ = global::Chess.Contracts.JoinChatRequest.CreateBuilder(result.joinChatRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.joinChatRequest_ = value;
        }
        result.hasJoinChatRequest = true;
        return this;
      }
      public Builder ClearJoinChatRequest() {
        PrepareBuilder();
        result.hasJoinChatRequest = false;
        result.joinChatRequest_ = null;
        return this;
      }
      
      public bool HasJoinChatResponse {
       get { return result.hasJoinChatResponse; }
      }
      public global::Chess.Contracts.JoinChatResponse JoinChatResponse {
        get { return result.JoinChatResponse; }
        set { SetJoinChatResponse(value); }
      }
      public Builder SetJoinChatResponse(global::Chess.Contracts.JoinChatResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoinChatResponse = true;
        result.joinChatResponse_ = value;
        return this;
      }
      public Builder SetJoinChatResponse(global::Chess.Contracts.JoinChatResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoinChatResponse = true;
        result.joinChatResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoinChatResponse(global::Chess.Contracts.JoinChatResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoinChatResponse &&
            result.joinChatResponse_ != global::Chess.Contracts.JoinChatResponse.DefaultInstance) {
            result.joinChatResponse_ = global::Chess.Contracts.JoinChatResponse.CreateBuilder(result.joinChatResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.joinChatResponse_ = value;
        }
        result.hasJoinChatResponse = true;
        return this;
      }
      public Builder ClearJoinChatResponse() {
        PrepareBuilder();
        result.hasJoinChatResponse = false;
        result.joinChatResponse_ = null;
        return this;
      }
      
      public bool HasJoinRoomRequest {
       get { return result.hasJoinRoomRequest; }
      }
      public global::Chess.Contracts.JoinRoomRequest JoinRoomRequest {
        get { return result.JoinRoomRequest; }
        set { SetJoinRoomRequest(value); }
      }
      public Builder SetJoinRoomRequest(global::Chess.Contracts.JoinRoomRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoinRoomRequest = true;
        result.joinRoomRequest_ = value;
        return this;
      }
      public Builder SetJoinRoomRequest(global::Chess.Contracts.JoinRoomRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoinRoomRequest = true;
        result.joinRoomRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoinRoomRequest(global::Chess.Contracts.JoinRoomRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoinRoomRequest &&
            result.joinRoomRequest_ != global::Chess.Contracts.JoinRoomRequest.DefaultInstance) {
            result.joinRoomRequest_ = global::Chess.Contracts.JoinRoomRequest.CreateBuilder(result.joinRoomRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.joinRoomRequest_ = value;
        }
        result.hasJoinRoomRequest = true;
        return this;
      }
      public Builder ClearJoinRoomRequest() {
        PrepareBuilder();
        result.hasJoinRoomRequest = false;
        result.joinRoomRequest_ = null;
        return this;
      }
      
      public bool HasJoinRoomResponse {
       get { return result.hasJoinRoomResponse; }
      }
      public global::Chess.Contracts.JoinRoomResponse JoinRoomResponse {
        get { return result.JoinRoomResponse; }
        set { SetJoinRoomResponse(value); }
      }
      public Builder SetJoinRoomResponse(global::Chess.Contracts.JoinRoomResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoinRoomResponse = true;
        result.joinRoomResponse_ = value;
        return this;
      }
      public Builder SetJoinRoomResponse(global::Chess.Contracts.JoinRoomResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoinRoomResponse = true;
        result.joinRoomResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoinRoomResponse(global::Chess.Contracts.JoinRoomResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoinRoomResponse &&
            result.joinRoomResponse_ != global::Chess.Contracts.JoinRoomResponse.DefaultInstance) {
            result.joinRoomResponse_ = global::Chess.Contracts.JoinRoomResponse.CreateBuilder(result.joinRoomResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.joinRoomResponse_ = value;
        }
        result.hasJoinRoomResponse = true;
        return this;
      }
      public Builder ClearJoinRoomResponse() {
        PrepareBuilder();
        result.hasJoinRoomResponse = false;
        result.joinRoomResponse_ = null;
        return this;
      }
      
      public bool HasSpeakRequest {
       get { return result.hasSpeakRequest; }
      }
      public global::Chess.Contracts.SpeakRequest SpeakRequest {
        get { return result.SpeakRequest; }
        set { SetSpeakRequest(value); }
      }
      public Builder SetSpeakRequest(global::Chess.Contracts.SpeakRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSpeakRequest = true;
        result.speakRequest_ = value;
        return this;
      }
      public Builder SetSpeakRequest(global::Chess.Contracts.SpeakRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasSpeakRequest = true;
        result.speakRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeSpeakRequest(global::Chess.Contracts.SpeakRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasSpeakRequest &&
            result.speakRequest_ != global::Chess.Contracts.SpeakRequest.DefaultInstance) {
            result.speakRequest_ = global::Chess.Contracts.SpeakRequest.CreateBuilder(result.speakRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.speakRequest_ = value;
        }
        result.hasSpeakRequest = true;
        return this;
      }
      public Builder ClearSpeakRequest() {
        PrepareBuilder();
        result.hasSpeakRequest = false;
        result.speakRequest_ = null;
        return this;
      }
      
      public bool HasChatRoomEvent {
       get { return result.hasChatRoomEvent; }
      }
      public global::Chess.Contracts.ChatRoomEvent ChatRoomEvent {
        get { return result.ChatRoomEvent; }
        set { SetChatRoomEvent(value); }
      }
      public Builder SetChatRoomEvent(global::Chess.Contracts.ChatRoomEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChatRoomEvent = true;
        result.chatRoomEvent_ = value;
        return this;
      }
      public Builder SetChatRoomEvent(global::Chess.Contracts.ChatRoomEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasChatRoomEvent = true;
        result.chatRoomEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeChatRoomEvent(global::Chess.Contracts.ChatRoomEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasChatRoomEvent &&
            result.chatRoomEvent_ != global::Chess.Contracts.ChatRoomEvent.DefaultInstance) {
            result.chatRoomEvent_ = global::Chess.Contracts.ChatRoomEvent.CreateBuilder(result.chatRoomEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.chatRoomEvent_ = value;
        }
        result.hasChatRoomEvent = true;
        return this;
      }
      public Builder ClearChatRoomEvent() {
        PrepareBuilder();
        result.hasChatRoomEvent = false;
        result.chatRoomEvent_ = null;
        return this;
      }
      
      public bool HasChatUserEvent {
       get { return result.hasChatUserEvent; }
      }
      public global::Chess.Contracts.ChatUserEvent ChatUserEvent {
        get { return result.ChatUserEvent; }
        set { SetChatUserEvent(value); }
      }
      public Builder SetChatUserEvent(global::Chess.Contracts.ChatUserEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChatUserEvent = true;
        result.chatUserEvent_ = value;
        return this;
      }
      public Builder SetChatUserEvent(global::Chess.Contracts.ChatUserEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasChatUserEvent = true;
        result.chatUserEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeChatUserEvent(global::Chess.Contracts.ChatUserEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasChatUserEvent &&
            result.chatUserEvent_ != global::Chess.Contracts.ChatUserEvent.DefaultInstance) {
            result.chatUserEvent_ = global::Chess.Contracts.ChatUserEvent.CreateBuilder(result.chatUserEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.chatUserEvent_ = value;
        }
        result.hasChatUserEvent = true;
        return this;
      }
      public Builder ClearChatUserEvent() {
        PrepareBuilder();
        result.hasChatUserEvent = false;
        result.chatUserEvent_ = null;
        return this;
      }
      
      public bool HasChatSpeakEvent {
       get { return result.hasChatSpeakEvent; }
      }
      public global::Chess.Contracts.ChatSpeakEvent ChatSpeakEvent {
        get { return result.ChatSpeakEvent; }
        set { SetChatSpeakEvent(value); }
      }
      public Builder SetChatSpeakEvent(global::Chess.Contracts.ChatSpeakEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChatSpeakEvent = true;
        result.chatSpeakEvent_ = value;
        return this;
      }
      public Builder SetChatSpeakEvent(global::Chess.Contracts.ChatSpeakEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasChatSpeakEvent = true;
        result.chatSpeakEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeChatSpeakEvent(global::Chess.Contracts.ChatSpeakEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasChatSpeakEvent &&
            result.chatSpeakEvent_ != global::Chess.Contracts.ChatSpeakEvent.DefaultInstance) {
            result.chatSpeakEvent_ = global::Chess.Contracts.ChatSpeakEvent.CreateBuilder(result.chatSpeakEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.chatSpeakEvent_ = value;
        }
        result.hasChatSpeakEvent = true;
        return this;
      }
      public Builder ClearChatSpeakEvent() {
        PrepareBuilder();
        result.hasChatSpeakEvent = false;
        result.chatSpeakEvent_ = null;
        return this;
      }
    }
    static Envelope() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Version : pb::GeneratedMessage<Version, Version.Builder> {
    private Version() { }
    private static readonly Version defaultInstance = new Version().MakeReadOnly();
    private static readonly string[] _versionFieldNames = new string[] { "VersionMajor", "VersionMinor", "VersionRevision" };
    private static readonly uint[] _versionFieldTags = new uint[] { 8, 16, 24 };
    public static Version DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Version DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Version ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_Version__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Version, Version.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_Version__FieldAccessorTable; }
    }
    
    public const int VersionMajorFieldNumber = 1;
    private bool hasVersionMajor;
    private uint versionMajor_ = 1;
    public bool HasVersionMajor {
      get { return hasVersionMajor; }
    }
    [global::System.CLSCompliant(false)]
    public uint VersionMajor {
      get { return versionMajor_; }
    }
    
    public const int VersionMinorFieldNumber = 2;
    private bool hasVersionMinor;
    private uint versionMinor_;
    public bool HasVersionMinor {
      get { return hasVersionMinor; }
    }
    [global::System.CLSCompliant(false)]
    public uint VersionMinor {
      get { return versionMinor_; }
    }
    
    public const int VersionRevisionFieldNumber = 3;
    private bool hasVersionRevision;
    private uint versionRevision_;
    public bool HasVersionRevision {
      get { return hasVersionRevision; }
    }
    [global::System.CLSCompliant(false)]
    public uint VersionRevision {
      get { return versionRevision_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _versionFieldNames;
      if (hasVersionMajor) {
        output.WriteUInt32(1, field_names[0], VersionMajor);
      }
      if (hasVersionMinor) {
        output.WriteUInt32(2, field_names[1], VersionMinor);
      }
      if (hasVersionRevision) {
        output.WriteUInt32(3, field_names[2], VersionRevision);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasVersionMajor) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, VersionMajor);
        }
        if (hasVersionMinor) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, VersionMinor);
        }
        if (hasVersionRevision) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, VersionRevision);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Version ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Version ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Version ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Version ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Version ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Version ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Version ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Version ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Version ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Version ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Version MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Version prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Version, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Version cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Version result;
      
      private Version PrepareBuilder() {
        if (resultIsReadOnly) {
          Version original = result;
          result = new Version();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Version MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.Version.Descriptor; }
      }
      
      public override Version DefaultInstanceForType {
        get { return global::Chess.Contracts.Version.DefaultInstance; }
      }
      
      public override Version BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Version) {
          return MergeFrom((Version) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Version other) {
        if (other == global::Chess.Contracts.Version.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasVersionMajor) {
          VersionMajor = other.VersionMajor;
        }
        if (other.HasVersionMinor) {
          VersionMinor = other.VersionMinor;
        }
        if (other.HasVersionRevision) {
          VersionRevision = other.VersionRevision;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_versionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _versionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasVersionMajor = input.ReadUInt32(ref result.versionMajor_);
              break;
            }
            case 16: {
              result.hasVersionMinor = input.ReadUInt32(ref result.versionMinor_);
              break;
            }
            case 24: {
              result.hasVersionRevision = input.ReadUInt32(ref result.versionRevision_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasVersionMajor {
        get { return result.hasVersionMajor; }
      }
      [global::System.CLSCompliant(false)]
      public uint VersionMajor {
        get { return result.VersionMajor; }
        set { SetVersionMajor(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetVersionMajor(uint value) {
        PrepareBuilder();
        result.hasVersionMajor = true;
        result.versionMajor_ = value;
        return this;
      }
      public Builder ClearVersionMajor() {
        PrepareBuilder();
        result.hasVersionMajor = false;
        result.versionMajor_ = 1;
        return this;
      }
      
      public bool HasVersionMinor {
        get { return result.hasVersionMinor; }
      }
      [global::System.CLSCompliant(false)]
      public uint VersionMinor {
        get { return result.VersionMinor; }
        set { SetVersionMinor(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetVersionMinor(uint value) {
        PrepareBuilder();
        result.hasVersionMinor = true;
        result.versionMinor_ = value;
        return this;
      }
      public Builder ClearVersionMinor() {
        PrepareBuilder();
        result.hasVersionMinor = false;
        result.versionMinor_ = 0;
        return this;
      }
      
      public bool HasVersionRevision {
        get { return result.hasVersionRevision; }
      }
      [global::System.CLSCompliant(false)]
      public uint VersionRevision {
        get { return result.VersionRevision; }
        set { SetVersionRevision(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetVersionRevision(uint value) {
        PrepareBuilder();
        result.hasVersionRevision = true;
        result.versionRevision_ = value;
        return this;
      }
      public Builder ClearVersionRevision() {
        PrepareBuilder();
        result.hasVersionRevision = false;
        result.versionRevision_ = 0;
        return this;
      }
    }
    static Version() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Room : pb::GeneratedMessage<Room, Room.Builder> {
    private Room() { }
    private static readonly Room defaultInstance = new Room().MakeReadOnly();
    private static readonly string[] _roomFieldNames = new string[] { "Flags", "Name" };
    private static readonly uint[] _roomFieldTags = new uint[] { 16, 10 };
    public static Room DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Room DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Room ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_Room__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Room, Room.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_Room__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int FlagsFieldNumber = 2;
    private bool hasFlags;
    private global::Chess.Contracts.RoomFlags flags_ = global::Chess.Contracts.RoomFlags.Public;
    public bool HasFlags {
      get { return hasFlags; }
    }
    public global::Chess.Contracts.RoomFlags Flags {
      get { return flags_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        if (!hasFlags) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _roomFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[1], Name);
      }
      if (hasFlags) {
        output.WriteEnum(2, field_names[0], (int) Flags, Flags);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasFlags) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Flags);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Room ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Room ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Room ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Room ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Room ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Room ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Room ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Room ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Room ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Room ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Room MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Room prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Room, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Room cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Room result;
      
      private Room PrepareBuilder() {
        if (resultIsReadOnly) {
          Room original = result;
          result = new Room();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Room MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.Room.Descriptor; }
      }
      
      public override Room DefaultInstanceForType {
        get { return global::Chess.Contracts.Room.DefaultInstance; }
      }
      
      public override Room BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Room) {
          return MergeFrom((Room) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Room other) {
        if (other == global::Chess.Contracts.Room.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasFlags) {
          Flags = other.Flags;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_roomFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _roomFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.flags_, out unknown)) {
                result.hasFlags = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasFlags {
       get { return result.hasFlags; }
      }
      public global::Chess.Contracts.RoomFlags Flags {
        get { return result.Flags; }
        set { SetFlags(value); }
      }
      public Builder SetFlags(global::Chess.Contracts.RoomFlags value) {
        PrepareBuilder();
        result.hasFlags = true;
        result.flags_ = value;
        return this;
      }
      public Builder ClearFlags() {
        PrepareBuilder();
        result.hasFlags = false;
        result.flags_ = global::Chess.Contracts.RoomFlags.Public;
        return this;
      }
    }
    static Room() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Record : pb::GeneratedMessage<Record, Record.Builder> {
    private Record() { }
    private static readonly Record defaultInstance = new Record().MakeReadOnly();
    private static readonly string[] _recordFieldNames = new string[] { "Disconnects", "Losses", "Stalemates", "Wins" };
    private static readonly uint[] _recordFieldTags = new uint[] { 32, 16, 24, 8 };
    public static Record DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Record DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Record ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_Record__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Record, Record.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_Record__FieldAccessorTable; }
    }
    
    public const int WinsFieldNumber = 1;
    private bool hasWins;
    private uint wins_;
    public bool HasWins {
      get { return hasWins; }
    }
    [global::System.CLSCompliant(false)]
    public uint Wins {
      get { return wins_; }
    }
    
    public const int LossesFieldNumber = 2;
    private bool hasLosses;
    private uint losses_;
    public bool HasLosses {
      get { return hasLosses; }
    }
    [global::System.CLSCompliant(false)]
    public uint Losses {
      get { return losses_; }
    }
    
    public const int StalematesFieldNumber = 3;
    private bool hasStalemates;
    private uint stalemates_;
    public bool HasStalemates {
      get { return hasStalemates; }
    }
    [global::System.CLSCompliant(false)]
    public uint Stalemates {
      get { return stalemates_; }
    }
    
    public const int DisconnectsFieldNumber = 4;
    private bool hasDisconnects;
    private uint disconnects_;
    public bool HasDisconnects {
      get { return hasDisconnects; }
    }
    [global::System.CLSCompliant(false)]
    public uint Disconnects {
      get { return disconnects_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasWins) return false;
        if (!hasLosses) return false;
        if (!hasStalemates) return false;
        if (!hasDisconnects) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _recordFieldNames;
      if (hasWins) {
        output.WriteUInt32(1, field_names[3], Wins);
      }
      if (hasLosses) {
        output.WriteUInt32(2, field_names[1], Losses);
      }
      if (hasStalemates) {
        output.WriteUInt32(3, field_names[2], Stalemates);
      }
      if (hasDisconnects) {
        output.WriteUInt32(4, field_names[0], Disconnects);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasWins) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Wins);
        }
        if (hasLosses) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, Losses);
        }
        if (hasStalemates) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, Stalemates);
        }
        if (hasDisconnects) {
          size += pb::CodedOutputStream.ComputeUInt32Size(4, Disconnects);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Record ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Record ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Record ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Record ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Record ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Record ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Record ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Record ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Record ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Record ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Record MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Record prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Record, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Record cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Record result;
      
      private Record PrepareBuilder() {
        if (resultIsReadOnly) {
          Record original = result;
          result = new Record();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Record MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.Record.Descriptor; }
      }
      
      public override Record DefaultInstanceForType {
        get { return global::Chess.Contracts.Record.DefaultInstance; }
      }
      
      public override Record BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Record) {
          return MergeFrom((Record) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Record other) {
        if (other == global::Chess.Contracts.Record.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasWins) {
          Wins = other.Wins;
        }
        if (other.HasLosses) {
          Losses = other.Losses;
        }
        if (other.HasStalemates) {
          Stalemates = other.Stalemates;
        }
        if (other.HasDisconnects) {
          Disconnects = other.Disconnects;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_recordFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _recordFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasWins = input.ReadUInt32(ref result.wins_);
              break;
            }
            case 16: {
              result.hasLosses = input.ReadUInt32(ref result.losses_);
              break;
            }
            case 24: {
              result.hasStalemates = input.ReadUInt32(ref result.stalemates_);
              break;
            }
            case 32: {
              result.hasDisconnects = input.ReadUInt32(ref result.disconnects_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasWins {
        get { return result.hasWins; }
      }
      [global::System.CLSCompliant(false)]
      public uint Wins {
        get { return result.Wins; }
        set { SetWins(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetWins(uint value) {
        PrepareBuilder();
        result.hasWins = true;
        result.wins_ = value;
        return this;
      }
      public Builder ClearWins() {
        PrepareBuilder();
        result.hasWins = false;
        result.wins_ = 0;
        return this;
      }
      
      public bool HasLosses {
        get { return result.hasLosses; }
      }
      [global::System.CLSCompliant(false)]
      public uint Losses {
        get { return result.Losses; }
        set { SetLosses(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetLosses(uint value) {
        PrepareBuilder();
        result.hasLosses = true;
        result.losses_ = value;
        return this;
      }
      public Builder ClearLosses() {
        PrepareBuilder();
        result.hasLosses = false;
        result.losses_ = 0;
        return this;
      }
      
      public bool HasStalemates {
        get { return result.hasStalemates; }
      }
      [global::System.CLSCompliant(false)]
      public uint Stalemates {
        get { return result.Stalemates; }
        set { SetStalemates(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetStalemates(uint value) {
        PrepareBuilder();
        result.hasStalemates = true;
        result.stalemates_ = value;
        return this;
      }
      public Builder ClearStalemates() {
        PrepareBuilder();
        result.hasStalemates = false;
        result.stalemates_ = 0;
        return this;
      }
      
      public bool HasDisconnects {
        get { return result.hasDisconnects; }
      }
      [global::System.CLSCompliant(false)]
      public uint Disconnects {
        get { return result.Disconnects; }
        set { SetDisconnects(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetDisconnects(uint value) {
        PrepareBuilder();
        result.hasDisconnects = true;
        result.disconnects_ = value;
        return this;
      }
      public Builder ClearDisconnects() {
        PrepareBuilder();
        result.hasDisconnects = false;
        result.disconnects_ = 0;
        return this;
      }
    }
    static Record() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class User : pb::GeneratedMessage<User, User.Builder> {
    private User() { }
    private static readonly User defaultInstance = new User().MakeReadOnly();
    private static readonly string[] _userFieldNames = new string[] { "Flags", "Name", "Record" };
    private static readonly uint[] _userFieldTags = new uint[] { 16, 10, 26 };
    public static User DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override User DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override User ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_User__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<User, User.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_User__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int FlagsFieldNumber = 2;
    private bool hasFlags;
    private global::Chess.Contracts.UserFlags flags_ = global::Chess.Contracts.UserFlags.Pedestrian;
    public bool HasFlags {
      get { return hasFlags; }
    }
    public global::Chess.Contracts.UserFlags Flags {
      get { return flags_; }
    }
    
    public const int RecordFieldNumber = 3;
    private bool hasRecord;
    private global::Chess.Contracts.Record record_;
    public bool HasRecord {
      get { return hasRecord; }
    }
    public global::Chess.Contracts.Record Record {
      get { return record_ ?? global::Chess.Contracts.Record.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        if (!hasFlags) return false;
        if (!hasRecord) return false;
        if (!Record.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _userFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[1], Name);
      }
      if (hasFlags) {
        output.WriteEnum(2, field_names[0], (int) Flags, Flags);
      }
      if (hasRecord) {
        output.WriteMessage(3, field_names[2], Record);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasFlags) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Flags);
        }
        if (hasRecord) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Record);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static User ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static User ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static User ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static User ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static User ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static User ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static User ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static User ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static User ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static User ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private User MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(User prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<User, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(User cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private User result;
      
      private User PrepareBuilder() {
        if (resultIsReadOnly) {
          User original = result;
          result = new User();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override User MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.User.Descriptor; }
      }
      
      public override User DefaultInstanceForType {
        get { return global::Chess.Contracts.User.DefaultInstance; }
      }
      
      public override User BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is User) {
          return MergeFrom((User) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(User other) {
        if (other == global::Chess.Contracts.User.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasFlags) {
          Flags = other.Flags;
        }
        if (other.HasRecord) {
          MergeRecord(other.Record);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_userFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _userFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.flags_, out unknown)) {
                result.hasFlags = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 26: {
              global::Chess.Contracts.Record.Builder subBuilder = global::Chess.Contracts.Record.CreateBuilder();
              if (result.hasRecord) {
                subBuilder.MergeFrom(Record);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Record = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasFlags {
       get { return result.hasFlags; }
      }
      public global::Chess.Contracts.UserFlags Flags {
        get { return result.Flags; }
        set { SetFlags(value); }
      }
      public Builder SetFlags(global::Chess.Contracts.UserFlags value) {
        PrepareBuilder();
        result.hasFlags = true;
        result.flags_ = value;
        return this;
      }
      public Builder ClearFlags() {
        PrepareBuilder();
        result.hasFlags = false;
        result.flags_ = global::Chess.Contracts.UserFlags.Pedestrian;
        return this;
      }
      
      public bool HasRecord {
       get { return result.hasRecord; }
      }
      public global::Chess.Contracts.Record Record {
        get { return result.Record; }
        set { SetRecord(value); }
      }
      public Builder SetRecord(global::Chess.Contracts.Record value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRecord = true;
        result.record_ = value;
        return this;
      }
      public Builder SetRecord(global::Chess.Contracts.Record.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRecord = true;
        result.record_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRecord(global::Chess.Contracts.Record value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRecord &&
            result.record_ != global::Chess.Contracts.Record.DefaultInstance) {
            result.record_ = global::Chess.Contracts.Record.CreateBuilder(result.record_).MergeFrom(value).BuildPartial();
        } else {
          result.record_ = value;
        }
        result.hasRecord = true;
        return this;
      }
      public Builder ClearRecord() {
        PrepareBuilder();
        result.hasRecord = false;
        result.record_ = null;
        return this;
      }
    }
    static User() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Game : pb::GeneratedMessage<Game, Game.Builder> {
    private Game() { }
    private static readonly Game defaultInstance = new Game().MakeReadOnly();
    private static readonly string[] _gameFieldNames = new string[] { "Creator", "Joiner", "Name", "Private" };
    private static readonly uint[] _gameFieldTags = new uint[] { 26, 34, 10, 16 };
    public static Game DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Game DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Game ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_Game__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Game, Game.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_Game__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int PrivateFieldNumber = 2;
    private bool hasPrivate;
    private bool private_;
    public bool HasPrivate {
      get { return hasPrivate; }
    }
    public bool Private {
      get { return private_; }
    }
    
    public const int CreatorFieldNumber = 3;
    private bool hasCreator;
    private global::Chess.Contracts.User creator_;
    public bool HasCreator {
      get { return hasCreator; }
    }
    public global::Chess.Contracts.User Creator {
      get { return creator_ ?? global::Chess.Contracts.User.DefaultInstance; }
    }
    
    public const int JoinerFieldNumber = 4;
    private bool hasJoiner;
    private global::Chess.Contracts.User joiner_;
    public bool HasJoiner {
      get { return hasJoiner; }
    }
    public global::Chess.Contracts.User Joiner {
      get { return joiner_ ?? global::Chess.Contracts.User.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        if (!hasPrivate) return false;
        if (HasCreator) {
          if (!Creator.IsInitialized) return false;
        }
        if (HasJoiner) {
          if (!Joiner.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gameFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[2], Name);
      }
      if (hasPrivate) {
        output.WriteBool(2, field_names[3], Private);
      }
      if (hasCreator) {
        output.WriteMessage(3, field_names[0], Creator);
      }
      if (hasJoiner) {
        output.WriteMessage(4, field_names[1], Joiner);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasPrivate) {
          size += pb::CodedOutputStream.ComputeBoolSize(2, Private);
        }
        if (hasCreator) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Creator);
        }
        if (hasJoiner) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, Joiner);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Game ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Game ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Game ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Game ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Game ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Game ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Game ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Game ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Game ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Game ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Game MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Game prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Game, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Game cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Game result;
      
      private Game PrepareBuilder() {
        if (resultIsReadOnly) {
          Game original = result;
          result = new Game();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Game MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.Game.Descriptor; }
      }
      
      public override Game DefaultInstanceForType {
        get { return global::Chess.Contracts.Game.DefaultInstance; }
      }
      
      public override Game BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Game) {
          return MergeFrom((Game) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Game other) {
        if (other == global::Chess.Contracts.Game.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasPrivate) {
          Private = other.Private;
        }
        if (other.HasCreator) {
          MergeCreator(other.Creator);
        }
        if (other.HasJoiner) {
          MergeJoiner(other.Joiner);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 16: {
              result.hasPrivate = input.ReadBool(ref result.private_);
              break;
            }
            case 26: {
              global::Chess.Contracts.User.Builder subBuilder = global::Chess.Contracts.User.CreateBuilder();
              if (result.hasCreator) {
                subBuilder.MergeFrom(Creator);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Creator = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::Chess.Contracts.User.Builder subBuilder = global::Chess.Contracts.User.CreateBuilder();
              if (result.hasJoiner) {
                subBuilder.MergeFrom(Joiner);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Joiner = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasPrivate {
        get { return result.hasPrivate; }
      }
      public bool Private {
        get { return result.Private; }
        set { SetPrivate(value); }
      }
      public Builder SetPrivate(bool value) {
        PrepareBuilder();
        result.hasPrivate = true;
        result.private_ = value;
        return this;
      }
      public Builder ClearPrivate() {
        PrepareBuilder();
        result.hasPrivate = false;
        result.private_ = false;
        return this;
      }
      
      public bool HasCreator {
       get { return result.hasCreator; }
      }
      public global::Chess.Contracts.User Creator {
        get { return result.Creator; }
        set { SetCreator(value); }
      }
      public Builder SetCreator(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCreator = true;
        result.creator_ = value;
        return this;
      }
      public Builder SetCreator(global::Chess.Contracts.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCreator = true;
        result.creator_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCreator(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCreator &&
            result.creator_ != global::Chess.Contracts.User.DefaultInstance) {
            result.creator_ = global::Chess.Contracts.User.CreateBuilder(result.creator_).MergeFrom(value).BuildPartial();
        } else {
          result.creator_ = value;
        }
        result.hasCreator = true;
        return this;
      }
      public Builder ClearCreator() {
        PrepareBuilder();
        result.hasCreator = false;
        result.creator_ = null;
        return this;
      }
      
      public bool HasJoiner {
       get { return result.hasJoiner; }
      }
      public global::Chess.Contracts.User Joiner {
        get { return result.Joiner; }
        set { SetJoiner(value); }
      }
      public Builder SetJoiner(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoiner = true;
        result.joiner_ = value;
        return this;
      }
      public Builder SetJoiner(global::Chess.Contracts.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoiner = true;
        result.joiner_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoiner(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoiner &&
            result.joiner_ != global::Chess.Contracts.User.DefaultInstance) {
            result.joiner_ = global::Chess.Contracts.User.CreateBuilder(result.joiner_).MergeFrom(value).BuildPartial();
        } else {
          result.joiner_ = value;
        }
        result.hasJoiner = true;
        return this;
      }
      public Builder ClearJoiner() {
        PrepareBuilder();
        result.hasJoiner = false;
        result.joiner_ = null;
        return this;
      }
    }
    static Game() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class HandshakeRequest : pb::GeneratedMessage<HandshakeRequest, HandshakeRequest.Builder> {
    private HandshakeRequest() { }
    private static readonly HandshakeRequest defaultInstance = new HandshakeRequest().MakeReadOnly();
    private static readonly string[] _handshakeRequestFieldNames = new string[] { "Version" };
    private static readonly uint[] _handshakeRequestFieldTags = new uint[] { 10 };
    public static HandshakeRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HandshakeRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HandshakeRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_HandshakeRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HandshakeRequest, HandshakeRequest.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_HandshakeRequest__FieldAccessorTable; }
    }
    
    public const int VersionFieldNumber = 1;
    private bool hasVersion;
    private global::Chess.Contracts.Version version_;
    public bool HasVersion {
      get { return hasVersion; }
    }
    public global::Chess.Contracts.Version Version {
      get { return version_ ?? global::Chess.Contracts.Version.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasVersion) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _handshakeRequestFieldNames;
      if (hasVersion) {
        output.WriteMessage(1, field_names[0], Version);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasVersion) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Version);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static HandshakeRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HandshakeRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HandshakeRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HandshakeRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HandshakeRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<HandshakeRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HandshakeRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HandshakeRequest result;
      
      private HandshakeRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          HandshakeRequest original = result;
          result = new HandshakeRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HandshakeRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.HandshakeRequest.Descriptor; }
      }
      
      public override HandshakeRequest DefaultInstanceForType {
        get { return global::Chess.Contracts.HandshakeRequest.DefaultInstance; }
      }
      
      public override HandshakeRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HandshakeRequest) {
          return MergeFrom((HandshakeRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HandshakeRequest other) {
        if (other == global::Chess.Contracts.HandshakeRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasVersion) {
          MergeVersion(other.Version);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_handshakeRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _handshakeRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Chess.Contracts.Version.Builder subBuilder = global::Chess.Contracts.Version.CreateBuilder();
              if (result.hasVersion) {
                subBuilder.MergeFrom(Version);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Version = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasVersion {
       get { return result.hasVersion; }
      }
      public global::Chess.Contracts.Version Version {
        get { return result.Version; }
        set { SetVersion(value); }
      }
      public Builder SetVersion(global::Chess.Contracts.Version value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasVersion = true;
        result.version_ = value;
        return this;
      }
      public Builder SetVersion(global::Chess.Contracts.Version.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasVersion = true;
        result.version_ = builderForValue.Build();
        return this;
      }
      public Builder MergeVersion(global::Chess.Contracts.Version value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasVersion &&
            result.version_ != global::Chess.Contracts.Version.DefaultInstance) {
            result.version_ = global::Chess.Contracts.Version.CreateBuilder(result.version_).MergeFrom(value).BuildPartial();
        } else {
          result.version_ = value;
        }
        result.hasVersion = true;
        return this;
      }
      public Builder ClearVersion() {
        PrepareBuilder();
        result.hasVersion = false;
        result.version_ = null;
        return this;
      }
    }
    static HandshakeRequest() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class HandshakeResponse : pb::GeneratedMessage<HandshakeResponse, HandshakeResponse.Builder> {
    private HandshakeResponse() { }
    private static readonly HandshakeResponse defaultInstance = new HandshakeResponse().MakeReadOnly();
    private static readonly string[] _handshakeResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _handshakeResponseFieldTags = new uint[] { 8 };
    public static HandshakeResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HandshakeResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HandshakeResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_HandshakeResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HandshakeResponse, HandshakeResponse.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_HandshakeResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::Chess.Contracts.Result result_ = global::Chess.Contracts.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::Chess.Contracts.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _handshakeResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static HandshakeResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HandshakeResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HandshakeResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HandshakeResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HandshakeResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<HandshakeResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HandshakeResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HandshakeResponse result;
      
      private HandshakeResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          HandshakeResponse original = result;
          result = new HandshakeResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HandshakeResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.HandshakeResponse.Descriptor; }
      }
      
      public override HandshakeResponse DefaultInstanceForType {
        get { return global::Chess.Contracts.HandshakeResponse.DefaultInstance; }
      }
      
      public override HandshakeResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HandshakeResponse) {
          return MergeFrom((HandshakeResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HandshakeResponse other) {
        if (other == global::Chess.Contracts.HandshakeResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_handshakeResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _handshakeResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::Chess.Contracts.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::Chess.Contracts.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::Chess.Contracts.Result.Success;
        return this;
      }
    }
    static HandshakeResponse() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class IdentifyRequest : pb::GeneratedMessage<IdentifyRequest, IdentifyRequest.Builder> {
    private IdentifyRequest() { }
    private static readonly IdentifyRequest defaultInstance = new IdentifyRequest().MakeReadOnly();
    private static readonly string[] _identifyRequestFieldNames = new string[] { "Password", "Username" };
    private static readonly uint[] _identifyRequestFieldTags = new uint[] { 18, 10 };
    public static IdentifyRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override IdentifyRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override IdentifyRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_IdentifyRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<IdentifyRequest, IdentifyRequest.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_IdentifyRequest__FieldAccessorTable; }
    }
    
    public const int UsernameFieldNumber = 1;
    private bool hasUsername;
    private string username_ = "";
    public bool HasUsername {
      get { return hasUsername; }
    }
    public string Username {
      get { return username_; }
    }
    
    public const int PasswordFieldNumber = 2;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasUsername) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _identifyRequestFieldNames;
      if (hasUsername) {
        output.WriteString(1, field_names[1], Username);
      }
      if (hasPassword) {
        output.WriteString(2, field_names[0], Password);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasUsername) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Username);
        }
        if (hasPassword) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Password);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static IdentifyRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static IdentifyRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static IdentifyRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private IdentifyRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(IdentifyRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<IdentifyRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(IdentifyRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private IdentifyRequest result;
      
      private IdentifyRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          IdentifyRequest original = result;
          result = new IdentifyRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override IdentifyRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.IdentifyRequest.Descriptor; }
      }
      
      public override IdentifyRequest DefaultInstanceForType {
        get { return global::Chess.Contracts.IdentifyRequest.DefaultInstance; }
      }
      
      public override IdentifyRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is IdentifyRequest) {
          return MergeFrom((IdentifyRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(IdentifyRequest other) {
        if (other == global::Chess.Contracts.IdentifyRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasUsername) {
          Username = other.Username;
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_identifyRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _identifyRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasUsername = input.ReadString(ref result.username_);
              break;
            }
            case 18: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasUsername {
        get { return result.hasUsername; }
      }
      public string Username {
        get { return result.Username; }
        set { SetUsername(value); }
      }
      public Builder SetUsername(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUsername = true;
        result.username_ = value;
        return this;
      }
      public Builder ClearUsername() {
        PrepareBuilder();
        result.hasUsername = false;
        result.username_ = "";
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
    }
    static IdentifyRequest() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class IdentifyResponse : pb::GeneratedMessage<IdentifyResponse, IdentifyResponse.Builder> {
    private IdentifyResponse() { }
    private static readonly IdentifyResponse defaultInstance = new IdentifyResponse().MakeReadOnly();
    private static readonly string[] _identifyResponseFieldNames = new string[] { "Message", "Result" };
    private static readonly uint[] _identifyResponseFieldTags = new uint[] { 18, 8 };
    public static IdentifyResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override IdentifyResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override IdentifyResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_IdentifyResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<IdentifyResponse, IdentifyResponse.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_IdentifyResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::Chess.Contracts.Result result_ = global::Chess.Contracts.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::Chess.Contracts.Result Result {
      get { return result_; }
    }
    
    public const int MessageFieldNumber = 2;
    private bool hasMessage;
    private string message_ = "";
    public bool HasMessage {
      get { return hasMessage; }
    }
    public string Message {
      get { return message_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _identifyResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[1], (int) Result, Result);
      }
      if (hasMessage) {
        output.WriteString(2, field_names[0], Message);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Message);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static IdentifyResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static IdentifyResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static IdentifyResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private IdentifyResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(IdentifyResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<IdentifyResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(IdentifyResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private IdentifyResponse result;
      
      private IdentifyResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          IdentifyResponse original = result;
          result = new IdentifyResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override IdentifyResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.IdentifyResponse.Descriptor; }
      }
      
      public override IdentifyResponse DefaultInstanceForType {
        get { return global::Chess.Contracts.IdentifyResponse.DefaultInstance; }
      }
      
      public override IdentifyResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is IdentifyResponse) {
          return MergeFrom((IdentifyResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(IdentifyResponse other) {
        if (other == global::Chess.Contracts.IdentifyResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        if (other.HasMessage) {
          Message = other.Message;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_identifyResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _identifyResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              result.hasMessage = input.ReadString(ref result.message_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::Chess.Contracts.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::Chess.Contracts.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::Chess.Contracts.Result.Success;
        return this;
      }
      
      public bool HasMessage {
        get { return result.hasMessage; }
      }
      public string Message {
        get { return result.Message; }
        set { SetMessage(value); }
      }
      public Builder SetMessage(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessage = true;
        result.message_ = value;
        return this;
      }
      public Builder ClearMessage() {
        PrepareBuilder();
        result.hasMessage = false;
        result.message_ = "";
        return this;
      }
    }
    static IdentifyResponse() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinChatRequest : pb::GeneratedMessage<JoinChatRequest, JoinChatRequest.Builder> {
    private JoinChatRequest() { }
    private static readonly JoinChatRequest defaultInstance = new JoinChatRequest().MakeReadOnly();
    private static readonly string[] _joinChatRequestFieldNames = new string[] {  };
    private static readonly uint[] _joinChatRequestFieldTags = new uint[] {  };
    public static JoinChatRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinChatRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinChatRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinChatRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinChatRequest, JoinChatRequest.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinChatRequest__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinChatRequestFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinChatRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinChatRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinChatRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinChatRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinChatRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinChatRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinChatRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinChatRequest result;
      
      private JoinChatRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinChatRequest original = result;
          result = new JoinChatRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinChatRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.JoinChatRequest.Descriptor; }
      }
      
      public override JoinChatRequest DefaultInstanceForType {
        get { return global::Chess.Contracts.JoinChatRequest.DefaultInstance; }
      }
      
      public override JoinChatRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinChatRequest) {
          return MergeFrom((JoinChatRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinChatRequest other) {
        if (other == global::Chess.Contracts.JoinChatRequest.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinChatRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinChatRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static JoinChatRequest() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinChatResponse : pb::GeneratedMessage<JoinChatResponse, JoinChatResponse.Builder> {
    private JoinChatResponse() { }
    private static readonly JoinChatResponse defaultInstance = new JoinChatResponse().MakeReadOnly();
    private static readonly string[] _joinChatResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _joinChatResponseFieldTags = new uint[] { 8 };
    public static JoinChatResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinChatResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinChatResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinChatResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinChatResponse, JoinChatResponse.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinChatResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::Chess.Contracts.Result result_ = global::Chess.Contracts.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::Chess.Contracts.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinChatResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinChatResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinChatResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinChatResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinChatResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinChatResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinChatResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinChatResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinChatResponse result;
      
      private JoinChatResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinChatResponse original = result;
          result = new JoinChatResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinChatResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.JoinChatResponse.Descriptor; }
      }
      
      public override JoinChatResponse DefaultInstanceForType {
        get { return global::Chess.Contracts.JoinChatResponse.DefaultInstance; }
      }
      
      public override JoinChatResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinChatResponse) {
          return MergeFrom((JoinChatResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinChatResponse other) {
        if (other == global::Chess.Contracts.JoinChatResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinChatResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinChatResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::Chess.Contracts.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::Chess.Contracts.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::Chess.Contracts.Result.Success;
        return this;
      }
    }
    static JoinChatResponse() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class RoomListRequest : pb::GeneratedMessage<RoomListRequest, RoomListRequest.Builder> {
    private RoomListRequest() { }
    private static readonly RoomListRequest defaultInstance = new RoomListRequest().MakeReadOnly();
    private static readonly string[] _roomListRequestFieldNames = new string[] {  };
    private static readonly uint[] _roomListRequestFieldTags = new uint[] {  };
    public static RoomListRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override RoomListRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override RoomListRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_RoomListRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<RoomListRequest, RoomListRequest.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_RoomListRequest__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _roomListRequestFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static RoomListRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static RoomListRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static RoomListRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static RoomListRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private RoomListRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(RoomListRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<RoomListRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(RoomListRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private RoomListRequest result;
      
      private RoomListRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          RoomListRequest original = result;
          result = new RoomListRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override RoomListRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.RoomListRequest.Descriptor; }
      }
      
      public override RoomListRequest DefaultInstanceForType {
        get { return global::Chess.Contracts.RoomListRequest.DefaultInstance; }
      }
      
      public override RoomListRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is RoomListRequest) {
          return MergeFrom((RoomListRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(RoomListRequest other) {
        if (other == global::Chess.Contracts.RoomListRequest.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_roomListRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _roomListRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static RoomListRequest() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class RoomListResponse : pb::GeneratedMessage<RoomListResponse, RoomListResponse.Builder> {
    private RoomListResponse() { }
    private static readonly RoomListResponse defaultInstance = new RoomListResponse().MakeReadOnly();
    private static readonly string[] _roomListResponseFieldNames = new string[] { "Rooms" };
    private static readonly uint[] _roomListResponseFieldTags = new uint[] { 10 };
    public static RoomListResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override RoomListResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override RoomListResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_RoomListResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<RoomListResponse, RoomListResponse.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_RoomListResponse__FieldAccessorTable; }
    }
    
    public const int RoomsFieldNumber = 1;
    private pbc::PopsicleList<global::Chess.Contracts.Room> rooms_ = new pbc::PopsicleList<global::Chess.Contracts.Room>();
    public scg::IList<global::Chess.Contracts.Room> RoomsList {
      get { return rooms_; }
    }
    public int RoomsCount {
      get { return rooms_.Count; }
    }
    public global::Chess.Contracts.Room GetRooms(int index) {
      return rooms_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Chess.Contracts.Room element in RoomsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _roomListResponseFieldNames;
      if (rooms_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], rooms_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::Chess.Contracts.Room element in RoomsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static RoomListResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static RoomListResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static RoomListResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static RoomListResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private RoomListResponse MakeReadOnly() {
      rooms_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(RoomListResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<RoomListResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(RoomListResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private RoomListResponse result;
      
      private RoomListResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          RoomListResponse original = result;
          result = new RoomListResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override RoomListResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.RoomListResponse.Descriptor; }
      }
      
      public override RoomListResponse DefaultInstanceForType {
        get { return global::Chess.Contracts.RoomListResponse.DefaultInstance; }
      }
      
      public override RoomListResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is RoomListResponse) {
          return MergeFrom((RoomListResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(RoomListResponse other) {
        if (other == global::Chess.Contracts.RoomListResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.rooms_.Count != 0) {
          result.rooms_.Add(other.rooms_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_roomListResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _roomListResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.rooms_, global::Chess.Contracts.Room.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Chess.Contracts.Room> RoomsList {
        get { return PrepareBuilder().rooms_; }
      }
      public int RoomsCount {
        get { return result.RoomsCount; }
      }
      public global::Chess.Contracts.Room GetRooms(int index) {
        return result.GetRooms(index);
      }
      public Builder SetRooms(int index, global::Chess.Contracts.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rooms_[index] = value;
        return this;
      }
      public Builder SetRooms(int index, global::Chess.Contracts.Room.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rooms_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddRooms(global::Chess.Contracts.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rooms_.Add(value);
        return this;
      }
      public Builder AddRooms(global::Chess.Contracts.Room.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rooms_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeRooms(scg::IEnumerable<global::Chess.Contracts.Room> values) {
        PrepareBuilder();
        result.rooms_.Add(values);
        return this;
      }
      public Builder ClearRooms() {
        PrepareBuilder();
        result.rooms_.Clear();
        return this;
      }
    }
    static RoomListResponse() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinRoomRequest : pb::GeneratedMessage<JoinRoomRequest, JoinRoomRequest.Builder> {
    private JoinRoomRequest() { }
    private static readonly JoinRoomRequest defaultInstance = new JoinRoomRequest().MakeReadOnly();
    private static readonly string[] _joinRoomRequestFieldNames = new string[] { "Room" };
    private static readonly uint[] _joinRoomRequestFieldTags = new uint[] { 10 };
    public static JoinRoomRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinRoomRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinRoomRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinRoomRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinRoomRequest, JoinRoomRequest.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinRoomRequest__FieldAccessorTable; }
    }
    
    public const int RoomFieldNumber = 1;
    private bool hasRoom;
    private global::Chess.Contracts.Room room_;
    public bool HasRoom {
      get { return hasRoom; }
    }
    public global::Chess.Contracts.Room Room {
      get { return room_ ?? global::Chess.Contracts.Room.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRoom) return false;
        if (!Room.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinRoomRequestFieldNames;
      if (hasRoom) {
        output.WriteMessage(1, field_names[0], Room);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRoom) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Room);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinRoomRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinRoomRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinRoomRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinRoomRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinRoomRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinRoomRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinRoomRequest result;
      
      private JoinRoomRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinRoomRequest original = result;
          result = new JoinRoomRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinRoomRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.JoinRoomRequest.Descriptor; }
      }
      
      public override JoinRoomRequest DefaultInstanceForType {
        get { return global::Chess.Contracts.JoinRoomRequest.DefaultInstance; }
      }
      
      public override JoinRoomRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinRoomRequest) {
          return MergeFrom((JoinRoomRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinRoomRequest other) {
        if (other == global::Chess.Contracts.JoinRoomRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRoom) {
          MergeRoom(other.Room);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinRoomRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinRoomRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Chess.Contracts.Room.Builder subBuilder = global::Chess.Contracts.Room.CreateBuilder();
              if (result.hasRoom) {
                subBuilder.MergeFrom(Room);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Room = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRoom {
       get { return result.hasRoom; }
      }
      public global::Chess.Contracts.Room Room {
        get { return result.Room; }
        set { SetRoom(value); }
      }
      public Builder SetRoom(global::Chess.Contracts.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRoom = true;
        result.room_ = value;
        return this;
      }
      public Builder SetRoom(global::Chess.Contracts.Room.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRoom = true;
        result.room_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRoom(global::Chess.Contracts.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRoom &&
            result.room_ != global::Chess.Contracts.Room.DefaultInstance) {
            result.room_ = global::Chess.Contracts.Room.CreateBuilder(result.room_).MergeFrom(value).BuildPartial();
        } else {
          result.room_ = value;
        }
        result.hasRoom = true;
        return this;
      }
      public Builder ClearRoom() {
        PrepareBuilder();
        result.hasRoom = false;
        result.room_ = null;
        return this;
      }
    }
    static JoinRoomRequest() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinRoomResponse : pb::GeneratedMessage<JoinRoomResponse, JoinRoomResponse.Builder> {
    private JoinRoomResponse() { }
    private static readonly JoinRoomResponse defaultInstance = new JoinRoomResponse().MakeReadOnly();
    private static readonly string[] _joinRoomResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _joinRoomResponseFieldTags = new uint[] { 8 };
    public static JoinRoomResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinRoomResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinRoomResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinRoomResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinRoomResponse, JoinRoomResponse.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinRoomResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::Chess.Contracts.Result result_ = global::Chess.Contracts.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::Chess.Contracts.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinRoomResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinRoomResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinRoomResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinRoomResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinRoomResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinRoomResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinRoomResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinRoomResponse result;
      
      private JoinRoomResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinRoomResponse original = result;
          result = new JoinRoomResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinRoomResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.JoinRoomResponse.Descriptor; }
      }
      
      public override JoinRoomResponse DefaultInstanceForType {
        get { return global::Chess.Contracts.JoinRoomResponse.DefaultInstance; }
      }
      
      public override JoinRoomResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinRoomResponse) {
          return MergeFrom((JoinRoomResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinRoomResponse other) {
        if (other == global::Chess.Contracts.JoinRoomResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinRoomResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinRoomResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::Chess.Contracts.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::Chess.Contracts.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::Chess.Contracts.Result.Success;
        return this;
      }
    }
    static JoinRoomResponse() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class SpeakRequest : pb::GeneratedMessage<SpeakRequest, SpeakRequest.Builder> {
    private SpeakRequest() { }
    private static readonly SpeakRequest defaultInstance = new SpeakRequest().MakeReadOnly();
    private static readonly string[] _speakRequestFieldNames = new string[] { "Message", "Mode", "Recipient" };
    private static readonly uint[] _speakRequestFieldTags = new uint[] { 18, 8, 26 };
    public static SpeakRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SpeakRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SpeakRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_SpeakRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SpeakRequest, SpeakRequest.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_SpeakRequest__FieldAccessorTable; }
    }
    
    public const int ModeFieldNumber = 1;
    private bool hasMode;
    private global::Chess.Contracts.SpeakMode mode_ = global::Chess.Contracts.SpeakMode.Normal;
    public bool HasMode {
      get { return hasMode; }
    }
    public global::Chess.Contracts.SpeakMode Mode {
      get { return mode_; }
    }
    
    public const int MessageFieldNumber = 2;
    private bool hasMessage;
    private string message_ = "";
    public bool HasMessage {
      get { return hasMessage; }
    }
    public string Message {
      get { return message_; }
    }
    
    public const int RecipientFieldNumber = 3;
    private bool hasRecipient;
    private global::Chess.Contracts.User recipient_;
    public bool HasRecipient {
      get { return hasRecipient; }
    }
    public global::Chess.Contracts.User Recipient {
      get { return recipient_ ?? global::Chess.Contracts.User.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasMode) return false;
        if (!hasMessage) return false;
        if (HasRecipient) {
          if (!Recipient.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _speakRequestFieldNames;
      if (hasMode) {
        output.WriteEnum(1, field_names[1], (int) Mode, Mode);
      }
      if (hasMessage) {
        output.WriteString(2, field_names[0], Message);
      }
      if (hasRecipient) {
        output.WriteMessage(3, field_names[2], Recipient);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasMode) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Mode);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Message);
        }
        if (hasRecipient) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Recipient);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SpeakRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SpeakRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SpeakRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SpeakRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SpeakRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SpeakRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<SpeakRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SpeakRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SpeakRequest result;
      
      private SpeakRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          SpeakRequest original = result;
          result = new SpeakRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SpeakRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.SpeakRequest.Descriptor; }
      }
      
      public override SpeakRequest DefaultInstanceForType {
        get { return global::Chess.Contracts.SpeakRequest.DefaultInstance; }
      }
      
      public override SpeakRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SpeakRequest) {
          return MergeFrom((SpeakRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SpeakRequest other) {
        if (other == global::Chess.Contracts.SpeakRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasMode) {
          Mode = other.Mode;
        }
        if (other.HasMessage) {
          Message = other.Message;
        }
        if (other.HasRecipient) {
          MergeRecipient(other.Recipient);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_speakRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _speakRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.mode_, out unknown)) {
                result.hasMode = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              result.hasMessage = input.ReadString(ref result.message_);
              break;
            }
            case 26: {
              global::Chess.Contracts.User.Builder subBuilder = global::Chess.Contracts.User.CreateBuilder();
              if (result.hasRecipient) {
                subBuilder.MergeFrom(Recipient);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Recipient = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasMode {
       get { return result.hasMode; }
      }
      public global::Chess.Contracts.SpeakMode Mode {
        get { return result.Mode; }
        set { SetMode(value); }
      }
      public Builder SetMode(global::Chess.Contracts.SpeakMode value) {
        PrepareBuilder();
        result.hasMode = true;
        result.mode_ = value;
        return this;
      }
      public Builder ClearMode() {
        PrepareBuilder();
        result.hasMode = false;
        result.mode_ = global::Chess.Contracts.SpeakMode.Normal;
        return this;
      }
      
      public bool HasMessage {
        get { return result.hasMessage; }
      }
      public string Message {
        get { return result.Message; }
        set { SetMessage(value); }
      }
      public Builder SetMessage(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessage = true;
        result.message_ = value;
        return this;
      }
      public Builder ClearMessage() {
        PrepareBuilder();
        result.hasMessage = false;
        result.message_ = "";
        return this;
      }
      
      public bool HasRecipient {
       get { return result.hasRecipient; }
      }
      public global::Chess.Contracts.User Recipient {
        get { return result.Recipient; }
        set { SetRecipient(value); }
      }
      public Builder SetRecipient(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRecipient = true;
        result.recipient_ = value;
        return this;
      }
      public Builder SetRecipient(global::Chess.Contracts.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRecipient = true;
        result.recipient_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRecipient(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRecipient &&
            result.recipient_ != global::Chess.Contracts.User.DefaultInstance) {
            result.recipient_ = global::Chess.Contracts.User.CreateBuilder(result.recipient_).MergeFrom(value).BuildPartial();
        } else {
          result.recipient_ = value;
        }
        result.hasRecipient = true;
        return this;
      }
      public Builder ClearRecipient() {
        PrepareBuilder();
        result.hasRecipient = false;
        result.recipient_ = null;
        return this;
      }
    }
    static SpeakRequest() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class OperatorRequest : pb::GeneratedMessage<OperatorRequest, OperatorRequest.Builder> {
    private OperatorRequest() { }
    private static readonly OperatorRequest defaultInstance = new OperatorRequest().MakeReadOnly();
    private static readonly string[] _operatorRequestFieldNames = new string[] { "Action", "User" };
    private static readonly uint[] _operatorRequestFieldTags = new uint[] { 8, 18 };
    public static OperatorRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override OperatorRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override OperatorRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_OperatorRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<OperatorRequest, OperatorRequest.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_OperatorRequest__FieldAccessorTable; }
    }
    
    public const int ActionFieldNumber = 1;
    private bool hasAction;
    private global::Chess.Contracts.OperatorAction action_ = global::Chess.Contracts.OperatorAction.Designate;
    public bool HasAction {
      get { return hasAction; }
    }
    public global::Chess.Contracts.OperatorAction Action {
      get { return action_; }
    }
    
    public const int UserFieldNumber = 2;
    private bool hasUser;
    private global::Chess.Contracts.User user_;
    public bool HasUser {
      get { return hasUser; }
    }
    public global::Chess.Contracts.User User {
      get { return user_ ?? global::Chess.Contracts.User.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasAction) return false;
        if (HasUser) {
          if (!User.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _operatorRequestFieldNames;
      if (hasAction) {
        output.WriteEnum(1, field_names[0], (int) Action, Action);
      }
      if (hasUser) {
        output.WriteMessage(2, field_names[1], User);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasAction) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Action);
        }
        if (hasUser) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, User);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static OperatorRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static OperatorRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static OperatorRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static OperatorRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private OperatorRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(OperatorRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<OperatorRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(OperatorRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private OperatorRequest result;
      
      private OperatorRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          OperatorRequest original = result;
          result = new OperatorRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override OperatorRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.OperatorRequest.Descriptor; }
      }
      
      public override OperatorRequest DefaultInstanceForType {
        get { return global::Chess.Contracts.OperatorRequest.DefaultInstance; }
      }
      
      public override OperatorRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is OperatorRequest) {
          return MergeFrom((OperatorRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(OperatorRequest other) {
        if (other == global::Chess.Contracts.OperatorRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasAction) {
          Action = other.Action;
        }
        if (other.HasUser) {
          MergeUser(other.User);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_operatorRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _operatorRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.action_, out unknown)) {
                result.hasAction = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              global::Chess.Contracts.User.Builder subBuilder = global::Chess.Contracts.User.CreateBuilder();
              if (result.hasUser) {
                subBuilder.MergeFrom(User);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              User = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasAction {
       get { return result.hasAction; }
      }
      public global::Chess.Contracts.OperatorAction Action {
        get { return result.Action; }
        set { SetAction(value); }
      }
      public Builder SetAction(global::Chess.Contracts.OperatorAction value) {
        PrepareBuilder();
        result.hasAction = true;
        result.action_ = value;
        return this;
      }
      public Builder ClearAction() {
        PrepareBuilder();
        result.hasAction = false;
        result.action_ = global::Chess.Contracts.OperatorAction.Designate;
        return this;
      }
      
      public bool HasUser {
       get { return result.hasUser; }
      }
      public global::Chess.Contracts.User User {
        get { return result.User; }
        set { SetUser(value); }
      }
      public Builder SetUser(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = value;
        return this;
      }
      public Builder SetUser(global::Chess.Contracts.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = builderForValue.Build();
        return this;
      }
      public Builder MergeUser(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasUser &&
            result.user_ != global::Chess.Contracts.User.DefaultInstance) {
            result.user_ = global::Chess.Contracts.User.CreateBuilder(result.user_).MergeFrom(value).BuildPartial();
        } else {
          result.user_ = value;
        }
        result.hasUser = true;
        return this;
      }
      public Builder ClearUser() {
        PrepareBuilder();
        result.hasUser = false;
        result.user_ = null;
        return this;
      }
    }
    static OperatorRequest() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class OperatorResponse : pb::GeneratedMessage<OperatorResponse, OperatorResponse.Builder> {
    private OperatorResponse() { }
    private static readonly OperatorResponse defaultInstance = new OperatorResponse().MakeReadOnly();
    private static readonly string[] _operatorResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _operatorResponseFieldTags = new uint[] { 8 };
    public static OperatorResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override OperatorResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override OperatorResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_OperatorResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<OperatorResponse, OperatorResponse.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_OperatorResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::Chess.Contracts.Result result_ = global::Chess.Contracts.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::Chess.Contracts.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _operatorResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static OperatorResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static OperatorResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static OperatorResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static OperatorResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private OperatorResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(OperatorResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<OperatorResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(OperatorResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private OperatorResponse result;
      
      private OperatorResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          OperatorResponse original = result;
          result = new OperatorResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override OperatorResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.OperatorResponse.Descriptor; }
      }
      
      public override OperatorResponse DefaultInstanceForType {
        get { return global::Chess.Contracts.OperatorResponse.DefaultInstance; }
      }
      
      public override OperatorResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is OperatorResponse) {
          return MergeFrom((OperatorResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(OperatorResponse other) {
        if (other == global::Chess.Contracts.OperatorResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_operatorResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _operatorResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::Chess.Contracts.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::Chess.Contracts.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::Chess.Contracts.Result.Success;
        return this;
      }
    }
    static OperatorResponse() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ChatRoomEvent : pb::GeneratedMessage<ChatRoomEvent, ChatRoomEvent.Builder> {
    private ChatRoomEvent() { }
    private static readonly ChatRoomEvent defaultInstance = new ChatRoomEvent().MakeReadOnly();
    private static readonly string[] _chatRoomEventFieldNames = new string[] { "Room", "Users" };
    private static readonly uint[] _chatRoomEventFieldTags = new uint[] { 10, 18 };
    public static ChatRoomEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ChatRoomEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ChatRoomEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_ChatRoomEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ChatRoomEvent, ChatRoomEvent.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_ChatRoomEvent__FieldAccessorTable; }
    }
    
    public const int RoomFieldNumber = 1;
    private bool hasRoom;
    private global::Chess.Contracts.Room room_;
    public bool HasRoom {
      get { return hasRoom; }
    }
    public global::Chess.Contracts.Room Room {
      get { return room_ ?? global::Chess.Contracts.Room.DefaultInstance; }
    }
    
    public const int UsersFieldNumber = 2;
    private pbc::PopsicleList<global::Chess.Contracts.User> users_ = new pbc::PopsicleList<global::Chess.Contracts.User>();
    public scg::IList<global::Chess.Contracts.User> UsersList {
      get { return users_; }
    }
    public int UsersCount {
      get { return users_.Count; }
    }
    public global::Chess.Contracts.User GetUsers(int index) {
      return users_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRoom) return false;
        if (!Room.IsInitialized) return false;
        foreach (global::Chess.Contracts.User element in UsersList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _chatRoomEventFieldNames;
      if (hasRoom) {
        output.WriteMessage(1, field_names[0], Room);
      }
      if (users_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], users_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRoom) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Room);
        }
        foreach (global::Chess.Contracts.User element in UsersList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ChatRoomEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ChatRoomEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ChatRoomEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ChatRoomEvent MakeReadOnly() {
      users_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ChatRoomEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ChatRoomEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ChatRoomEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ChatRoomEvent result;
      
      private ChatRoomEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          ChatRoomEvent original = result;
          result = new ChatRoomEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ChatRoomEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.ChatRoomEvent.Descriptor; }
      }
      
      public override ChatRoomEvent DefaultInstanceForType {
        get { return global::Chess.Contracts.ChatRoomEvent.DefaultInstance; }
      }
      
      public override ChatRoomEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ChatRoomEvent) {
          return MergeFrom((ChatRoomEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ChatRoomEvent other) {
        if (other == global::Chess.Contracts.ChatRoomEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRoom) {
          MergeRoom(other.Room);
        }
        if (other.users_.Count != 0) {
          result.users_.Add(other.users_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_chatRoomEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _chatRoomEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Chess.Contracts.Room.Builder subBuilder = global::Chess.Contracts.Room.CreateBuilder();
              if (result.hasRoom) {
                subBuilder.MergeFrom(Room);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Room = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.users_, global::Chess.Contracts.User.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRoom {
       get { return result.hasRoom; }
      }
      public global::Chess.Contracts.Room Room {
        get { return result.Room; }
        set { SetRoom(value); }
      }
      public Builder SetRoom(global::Chess.Contracts.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRoom = true;
        result.room_ = value;
        return this;
      }
      public Builder SetRoom(global::Chess.Contracts.Room.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRoom = true;
        result.room_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRoom(global::Chess.Contracts.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRoom &&
            result.room_ != global::Chess.Contracts.Room.DefaultInstance) {
            result.room_ = global::Chess.Contracts.Room.CreateBuilder(result.room_).MergeFrom(value).BuildPartial();
        } else {
          result.room_ = value;
        }
        result.hasRoom = true;
        return this;
      }
      public Builder ClearRoom() {
        PrepareBuilder();
        result.hasRoom = false;
        result.room_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Chess.Contracts.User> UsersList {
        get { return PrepareBuilder().users_; }
      }
      public int UsersCount {
        get { return result.UsersCount; }
      }
      public global::Chess.Contracts.User GetUsers(int index) {
        return result.GetUsers(index);
      }
      public Builder SetUsers(int index, global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.users_[index] = value;
        return this;
      }
      public Builder SetUsers(int index, global::Chess.Contracts.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.users_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddUsers(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.users_.Add(value);
        return this;
      }
      public Builder AddUsers(global::Chess.Contracts.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.users_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeUsers(scg::IEnumerable<global::Chess.Contracts.User> values) {
        PrepareBuilder();
        result.users_.Add(values);
        return this;
      }
      public Builder ClearUsers() {
        PrepareBuilder();
        result.users_.Clear();
        return this;
      }
    }
    static ChatRoomEvent() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ChatUserEvent : pb::GeneratedMessage<ChatUserEvent, ChatUserEvent.Builder> {
    private ChatUserEvent() { }
    private static readonly ChatUserEvent defaultInstance = new ChatUserEvent().MakeReadOnly();
    private static readonly string[] _chatUserEventFieldNames = new string[] { "Message", "Status", "User" };
    private static readonly uint[] _chatUserEventFieldTags = new uint[] { 26, 16, 10 };
    public static ChatUserEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ChatUserEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ChatUserEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_ChatUserEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ChatUserEvent, ChatUserEvent.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_ChatUserEvent__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public static class Types {
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
      public enum UserStatus {
        Joined = 0,
        Left = 1,
        Update = 2,
      }
      
    }
    #endregion
    
    public const int UserFieldNumber = 1;
    private bool hasUser;
    private global::Chess.Contracts.User user_;
    public bool HasUser {
      get { return hasUser; }
    }
    public global::Chess.Contracts.User User {
      get { return user_ ?? global::Chess.Contracts.User.DefaultInstance; }
    }
    
    public const int StatusFieldNumber = 2;
    private bool hasStatus;
    private global::Chess.Contracts.ChatUserEvent.Types.UserStatus status_ = global::Chess.Contracts.ChatUserEvent.Types.UserStatus.Joined;
    public bool HasStatus {
      get { return hasStatus; }
    }
    public global::Chess.Contracts.ChatUserEvent.Types.UserStatus Status {
      get { return status_; }
    }
    
    public const int MessageFieldNumber = 3;
    private bool hasMessage;
    private string message_ = "";
    public bool HasMessage {
      get { return hasMessage; }
    }
    public string Message {
      get { return message_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasUser) return false;
        if (!hasStatus) return false;
        if (!User.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _chatUserEventFieldNames;
      if (hasUser) {
        output.WriteMessage(1, field_names[2], User);
      }
      if (hasStatus) {
        output.WriteEnum(2, field_names[1], (int) Status, Status);
      }
      if (hasMessage) {
        output.WriteString(3, field_names[0], Message);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasUser) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, User);
        }
        if (hasStatus) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Status);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Message);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ChatUserEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ChatUserEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ChatUserEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ChatUserEvent MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ChatUserEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ChatUserEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ChatUserEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ChatUserEvent result;
      
      private ChatUserEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          ChatUserEvent original = result;
          result = new ChatUserEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ChatUserEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.ChatUserEvent.Descriptor; }
      }
      
      public override ChatUserEvent DefaultInstanceForType {
        get { return global::Chess.Contracts.ChatUserEvent.DefaultInstance; }
      }
      
      public override ChatUserEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ChatUserEvent) {
          return MergeFrom((ChatUserEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ChatUserEvent other) {
        if (other == global::Chess.Contracts.ChatUserEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasUser) {
          MergeUser(other.User);
        }
        if (other.HasStatus) {
          Status = other.Status;
        }
        if (other.HasMessage) {
          Message = other.Message;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_chatUserEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _chatUserEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Chess.Contracts.User.Builder subBuilder = global::Chess.Contracts.User.CreateBuilder();
              if (result.hasUser) {
                subBuilder.MergeFrom(User);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              User = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.status_, out unknown)) {
                result.hasStatus = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 26: {
              result.hasMessage = input.ReadString(ref result.message_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasUser {
       get { return result.hasUser; }
      }
      public global::Chess.Contracts.User User {
        get { return result.User; }
        set { SetUser(value); }
      }
      public Builder SetUser(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = value;
        return this;
      }
      public Builder SetUser(global::Chess.Contracts.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = builderForValue.Build();
        return this;
      }
      public Builder MergeUser(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasUser &&
            result.user_ != global::Chess.Contracts.User.DefaultInstance) {
            result.user_ = global::Chess.Contracts.User.CreateBuilder(result.user_).MergeFrom(value).BuildPartial();
        } else {
          result.user_ = value;
        }
        result.hasUser = true;
        return this;
      }
      public Builder ClearUser() {
        PrepareBuilder();
        result.hasUser = false;
        result.user_ = null;
        return this;
      }
      
      public bool HasStatus {
       get { return result.hasStatus; }
      }
      public global::Chess.Contracts.ChatUserEvent.Types.UserStatus Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(global::Chess.Contracts.ChatUserEvent.Types.UserStatus value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = global::Chess.Contracts.ChatUserEvent.Types.UserStatus.Joined;
        return this;
      }
      
      public bool HasMessage {
        get { return result.hasMessage; }
      }
      public string Message {
        get { return result.Message; }
        set { SetMessage(value); }
      }
      public Builder SetMessage(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessage = true;
        result.message_ = value;
        return this;
      }
      public Builder ClearMessage() {
        PrepareBuilder();
        result.hasMessage = false;
        result.message_ = "";
        return this;
      }
    }
    static ChatUserEvent() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ChatSpeakEvent : pb::GeneratedMessage<ChatSpeakEvent, ChatSpeakEvent.Builder> {
    private ChatSpeakEvent() { }
    private static readonly ChatSpeakEvent defaultInstance = new ChatSpeakEvent().MakeReadOnly();
    private static readonly string[] _chatSpeakEventFieldNames = new string[] { "Message", "Mode", "User" };
    private static readonly uint[] _chatSpeakEventFieldTags = new uint[] { 18, 24, 10 };
    public static ChatSpeakEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ChatSpeakEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ChatSpeakEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_ChatSpeakEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ChatSpeakEvent, ChatSpeakEvent.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_ChatSpeakEvent__FieldAccessorTable; }
    }
    
    public const int UserFieldNumber = 1;
    private bool hasUser;
    private global::Chess.Contracts.User user_;
    public bool HasUser {
      get { return hasUser; }
    }
    public global::Chess.Contracts.User User {
      get { return user_ ?? global::Chess.Contracts.User.DefaultInstance; }
    }
    
    public const int MessageFieldNumber = 2;
    private bool hasMessage;
    private string message_ = "";
    public bool HasMessage {
      get { return hasMessage; }
    }
    public string Message {
      get { return message_; }
    }
    
    public const int ModeFieldNumber = 3;
    private bool hasMode;
    private global::Chess.Contracts.SpeakMode mode_ = global::Chess.Contracts.SpeakMode.Normal;
    public bool HasMode {
      get { return hasMode; }
    }
    public global::Chess.Contracts.SpeakMode Mode {
      get { return mode_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasUser) return false;
        if (!hasMessage) return false;
        if (!hasMode) return false;
        if (!User.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _chatSpeakEventFieldNames;
      if (hasUser) {
        output.WriteMessage(1, field_names[2], User);
      }
      if (hasMessage) {
        output.WriteString(2, field_names[0], Message);
      }
      if (hasMode) {
        output.WriteEnum(3, field_names[1], (int) Mode, Mode);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasUser) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, User);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Message);
        }
        if (hasMode) {
          size += pb::CodedOutputStream.ComputeEnumSize(3, (int) Mode);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ChatSpeakEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ChatSpeakEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ChatSpeakEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ChatSpeakEvent MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ChatSpeakEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ChatSpeakEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ChatSpeakEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ChatSpeakEvent result;
      
      private ChatSpeakEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          ChatSpeakEvent original = result;
          result = new ChatSpeakEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ChatSpeakEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.ChatSpeakEvent.Descriptor; }
      }
      
      public override ChatSpeakEvent DefaultInstanceForType {
        get { return global::Chess.Contracts.ChatSpeakEvent.DefaultInstance; }
      }
      
      public override ChatSpeakEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ChatSpeakEvent) {
          return MergeFrom((ChatSpeakEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ChatSpeakEvent other) {
        if (other == global::Chess.Contracts.ChatSpeakEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasUser) {
          MergeUser(other.User);
        }
        if (other.HasMessage) {
          Message = other.Message;
        }
        if (other.HasMode) {
          Mode = other.Mode;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_chatSpeakEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _chatSpeakEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Chess.Contracts.User.Builder subBuilder = global::Chess.Contracts.User.CreateBuilder();
              if (result.hasUser) {
                subBuilder.MergeFrom(User);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              User = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              result.hasMessage = input.ReadString(ref result.message_);
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.mode_, out unknown)) {
                result.hasMode = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasUser {
       get { return result.hasUser; }
      }
      public global::Chess.Contracts.User User {
        get { return result.User; }
        set { SetUser(value); }
      }
      public Builder SetUser(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = value;
        return this;
      }
      public Builder SetUser(global::Chess.Contracts.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = builderForValue.Build();
        return this;
      }
      public Builder MergeUser(global::Chess.Contracts.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasUser &&
            result.user_ != global::Chess.Contracts.User.DefaultInstance) {
            result.user_ = global::Chess.Contracts.User.CreateBuilder(result.user_).MergeFrom(value).BuildPartial();
        } else {
          result.user_ = value;
        }
        result.hasUser = true;
        return this;
      }
      public Builder ClearUser() {
        PrepareBuilder();
        result.hasUser = false;
        result.user_ = null;
        return this;
      }
      
      public bool HasMessage {
        get { return result.hasMessage; }
      }
      public string Message {
        get { return result.Message; }
        set { SetMessage(value); }
      }
      public Builder SetMessage(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessage = true;
        result.message_ = value;
        return this;
      }
      public Builder ClearMessage() {
        PrepareBuilder();
        result.hasMessage = false;
        result.message_ = "";
        return this;
      }
      
      public bool HasMode {
       get { return result.hasMode; }
      }
      public global::Chess.Contracts.SpeakMode Mode {
        get { return result.Mode; }
        set { SetMode(value); }
      }
      public Builder SetMode(global::Chess.Contracts.SpeakMode value) {
        PrepareBuilder();
        result.hasMode = true;
        result.mode_ = value;
        return this;
      }
      public Builder ClearMode() {
        PrepareBuilder();
        result.hasMode = false;
        result.mode_ = global::Chess.Contracts.SpeakMode.Normal;
        return this;
      }
    }
    static ChatSpeakEvent() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GameListRequest : pb::GeneratedMessage<GameListRequest, GameListRequest.Builder> {
    private GameListRequest() { }
    private static readonly GameListRequest defaultInstance = new GameListRequest().MakeReadOnly();
    private static readonly string[] _gameListRequestFieldNames = new string[] {  };
    private static readonly uint[] _gameListRequestFieldTags = new uint[] {  };
    public static GameListRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameListRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameListRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_GameListRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameListRequest, GameListRequest.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_GameListRequest__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gameListRequestFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GameListRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameListRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameListRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameListRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameListRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameListRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameListRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameListRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameListRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameListRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameListRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameListRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GameListRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameListRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameListRequest result;
      
      private GameListRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          GameListRequest original = result;
          result = new GameListRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameListRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.GameListRequest.Descriptor; }
      }
      
      public override GameListRequest DefaultInstanceForType {
        get { return global::Chess.Contracts.GameListRequest.DefaultInstance; }
      }
      
      public override GameListRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameListRequest) {
          return MergeFrom((GameListRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameListRequest other) {
        if (other == global::Chess.Contracts.GameListRequest.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameListRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameListRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static GameListRequest() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GameListResponse : pb::GeneratedMessage<GameListResponse, GameListResponse.Builder> {
    private GameListResponse() { }
    private static readonly GameListResponse defaultInstance = new GameListResponse().MakeReadOnly();
    private static readonly string[] _gameListResponseFieldNames = new string[] { "Games" };
    private static readonly uint[] _gameListResponseFieldTags = new uint[] { 10 };
    public static GameListResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameListResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameListResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_GameListResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameListResponse, GameListResponse.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_GameListResponse__FieldAccessorTable; }
    }
    
    public const int GamesFieldNumber = 1;
    private pbc::PopsicleList<global::Chess.Contracts.Game> games_ = new pbc::PopsicleList<global::Chess.Contracts.Game>();
    public scg::IList<global::Chess.Contracts.Game> GamesList {
      get { return games_; }
    }
    public int GamesCount {
      get { return games_.Count; }
    }
    public global::Chess.Contracts.Game GetGames(int index) {
      return games_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Chess.Contracts.Game element in GamesList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gameListResponseFieldNames;
      if (games_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], games_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::Chess.Contracts.Game element in GamesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GameListResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameListResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameListResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameListResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameListResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameListResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameListResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameListResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameListResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameListResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameListResponse MakeReadOnly() {
      games_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameListResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GameListResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameListResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameListResponse result;
      
      private GameListResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          GameListResponse original = result;
          result = new GameListResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameListResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.GameListResponse.Descriptor; }
      }
      
      public override GameListResponse DefaultInstanceForType {
        get { return global::Chess.Contracts.GameListResponse.DefaultInstance; }
      }
      
      public override GameListResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameListResponse) {
          return MergeFrom((GameListResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameListResponse other) {
        if (other == global::Chess.Contracts.GameListResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.games_.Count != 0) {
          result.games_.Add(other.games_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameListResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameListResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.games_, global::Chess.Contracts.Game.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Chess.Contracts.Game> GamesList {
        get { return PrepareBuilder().games_; }
      }
      public int GamesCount {
        get { return result.GamesCount; }
      }
      public global::Chess.Contracts.Game GetGames(int index) {
        return result.GetGames(index);
      }
      public Builder SetGames(int index, global::Chess.Contracts.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.games_[index] = value;
        return this;
      }
      public Builder SetGames(int index, global::Chess.Contracts.Game.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.games_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddGames(global::Chess.Contracts.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.games_.Add(value);
        return this;
      }
      public Builder AddGames(global::Chess.Contracts.Game.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.games_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeGames(scg::IEnumerable<global::Chess.Contracts.Game> values) {
        PrepareBuilder();
        result.games_.Add(values);
        return this;
      }
      public Builder ClearGames() {
        PrepareBuilder();
        result.games_.Clear();
        return this;
      }
    }
    static GameListResponse() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class CreateGameRequest : pb::GeneratedMessage<CreateGameRequest, CreateGameRequest.Builder> {
    private CreateGameRequest() { }
    private static readonly CreateGameRequest defaultInstance = new CreateGameRequest().MakeReadOnly();
    private static readonly string[] _createGameRequestFieldNames = new string[] { "Name", "Password" };
    private static readonly uint[] _createGameRequestFieldTags = new uint[] { 10, 18 };
    public static CreateGameRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CreateGameRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CreateGameRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_CreateGameRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CreateGameRequest, CreateGameRequest.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_CreateGameRequest__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int PasswordFieldNumber = 2;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _createGameRequestFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[0], Name);
      }
      if (hasPassword) {
        output.WriteString(2, field_names[1], Password);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasPassword) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Password);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CreateGameRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CreateGameRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CreateGameRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CreateGameRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CreateGameRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<CreateGameRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CreateGameRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CreateGameRequest result;
      
      private CreateGameRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          CreateGameRequest original = result;
          result = new CreateGameRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CreateGameRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.CreateGameRequest.Descriptor; }
      }
      
      public override CreateGameRequest DefaultInstanceForType {
        get { return global::Chess.Contracts.CreateGameRequest.DefaultInstance; }
      }
      
      public override CreateGameRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CreateGameRequest) {
          return MergeFrom((CreateGameRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CreateGameRequest other) {
        if (other == global::Chess.Contracts.CreateGameRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_createGameRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _createGameRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
    }
    static CreateGameRequest() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class CreateGameResponse : pb::GeneratedMessage<CreateGameResponse, CreateGameResponse.Builder> {
    private CreateGameResponse() { }
    private static readonly CreateGameResponse defaultInstance = new CreateGameResponse().MakeReadOnly();
    private static readonly string[] _createGameResponseFieldNames = new string[] { "Game", "Message", "Result" };
    private static readonly uint[] _createGameResponseFieldTags = new uint[] { 18, 26, 8 };
    public static CreateGameResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CreateGameResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CreateGameResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_CreateGameResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CreateGameResponse, CreateGameResponse.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_CreateGameResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::Chess.Contracts.Result result_ = global::Chess.Contracts.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::Chess.Contracts.Result Result {
      get { return result_; }
    }
    
    public const int GameFieldNumber = 2;
    private bool hasGame;
    private global::Chess.Contracts.Game game_;
    public bool HasGame {
      get { return hasGame; }
    }
    public global::Chess.Contracts.Game Game {
      get { return game_ ?? global::Chess.Contracts.Game.DefaultInstance; }
    }
    
    public const int MessageFieldNumber = 3;
    private bool hasMessage;
    private string message_ = "";
    public bool HasMessage {
      get { return hasMessage; }
    }
    public string Message {
      get { return message_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        if (HasGame) {
          if (!Game.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _createGameResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[2], (int) Result, Result);
      }
      if (hasGame) {
        output.WriteMessage(2, field_names[0], Game);
      }
      if (hasMessage) {
        output.WriteString(3, field_names[1], Message);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        if (hasGame) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Game);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Message);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CreateGameResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CreateGameResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CreateGameResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CreateGameResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CreateGameResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<CreateGameResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CreateGameResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CreateGameResponse result;
      
      private CreateGameResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          CreateGameResponse original = result;
          result = new CreateGameResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CreateGameResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.CreateGameResponse.Descriptor; }
      }
      
      public override CreateGameResponse DefaultInstanceForType {
        get { return global::Chess.Contracts.CreateGameResponse.DefaultInstance; }
      }
      
      public override CreateGameResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CreateGameResponse) {
          return MergeFrom((CreateGameResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CreateGameResponse other) {
        if (other == global::Chess.Contracts.CreateGameResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        if (other.HasGame) {
          MergeGame(other.Game);
        }
        if (other.HasMessage) {
          Message = other.Message;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_createGameResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _createGameResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              global::Chess.Contracts.Game.Builder subBuilder = global::Chess.Contracts.Game.CreateBuilder();
              if (result.hasGame) {
                subBuilder.MergeFrom(Game);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Game = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              result.hasMessage = input.ReadString(ref result.message_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::Chess.Contracts.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::Chess.Contracts.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::Chess.Contracts.Result.Success;
        return this;
      }
      
      public bool HasGame {
       get { return result.hasGame; }
      }
      public global::Chess.Contracts.Game Game {
        get { return result.Game; }
        set { SetGame(value); }
      }
      public Builder SetGame(global::Chess.Contracts.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGame = true;
        result.game_ = value;
        return this;
      }
      public Builder SetGame(global::Chess.Contracts.Game.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGame = true;
        result.game_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGame(global::Chess.Contracts.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGame &&
            result.game_ != global::Chess.Contracts.Game.DefaultInstance) {
            result.game_ = global::Chess.Contracts.Game.CreateBuilder(result.game_).MergeFrom(value).BuildPartial();
        } else {
          result.game_ = value;
        }
        result.hasGame = true;
        return this;
      }
      public Builder ClearGame() {
        PrepareBuilder();
        result.hasGame = false;
        result.game_ = null;
        return this;
      }
      
      public bool HasMessage {
        get { return result.hasMessage; }
      }
      public string Message {
        get { return result.Message; }
        set { SetMessage(value); }
      }
      public Builder SetMessage(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessage = true;
        result.message_ = value;
        return this;
      }
      public Builder ClearMessage() {
        PrepareBuilder();
        result.hasMessage = false;
        result.message_ = "";
        return this;
      }
    }
    static CreateGameResponse() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinGameRequest : pb::GeneratedMessage<JoinGameRequest, JoinGameRequest.Builder> {
    private JoinGameRequest() { }
    private static readonly JoinGameRequest defaultInstance = new JoinGameRequest().MakeReadOnly();
    private static readonly string[] _joinGameRequestFieldNames = new string[] { "Game", "Password" };
    private static readonly uint[] _joinGameRequestFieldTags = new uint[] { 10, 18 };
    public static JoinGameRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinGameRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinGameRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinGameRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinGameRequest, JoinGameRequest.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinGameRequest__FieldAccessorTable; }
    }
    
    public const int GameFieldNumber = 1;
    private bool hasGame;
    private global::Chess.Contracts.Game game_;
    public bool HasGame {
      get { return hasGame; }
    }
    public global::Chess.Contracts.Game Game {
      get { return game_ ?? global::Chess.Contracts.Game.DefaultInstance; }
    }
    
    public const int PasswordFieldNumber = 2;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasGame) return false;
        if (!Game.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinGameRequestFieldNames;
      if (hasGame) {
        output.WriteMessage(1, field_names[0], Game);
      }
      if (hasPassword) {
        output.WriteString(2, field_names[1], Password);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasGame) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Game);
        }
        if (hasPassword) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Password);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinGameRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinGameRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinGameRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinGameRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinGameRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinGameRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinGameRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinGameRequest result;
      
      private JoinGameRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinGameRequest original = result;
          result = new JoinGameRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinGameRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.JoinGameRequest.Descriptor; }
      }
      
      public override JoinGameRequest DefaultInstanceForType {
        get { return global::Chess.Contracts.JoinGameRequest.DefaultInstance; }
      }
      
      public override JoinGameRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinGameRequest) {
          return MergeFrom((JoinGameRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinGameRequest other) {
        if (other == global::Chess.Contracts.JoinGameRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasGame) {
          MergeGame(other.Game);
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinGameRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinGameRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Chess.Contracts.Game.Builder subBuilder = global::Chess.Contracts.Game.CreateBuilder();
              if (result.hasGame) {
                subBuilder.MergeFrom(Game);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Game = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasGame {
       get { return result.hasGame; }
      }
      public global::Chess.Contracts.Game Game {
        get { return result.Game; }
        set { SetGame(value); }
      }
      public Builder SetGame(global::Chess.Contracts.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGame = true;
        result.game_ = value;
        return this;
      }
      public Builder SetGame(global::Chess.Contracts.Game.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGame = true;
        result.game_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGame(global::Chess.Contracts.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGame &&
            result.game_ != global::Chess.Contracts.Game.DefaultInstance) {
            result.game_ = global::Chess.Contracts.Game.CreateBuilder(result.game_).MergeFrom(value).BuildPartial();
        } else {
          result.game_ = value;
        }
        result.hasGame = true;
        return this;
      }
      public Builder ClearGame() {
        PrepareBuilder();
        result.hasGame = false;
        result.game_ = null;
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
    }
    static JoinGameRequest() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinGameResponse : pb::GeneratedMessage<JoinGameResponse, JoinGameResponse.Builder> {
    private JoinGameResponse() { }
    private static readonly JoinGameResponse defaultInstance = new JoinGameResponse().MakeReadOnly();
    private static readonly string[] _joinGameResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _joinGameResponseFieldTags = new uint[] { 8 };
    public static JoinGameResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinGameResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinGameResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinGameResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinGameResponse, JoinGameResponse.Builder> InternalFieldAccessors {
      get { return global::Chess.Contracts.Contracts.internal__static_com_richardpianka_chess_network_JoinGameResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::Chess.Contracts.Result result_ = global::Chess.Contracts.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::Chess.Contracts.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinGameResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinGameResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinGameResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinGameResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinGameResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinGameResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinGameResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinGameResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinGameResponse result;
      
      private JoinGameResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinGameResponse original = result;
          result = new JoinGameResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinGameResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Chess.Contracts.JoinGameResponse.Descriptor; }
      }
      
      public override JoinGameResponse DefaultInstanceForType {
        get { return global::Chess.Contracts.JoinGameResponse.DefaultInstance; }
      }
      
      public override JoinGameResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinGameResponse) {
          return MergeFrom((JoinGameResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinGameResponse other) {
        if (other == global::Chess.Contracts.JoinGameResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinGameResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinGameResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::Chess.Contracts.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::Chess.Contracts.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::Chess.Contracts.Result.Success;
        return this;
      }
    }
    static JoinGameResponse() {
      object.ReferenceEquals(global::Chess.Contracts.Contracts.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
