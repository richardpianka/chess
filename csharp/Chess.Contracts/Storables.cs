// Generated by ProtoGen, Version=2.4.1.473, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace com.richardpianka.chess.server.storables {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public static partial class Storables {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_server_storables_Account__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.server.storables.Account, global::com.richardpianka.chess.server.storables.Account.Builder> internal__static_com_richardpianka_chess_server_storables_Account__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_server_storables_Record__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.server.storables.Record, global::com.richardpianka.chess.server.storables.Record.Builder> internal__static_com_richardpianka_chess_server_storables_Record__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static Storables() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "Ch5wcm90b2J1Zi9jaGVzcy9zdG9yYWJsZXMucHJvdG8SKGNvbS5yaWNoYXJk" + 
          "cGlhbmthLmNoZXNzLnNlcnZlci5zdG9yYWJsZXMiewoHQWNjb3VudBIKCgJJ" + 
          "ZBgBIAIoDRIQCghVc2VybmFtZRgCIAIoCRIQCghQYXNzd29yZBgDIAIoCRJA" + 
          "CgZSZWNvcmQYBCACKAsyMC5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5zZXJ2" + 
          "ZXIuc3RvcmFibGVzLlJlY29yZCJPCgZSZWNvcmQSDAoEV2lucxgBIAIoDRIO" + 
          "CgZMb3NzZXMYAiACKA0SEgoKU3RhbGVtYXRlcxgDIAIoDRITCgtEaXNjb25u" + 
          "ZWN0cxgEIAIoDUI1Cihjb20ucmljaGFyZHBpYW5rYS5jaGVzcy5zZXJ2ZXIu" + 
          "c3RvcmFibGVzQglTdG9yYWJsZXM=");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_com_richardpianka_chess_server_storables_Account__Descriptor = Descriptor.MessageTypes[0];
        internal__static_com_richardpianka_chess_server_storables_Account__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.server.storables.Account, global::com.richardpianka.chess.server.storables.Account.Builder>(internal__static_com_richardpianka_chess_server_storables_Account__Descriptor,
                new string[] { "Id", "Username", "Password", "Record", });
        internal__static_com_richardpianka_chess_server_storables_Record__Descriptor = Descriptor.MessageTypes[1];
        internal__static_com_richardpianka_chess_server_storables_Record__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.server.storables.Record, global::com.richardpianka.chess.server.storables.Record.Builder>(internal__static_com_richardpianka_chess_server_storables_Record__Descriptor,
                new string[] { "Wins", "Losses", "Stalemates", "Disconnects", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Account : pb::GeneratedMessage<Account, Account.Builder> {
    private Account() { }
    private static readonly Account defaultInstance = new Account().MakeReadOnly();
    private static readonly string[] _accountFieldNames = new string[] { "Id", "Password", "Record", "Username" };
    private static readonly uint[] _accountFieldTags = new uint[] { 8, 26, 34, 18 };
    public static Account DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Account DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Account ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.server.storables.Storables.internal__static_com_richardpianka_chess_server_storables_Account__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Account, Account.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.server.storables.Storables.internal__static_com_richardpianka_chess_server_storables_Account__FieldAccessorTable; }
    }
    
    public const int IdFieldNumber = 1;
    private bool hasId;
    private uint id_;
    public bool HasId {
      get { return hasId; }
    }
    [global::System.CLSCompliant(false)]
    public uint Id {
      get { return id_; }
    }
    
    public const int UsernameFieldNumber = 2;
    private bool hasUsername;
    private string username_ = "";
    public bool HasUsername {
      get { return hasUsername; }
    }
    public string Username {
      get { return username_; }
    }
    
    public const int PasswordFieldNumber = 3;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public const int RecordFieldNumber = 4;
    private bool hasRecord;
    private global::com.richardpianka.chess.server.storables.Record record_;
    public bool HasRecord {
      get { return hasRecord; }
    }
    public global::com.richardpianka.chess.server.storables.Record Record {
      get { return record_ ?? global::com.richardpianka.chess.server.storables.Record.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasId) return false;
        if (!hasUsername) return false;
        if (!hasPassword) return false;
        if (!hasRecord) return false;
        if (!Record.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _accountFieldNames;
      if (hasId) {
        output.WriteUInt32(1, field_names[0], Id);
      }
      if (hasUsername) {
        output.WriteString(2, field_names[3], Username);
      }
      if (hasPassword) {
        output.WriteString(3, field_names[1], Password);
      }
      if (hasRecord) {
        output.WriteMessage(4, field_names[2], Record);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Id);
        }
        if (hasUsername) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Username);
        }
        if (hasPassword) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Password);
        }
        if (hasRecord) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, Record);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Account ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Account ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Account ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Account ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Account ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Account ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Account ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Account ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Account ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Account ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Account MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Account prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Account, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Account cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Account result;
      
      private Account PrepareBuilder() {
        if (resultIsReadOnly) {
          Account original = result;
          result = new Account();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Account MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.server.storables.Account.Descriptor; }
      }
      
      public override Account DefaultInstanceForType {
        get { return global::com.richardpianka.chess.server.storables.Account.DefaultInstance; }
      }
      
      public override Account BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Account) {
          return MergeFrom((Account) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Account other) {
        if (other == global::com.richardpianka.chess.server.storables.Account.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasId) {
          Id = other.Id;
        }
        if (other.HasUsername) {
          Username = other.Username;
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        if (other.HasRecord) {
          MergeRecord(other.Record);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_accountFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _accountFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasId = input.ReadUInt32(ref result.id_);
              break;
            }
            case 18: {
              result.hasUsername = input.ReadString(ref result.username_);
              break;
            }
            case 26: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
            case 34: {
              global::com.richardpianka.chess.server.storables.Record.Builder subBuilder = global::com.richardpianka.chess.server.storables.Record.CreateBuilder();
              if (result.hasRecord) {
                subBuilder.MergeFrom(Record);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Record = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasId {
        get { return result.hasId; }
      }
      [global::System.CLSCompliant(false)]
      public uint Id {
        get { return result.Id; }
        set { SetId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetId(uint value) {
        PrepareBuilder();
        result.hasId = true;
        result.id_ = value;
        return this;
      }
      public Builder ClearId() {
        PrepareBuilder();
        result.hasId = false;
        result.id_ = 0;
        return this;
      }
      
      public bool HasUsername {
        get { return result.hasUsername; }
      }
      public string Username {
        get { return result.Username; }
        set { SetUsername(value); }
      }
      public Builder SetUsername(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUsername = true;
        result.username_ = value;
        return this;
      }
      public Builder ClearUsername() {
        PrepareBuilder();
        result.hasUsername = false;
        result.username_ = "";
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
      
      public bool HasRecord {
       get { return result.hasRecord; }
      }
      public global::com.richardpianka.chess.server.storables.Record Record {
        get { return result.Record; }
        set { SetRecord(value); }
      }
      public Builder SetRecord(global::com.richardpianka.chess.server.storables.Record value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRecord = true;
        result.record_ = value;
        return this;
      }
      public Builder SetRecord(global::com.richardpianka.chess.server.storables.Record.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRecord = true;
        result.record_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRecord(global::com.richardpianka.chess.server.storables.Record value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRecord &&
            result.record_ != global::com.richardpianka.chess.server.storables.Record.DefaultInstance) {
            result.record_ = global::com.richardpianka.chess.server.storables.Record.CreateBuilder(result.record_).MergeFrom(value).BuildPartial();
        } else {
          result.record_ = value;
        }
        result.hasRecord = true;
        return this;
      }
      public Builder ClearRecord() {
        PrepareBuilder();
        result.hasRecord = false;
        result.record_ = null;
        return this;
      }
    }
    static Account() {
      object.ReferenceEquals(global::com.richardpianka.chess.server.storables.Storables.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Record : pb::GeneratedMessage<Record, Record.Builder> {
    private Record() { }
    private static readonly Record defaultInstance = new Record().MakeReadOnly();
    private static readonly string[] _recordFieldNames = new string[] { "Disconnects", "Losses", "Stalemates", "Wins" };
    private static readonly uint[] _recordFieldTags = new uint[] { 32, 16, 24, 8 };
    public static Record DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Record DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Record ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.server.storables.Storables.internal__static_com_richardpianka_chess_server_storables_Record__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Record, Record.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.server.storables.Storables.internal__static_com_richardpianka_chess_server_storables_Record__FieldAccessorTable; }
    }
    
    public const int WinsFieldNumber = 1;
    private bool hasWins;
    private uint wins_;
    public bool HasWins {
      get { return hasWins; }
    }
    [global::System.CLSCompliant(false)]
    public uint Wins {
      get { return wins_; }
    }
    
    public const int LossesFieldNumber = 2;
    private bool hasLosses;
    private uint losses_;
    public bool HasLosses {
      get { return hasLosses; }
    }
    [global::System.CLSCompliant(false)]
    public uint Losses {
      get { return losses_; }
    }
    
    public const int StalematesFieldNumber = 3;
    private bool hasStalemates;
    private uint stalemates_;
    public bool HasStalemates {
      get { return hasStalemates; }
    }
    [global::System.CLSCompliant(false)]
    public uint Stalemates {
      get { return stalemates_; }
    }
    
    public const int DisconnectsFieldNumber = 4;
    private bool hasDisconnects;
    private uint disconnects_;
    public bool HasDisconnects {
      get { return hasDisconnects; }
    }
    [global::System.CLSCompliant(false)]
    public uint Disconnects {
      get { return disconnects_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasWins) return false;
        if (!hasLosses) return false;
        if (!hasStalemates) return false;
        if (!hasDisconnects) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _recordFieldNames;
      if (hasWins) {
        output.WriteUInt32(1, field_names[3], Wins);
      }
      if (hasLosses) {
        output.WriteUInt32(2, field_names[1], Losses);
      }
      if (hasStalemates) {
        output.WriteUInt32(3, field_names[2], Stalemates);
      }
      if (hasDisconnects) {
        output.WriteUInt32(4, field_names[0], Disconnects);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasWins) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Wins);
        }
        if (hasLosses) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, Losses);
        }
        if (hasStalemates) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, Stalemates);
        }
        if (hasDisconnects) {
          size += pb::CodedOutputStream.ComputeUInt32Size(4, Disconnects);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Record ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Record ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Record ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Record ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Record ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Record ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Record ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Record ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Record ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Record ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Record MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Record prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Record, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Record cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Record result;
      
      private Record PrepareBuilder() {
        if (resultIsReadOnly) {
          Record original = result;
          result = new Record();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Record MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.server.storables.Record.Descriptor; }
      }
      
      public override Record DefaultInstanceForType {
        get { return global::com.richardpianka.chess.server.storables.Record.DefaultInstance; }
      }
      
      public override Record BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Record) {
          return MergeFrom((Record) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Record other) {
        if (other == global::com.richardpianka.chess.server.storables.Record.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasWins) {
          Wins = other.Wins;
        }
        if (other.HasLosses) {
          Losses = other.Losses;
        }
        if (other.HasStalemates) {
          Stalemates = other.Stalemates;
        }
        if (other.HasDisconnects) {
          Disconnects = other.Disconnects;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_recordFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _recordFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasWins = input.ReadUInt32(ref result.wins_);
              break;
            }
            case 16: {
              result.hasLosses = input.ReadUInt32(ref result.losses_);
              break;
            }
            case 24: {
              result.hasStalemates = input.ReadUInt32(ref result.stalemates_);
              break;
            }
            case 32: {
              result.hasDisconnects = input.ReadUInt32(ref result.disconnects_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasWins {
        get { return result.hasWins; }
      }
      [global::System.CLSCompliant(false)]
      public uint Wins {
        get { return result.Wins; }
        set { SetWins(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetWins(uint value) {
        PrepareBuilder();
        result.hasWins = true;
        result.wins_ = value;
        return this;
      }
      public Builder ClearWins() {
        PrepareBuilder();
        result.hasWins = false;
        result.wins_ = 0;
        return this;
      }
      
      public bool HasLosses {
        get { return result.hasLosses; }
      }
      [global::System.CLSCompliant(false)]
      public uint Losses {
        get { return result.Losses; }
        set { SetLosses(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetLosses(uint value) {
        PrepareBuilder();
        result.hasLosses = true;
        result.losses_ = value;
        return this;
      }
      public Builder ClearLosses() {
        PrepareBuilder();
        result.hasLosses = false;
        result.losses_ = 0;
        return this;
      }
      
      public bool HasStalemates {
        get { return result.hasStalemates; }
      }
      [global::System.CLSCompliant(false)]
      public uint Stalemates {
        get { return result.Stalemates; }
        set { SetStalemates(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetStalemates(uint value) {
        PrepareBuilder();
        result.hasStalemates = true;
        result.stalemates_ = value;
        return this;
      }
      public Builder ClearStalemates() {
        PrepareBuilder();
        result.hasStalemates = false;
        result.stalemates_ = 0;
        return this;
      }
      
      public bool HasDisconnects {
        get { return result.hasDisconnects; }
      }
      [global::System.CLSCompliant(false)]
      public uint Disconnects {
        get { return result.Disconnects; }
        set { SetDisconnects(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetDisconnects(uint value) {
        PrepareBuilder();
        result.hasDisconnects = true;
        result.disconnects_ = value;
        return this;
      }
      public Builder ClearDisconnects() {
        PrepareBuilder();
        result.hasDisconnects = false;
        result.disconnects_ = 0;
        return this;
      }
    }
    static Record() {
      object.ReferenceEquals(global::com.richardpianka.chess.server.storables.Storables.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
