// Generated by ProtoGen, Version=2.4.1.473, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace com.richardpianka.chess.network {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public static partial class Contracts {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Envelope__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Envelope, global::com.richardpianka.chess.network.Envelope.Builder> internal__static_com_richardpianka_chess_network_Envelope__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Coordinate__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Coordinate, global::com.richardpianka.chess.network.Coordinate.Builder> internal__static_com_richardpianka_chess_network_Coordinate__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Piece__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Piece, global::com.richardpianka.chess.network.Piece.Builder> internal__static_com_richardpianka_chess_network_Piece__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Move__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Move, global::com.richardpianka.chess.network.Move.Builder> internal__static_com_richardpianka_chess_network_Move__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_SpecialMove__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.SpecialMove, global::com.richardpianka.chess.network.SpecialMove.Builder> internal__static_com_richardpianka_chess_network_SpecialMove__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Castle__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Castle, global::com.richardpianka.chess.network.Castle.Builder> internal__static_com_richardpianka_chess_network_Castle__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Version__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Version, global::com.richardpianka.chess.network.Version.Builder> internal__static_com_richardpianka_chess_network_Version__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Room__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Room, global::com.richardpianka.chess.network.Room.Builder> internal__static_com_richardpianka_chess_network_Room__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Record__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Record, global::com.richardpianka.chess.network.Record.Builder> internal__static_com_richardpianka_chess_network_Record__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_User__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.User, global::com.richardpianka.chess.network.User.Builder> internal__static_com_richardpianka_chess_network_User__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_Game__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Game, global::com.richardpianka.chess.network.Game.Builder> internal__static_com_richardpianka_chess_network_Game__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_GameMetadata__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.GameMetadata, global::com.richardpianka.chess.network.GameMetadata.Builder> internal__static_com_richardpianka_chess_network_GameMetadata__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_UserTime__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.UserTime, global::com.richardpianka.chess.network.UserTime.Builder> internal__static_com_richardpianka_chess_network_UserTime__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_HandshakeRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.HandshakeRequest, global::com.richardpianka.chess.network.HandshakeRequest.Builder> internal__static_com_richardpianka_chess_network_HandshakeRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_HandshakeResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.HandshakeResponse, global::com.richardpianka.chess.network.HandshakeResponse.Builder> internal__static_com_richardpianka_chess_network_HandshakeResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_IdentifyRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.IdentifyRequest, global::com.richardpianka.chess.network.IdentifyRequest.Builder> internal__static_com_richardpianka_chess_network_IdentifyRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_IdentifyResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.IdentifyResponse, global::com.richardpianka.chess.network.IdentifyResponse.Builder> internal__static_com_richardpianka_chess_network_IdentifyResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinChatRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinChatRequest, global::com.richardpianka.chess.network.JoinChatRequest.Builder> internal__static_com_richardpianka_chess_network_JoinChatRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinChatResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinChatResponse, global::com.richardpianka.chess.network.JoinChatResponse.Builder> internal__static_com_richardpianka_chess_network_JoinChatResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_RoomListRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.RoomListRequest, global::com.richardpianka.chess.network.RoomListRequest.Builder> internal__static_com_richardpianka_chess_network_RoomListRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_RoomListResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.RoomListResponse, global::com.richardpianka.chess.network.RoomListResponse.Builder> internal__static_com_richardpianka_chess_network_RoomListResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinRoomRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinRoomRequest, global::com.richardpianka.chess.network.JoinRoomRequest.Builder> internal__static_com_richardpianka_chess_network_JoinRoomRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinRoomResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinRoomResponse, global::com.richardpianka.chess.network.JoinRoomResponse.Builder> internal__static_com_richardpianka_chess_network_JoinRoomResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_SpeakRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.SpeakRequest, global::com.richardpianka.chess.network.SpeakRequest.Builder> internal__static_com_richardpianka_chess_network_SpeakRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_OperatorRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.OperatorRequest, global::com.richardpianka.chess.network.OperatorRequest.Builder> internal__static_com_richardpianka_chess_network_OperatorRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_OperatorResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.OperatorResponse, global::com.richardpianka.chess.network.OperatorResponse.Builder> internal__static_com_richardpianka_chess_network_OperatorResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_ChatRoomEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.ChatRoomEvent, global::com.richardpianka.chess.network.ChatRoomEvent.Builder> internal__static_com_richardpianka_chess_network_ChatRoomEvent__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_ChatUserEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.ChatUserEvent, global::com.richardpianka.chess.network.ChatUserEvent.Builder> internal__static_com_richardpianka_chess_network_ChatUserEvent__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_ChatSpeakEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.ChatSpeakEvent, global::com.richardpianka.chess.network.ChatSpeakEvent.Builder> internal__static_com_richardpianka_chess_network_ChatSpeakEvent__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_GameListRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.GameListRequest, global::com.richardpianka.chess.network.GameListRequest.Builder> internal__static_com_richardpianka_chess_network_GameListRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_GameListResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.GameListResponse, global::com.richardpianka.chess.network.GameListResponse.Builder> internal__static_com_richardpianka_chess_network_GameListResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_CreateGameRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.CreateGameRequest, global::com.richardpianka.chess.network.CreateGameRequest.Builder> internal__static_com_richardpianka_chess_network_CreateGameRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_CreateGameResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.CreateGameResponse, global::com.richardpianka.chess.network.CreateGameResponse.Builder> internal__static_com_richardpianka_chess_network_CreateGameResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinGameRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinGameRequest, global::com.richardpianka.chess.network.JoinGameRequest.Builder> internal__static_com_richardpianka_chess_network_JoinGameRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_JoinGameResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinGameResponse, global::com.richardpianka.chess.network.JoinGameResponse.Builder> internal__static_com_richardpianka_chess_network_JoinGameResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_LeaveGameRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.LeaveGameRequest, global::com.richardpianka.chess.network.LeaveGameRequest.Builder> internal__static_com_richardpianka_chess_network_LeaveGameRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_StartGameRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.StartGameRequest, global::com.richardpianka.chess.network.StartGameRequest.Builder> internal__static_com_richardpianka_chess_network_StartGameRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_StartGameResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.StartGameResponse, global::com.richardpianka.chess.network.StartGameResponse.Builder> internal__static_com_richardpianka_chess_network_StartGameResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_GameStartedEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.GameStartedEvent, global::com.richardpianka.chess.network.GameStartedEvent.Builder> internal__static_com_richardpianka_chess_network_GameStartedEvent__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_MovePieceRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.MovePieceRequest, global::com.richardpianka.chess.network.MovePieceRequest.Builder> internal__static_com_richardpianka_chess_network_MovePieceRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_MovePieceResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.MovePieceResponse, global::com.richardpianka.chess.network.MovePieceResponse.Builder> internal__static_com_richardpianka_chess_network_MovePieceResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_MovePieceEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.MovePieceEvent, global::com.richardpianka.chess.network.MovePieceEvent.Builder> internal__static_com_richardpianka_chess_network_MovePieceEvent__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_SpecialMovePieceRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.SpecialMovePieceRequest, global::com.richardpianka.chess.network.SpecialMovePieceRequest.Builder> internal__static_com_richardpianka_chess_network_SpecialMovePieceRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_SpecialMovePieceResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.SpecialMovePieceResponse, global::com.richardpianka.chess.network.SpecialMovePieceResponse.Builder> internal__static_com_richardpianka_chess_network_SpecialMovePieceResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_SpecialMovePieceEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.SpecialMovePieceEvent, global::com.richardpianka.chess.network.SpecialMovePieceEvent.Builder> internal__static_com_richardpianka_chess_network_SpecialMovePieceEvent__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_GameStatusEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.GameStatusEvent, global::com.richardpianka.chess.network.GameStatusEvent.Builder> internal__static_com_richardpianka_chess_network_GameStatusEvent__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_com_richardpianka_chess_network_TimeLeftEvent__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.TimeLeftEvent, global::com.richardpianka.chess.network.TimeLeftEvent.Builder> internal__static_com_richardpianka_chess_network_TimeLeftEvent__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static Contracts() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "Ch5wcm90b2J1Zi9jaGVzcy9jb250cmFjdHMucHJvdG8SH2NvbS5yaWNoYXJk" + 
          "cGlhbmthLmNoZXNzLm5ldHdvcmsixhQKCEVudmVsb3BlEksKEEhhbmRzaGFr" + 
          "ZVJlcXVlc3QYASABKAsyMS5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3" + 
          "b3JrLkhhbmRzaGFrZVJlcXVlc3QSTQoRSGFuZHNoYWtlUmVzcG9uc2UYAiAB" + 
          "KAsyMi5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLkhhbmRzaGFr" + 
          "ZVJlc3BvbnNlEkkKD0lkZW50aWZ5UmVxdWVzdBgDIAEoCzIwLmNvbS5yaWNo" + 
          "YXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuSWRlbnRpZnlSZXF1ZXN0EksKEElk" + 
          "ZW50aWZ5UmVzcG9uc2UYBCABKAsyMS5jb20ucmljaGFyZHBpYW5rYS5jaGVz" + 
          "cy5uZXR3b3JrLklkZW50aWZ5UmVzcG9uc2USSQoPSm9pbkNoYXRSZXF1ZXN0" + 
          "GAUgASgLMjAuY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5Kb2lu" + 
          "Q2hhdFJlcXVlc3QSSwoQSm9pbkNoYXRSZXNwb25zZRgGIAEoCzIxLmNvbS5y" + 
          "aWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuSm9pbkNoYXRSZXNwb25zZRJJ" + 
          "Cg9Sb29tTGlzdFJlcXVlc3QYByABKAsyMC5jb20ucmljaGFyZHBpYW5rYS5j" + 
          "aGVzcy5uZXR3b3JrLlJvb21MaXN0UmVxdWVzdBJLChBSb29tTGlzdFJlc3Bv" + 
          "bnNlGAggASgLMjEuY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5S" + 
          "b29tTGlzdFJlc3BvbnNlEkkKD0pvaW5Sb29tUmVxdWVzdBgJIAEoCzIwLmNv" + 
          "bS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuSm9pblJvb21SZXF1ZXN0" + 
          "EksKEEpvaW5Sb29tUmVzcG9uc2UYCiABKAsyMS5jb20ucmljaGFyZHBpYW5r" + 
          "YS5jaGVzcy5uZXR3b3JrLkpvaW5Sb29tUmVzcG9uc2USQwoMU3BlYWtSZXF1" + 
          "ZXN0GAsgASgLMi0uY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5T" + 
          "cGVha1JlcXVlc3QSSQoPT3BlcmF0b3JSZXF1ZXN0GAwgASgLMjAuY29tLnJp" + 
          "Y2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5PcGVyYXRvclJlcXVlc3QSSwoQ" + 
          "T3BlcmF0b3JSZXNwb25zZRgNIAEoCzIxLmNvbS5yaWNoYXJkcGlhbmthLmNo" + 
          "ZXNzLm5ldHdvcmsuT3BlcmF0b3JSZXNwb25zZRJFCg1DaGF0Um9vbUV2ZW50" + 
          "GA4gASgLMi4uY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5DaGF0" + 
          "Um9vbUV2ZW50EkUKDUNoYXRVc2VyRXZlbnQYDyABKAsyLi5jb20ucmljaGFy" + 
          "ZHBpYW5rYS5jaGVzcy5uZXR3b3JrLkNoYXRVc2VyRXZlbnQSRwoOQ2hhdFNw" + 
          "ZWFrRXZlbnQYECABKAsyLy5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3" + 
          "b3JrLkNoYXRTcGVha0V2ZW50EkkKD0dhbWVMaXN0UmVxdWVzdBgRIAEoCzIw" + 
          "LmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuR2FtZUxpc3RSZXF1" + 
          "ZXN0EksKEEdhbWVMaXN0UmVzcG9uc2UYEiABKAsyMS5jb20ucmljaGFyZHBp" + 
          "YW5rYS5jaGVzcy5uZXR3b3JrLkdhbWVMaXN0UmVzcG9uc2USTQoRQ3JlYXRl" + 
          "R2FtZVJlcXVlc3QYEyABKAsyMi5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5u" + 
          "ZXR3b3JrLkNyZWF0ZUdhbWVSZXF1ZXN0Ek8KEkNyZWF0ZUdhbWVSZXNwb25z" + 
          "ZRgUIAEoCzIzLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuQ3Jl" + 
          "YXRlR2FtZVJlc3BvbnNlEkkKD0pvaW5HYW1lUmVxdWVzdBgVIAEoCzIwLmNv" + 
          "bS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuSm9pbkdhbWVSZXF1ZXN0" + 
          "EksKEEpvaW5HYW1lUmVzcG9uc2UYFiABKAsyMS5jb20ucmljaGFyZHBpYW5r" + 
          "YS5jaGVzcy5uZXR3b3JrLkpvaW5HYW1lUmVzcG9uc2USSwoQTGVhdmVHYW1l" + 
          "UmVxdWVzdBgXIAEoCzIxLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdv" + 
          "cmsuTGVhdmVHYW1lUmVxdWVzdBJLChBTdGFydEdhbWVSZXF1ZXN0GBggASgL" + 
          "MjEuY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5TdGFydEdhbWVS" + 
          "ZXF1ZXN0Ek0KEVN0YXJ0R2FtZVJlc3BvbnNlGBkgASgLMjIuY29tLnJpY2hh" + 
          "cmRwaWFua2EuY2hlc3MubmV0d29yay5TdGFydEdhbWVSZXNwb25zZRJLChBH" + 
          "YW1lU3RhcnRlZEV2ZW50GBogASgLMjEuY29tLnJpY2hhcmRwaWFua2EuY2hl" + 
          "c3MubmV0d29yay5HYW1lU3RhcnRlZEV2ZW50EksKEE1vdmVQaWVjZVJlcXVl" + 
          "c3QYGyABKAsyMS5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLk1v" + 
          "dmVQaWVjZVJlcXVlc3QSTQoRTW92ZVBpZWNlUmVzcG9uc2UYHCABKAsyMi5j" + 
          "b20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLk1vdmVQaWVjZVJlc3Bv" + 
          "bnNlEkcKDk1vdmVQaWVjZUV2ZW50GB0gASgLMi8uY29tLnJpY2hhcmRwaWFu" + 
          "a2EuY2hlc3MubmV0d29yay5Nb3ZlUGllY2VFdmVudBJZChdTcGVjaWFsTW92" + 
          "ZVBpZWNlUmVxdWVzdBgeIAEoCzI4LmNvbS5yaWNoYXJkcGlhbmthLmNoZXNz" + 
          "Lm5ldHdvcmsuU3BlY2lhbE1vdmVQaWVjZVJlcXVlc3QSWwoYU3BlY2lhbE1v" + 
          "dmVQaWVjZVJlc3BvbnNlGB8gASgLMjkuY29tLnJpY2hhcmRwaWFua2EuY2hl" + 
          "c3MubmV0d29yay5TcGVjaWFsTW92ZVBpZWNlUmVzcG9uc2USVQoVU3BlY2lh" + 
          "bE1vdmVQaWVjZUV2ZW50GCAgASgLMjYuY29tLnJpY2hhcmRwaWFua2EuY2hl" + 
          "c3MubmV0d29yay5TcGVjaWFsTW92ZVBpZWNlRXZlbnQSSQoPR2FtZVN0YXR1" + 
          "c0V2ZW50GCIgASgLMjAuY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29y" + 
          "ay5HYW1lU3RhdHVzRXZlbnQSRQoNVGltZUxlZnRFdmVudBgjIAEoCzIuLmNv" + 
          "bS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuVGltZUxlZnRFdmVudCJ2" + 
          "CgpDb29yZGluYXRlEjMKBEZpbGUYASACKA4yJS5jb20ucmljaGFyZHBpYW5r" + 
          "YS5jaGVzcy5uZXR3b3JrLkZpbGUSMwoEUmFuaxgCIAIoDjIlLmNvbS5yaWNo" + 
          "YXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUmFuayKLAQoFUGllY2USNQoFQ29s" + 
          "b3IYASACKA4yJi5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLkNv" + 
          "bG9yEjsKCEZpZ3VyaW5lGAIgAigOMikuY29tLnJpY2hhcmRwaWFua2EuY2hl" + 
          "c3MubmV0d29yay5GaWd1cmluZRIOCgZOdW1iZXIYAyACKA0iswEKBE1vdmUS" + 
          "NQoFUGllY2UYASACKAsyJi5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3" + 
          "b3JrLlBpZWNlEjoKBVN0YXJ0GAIgAigLMisuY29tLnJpY2hhcmRwaWFua2Eu" + 
          "Y2hlc3MubmV0d29yay5Db29yZGluYXRlEjgKA0VuZBgDIAIoCzIrLmNvbS5y" + 
          "aWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuQ29vcmRpbmF0ZSJGCgtTcGVj" + 
          "aWFsTW92ZRI3CgZDYXN0bGUYASABKAsyJy5jb20ucmljaGFyZHBpYW5rYS5j" + 
          "aGVzcy5uZXR3b3JrLkNhc3RsZSJ0CgZDYXN0bGUSNAoEUm9vaxgBIAIoCzIm" + 
          "LmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUGllY2USNAoES2lu" + 
          "ZxgCIAIoCzImLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUGll" + 
          "Y2UiVwoHVmVyc2lvbhIXCgxWZXJzaW9uTWFqb3IYASABKA06ATESFwoMVmVy" + 
          "c2lvbk1pbm9yGAIgASgNOgEwEhoKD1ZlcnNpb25SZXZpc2lvbhgDIAEoDToB" + 
          "MCJPCgRSb29tEgwKBE5hbWUYASACKAkSOQoFRmxhZ3MYAiACKA4yKi5jb20u" + 
          "cmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLlJvb21GbGFncyJPCgZSZWNv" + 
          "cmQSDAoEV2lucxgBIAIoDRIOCgZMb3NzZXMYAiACKA0SEgoKU3RhbGVtYXRl" + 
          "cxgDIAIoDRITCgtEaXNjb25uZWN0cxgEIAIoDSKIAQoEVXNlchIMCgROYW1l" + 
          "GAEgAigJEjkKBUZsYWdzGAIgAigOMiouY29tLnJpY2hhcmRwaWFua2EuY2hl" + 
          "c3MubmV0d29yay5Vc2VyRmxhZ3MSNwoGUmVjb3JkGAMgAigLMicuY29tLnJp" + 
          "Y2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5SZWNvcmQieAoER2FtZRIMCgRO" + 
          "YW1lGAEgAigJEhAKCFBhc3N3b3JkGAIgASgJEg8KB1ByaXZhdGUYAyACKAgS" + 
          "PwoITWV0YURhdGEYBCABKAsyLS5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5u" + 
          "ZXR3b3JrLkdhbWVNZXRhZGF0YSK6AQoMR2FtZU1ldGFkYXRhEjYKB0NyZWF0" + 
          "ZWQYASABKAsyJS5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLlVz" + 
          "ZXISNQoGSm9pbmVkGAIgASgLMiUuY29tLnJpY2hhcmRwaWFua2EuY2hlc3Mu" + 
          "bmV0d29yay5Vc2VyEjsKCFVzZXJUaW1lGAMgASgLMikuY29tLnJpY2hhcmRw" + 
          "aWFua2EuY2hlc3MubmV0d29yay5Vc2VyVGltZSIxCghVc2VyVGltZRINCgVU" + 
          "aW1lZBgBIAIoCBIWCg5TZWNvbmRzUGVyVXNlchgCIAIoDSJNChBIYW5kc2hh" + 
          "a2VSZXF1ZXN0EjkKB1ZlcnNpb24YASACKAsyKC5jb20ucmljaGFyZHBpYW5r" + 
          "YS5jaGVzcy5uZXR3b3JrLlZlcnNpb24iTAoRSGFuZHNoYWtlUmVzcG9uc2US" + 
          "NwoGUmVzdWx0GAEgAigOMicuY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0" + 
          "d29yay5SZXN1bHQiNQoPSWRlbnRpZnlSZXF1ZXN0EhAKCFVzZXJuYW1lGAEg" + 
          "AigJEhAKCFBhc3N3b3JkGAIgASgJIlwKEElkZW50aWZ5UmVzcG9uc2USNwoG" + 
          "UmVzdWx0GAEgAigOMicuY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29y" + 
          "ay5SZXN1bHQSDwoHTWVzc2FnZRgCIAEoCSIRCg9Kb2luQ2hhdFJlcXVlc3Qi" + 
          "SwoQSm9pbkNoYXRSZXNwb25zZRI3CgZSZXN1bHQYASACKA4yJy5jb20ucmlj" + 
          "aGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLlJlc3VsdCIRCg9Sb29tTGlzdFJl" + 
          "cXVlc3QiSAoQUm9vbUxpc3RSZXNwb25zZRI0CgVSb29tcxgBIAMoCzIlLmNv" + 
          "bS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUm9vbSJGCg9Kb2luUm9v" + 
          "bVJlcXVlc3QSMwoEUm9vbRgBIAIoCzIlLmNvbS5yaWNoYXJkcGlhbmthLmNo" + 
          "ZXNzLm5ldHdvcmsuUm9vbSJLChBKb2luUm9vbVJlc3BvbnNlEjcKBlJlc3Vs" + 
          "dBgBIAIoDjInLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUmVz" + 
          "dWx0IpMBCgxTcGVha1JlcXVlc3QSOAoETW9kZRgBIAIoDjIqLmNvbS5yaWNo" + 
          "YXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuU3BlYWtNb2RlEg8KB01lc3NhZ2UY" + 
          "AiACKAkSOAoJUmVjaXBpZW50GAMgASgLMiUuY29tLnJpY2hhcmRwaWFua2Eu" + 
          "Y2hlc3MubmV0d29yay5Vc2VyIocBCg9PcGVyYXRvclJlcXVlc3QSPwoGQWN0" + 
          "aW9uGAEgAigOMi8uY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5P" + 
          "cGVyYXRvckFjdGlvbhIzCgRVc2VyGAIgASgLMiUuY29tLnJpY2hhcmRwaWFu" + 
          "a2EuY2hlc3MubmV0d29yay5Vc2VyIksKEE9wZXJhdG9yUmVzcG9uc2USNwoG" + 
          "UmVzdWx0GAEgAigOMicuY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29y" + 
          "ay5SZXN1bHQiegoNQ2hhdFJvb21FdmVudBIzCgRSb29tGAEgAigLMiUuY29t" + 
          "LnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5Sb29tEjQKBVVzZXJzGAIg" + 
          "AygLMiUuY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5Vc2VyItAB" + 
          "Cg1DaGF0VXNlckV2ZW50EjMKBFVzZXIYASACKAsyJS5jb20ucmljaGFyZHBp" + 
          "YW5rYS5jaGVzcy5uZXR3b3JrLlVzZXISSQoGU3RhdHVzGAIgAigOMjkuY29t" + 
          "LnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5DaGF0VXNlckV2ZW50LlVz" + 
          "ZXJTdGF0dXMSDwoHTWVzc2FnZRgDIAEoCSIuCgpVc2VyU3RhdHVzEgoKBkpv" + 
          "aW5lZBAAEggKBExlZnQQARIKCgZVcGRhdGUQAiKQAQoOQ2hhdFNwZWFrRXZl" + 
          "bnQSMwoEVXNlchgBIAIoCzIlLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5l" + 
          "dHdvcmsuVXNlchIPCgdNZXNzYWdlGAIgAigJEjgKBE1vZGUYAyACKA4yKi5j" + 
          "b20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLlNwZWFrTW9kZSIRCg9H" + 
          "YW1lTGlzdFJlcXVlc3QiSAoQR2FtZUxpc3RSZXNwb25zZRI0CgVHYW1lcxgB" + 
          "IAMoCzIlLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuR2FtZSIz" + 
          "ChFDcmVhdGVHYW1lUmVxdWVzdBIMCgROYW1lGAEgAigJEhAKCFBhc3N3b3Jk" + 
          "GAIgASgJIpMBChJDcmVhdGVHYW1lUmVzcG9uc2USNwoGUmVzdWx0GAEgAigO" + 
          "MicuY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5SZXN1bHQSMwoE" + 
          "R2FtZRgCIAEoCzIlLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsu" + 
          "R2FtZRIPCgdNZXNzYWdlGAMgASgJIlgKD0pvaW5HYW1lUmVxdWVzdBIzCgRH" + 
          "YW1lGAEgAigLMiUuY29tLnJpY2hhcmRwaWFua2EuY2hlc3MubmV0d29yay5H" + 
          "YW1lEhAKCFBhc3N3b3JkGAIgASgJIoABChBKb2luR2FtZVJlc3BvbnNlEjMK" + 
          "BEdhbWUYASACKAsyJS5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3Jr" + 
          "LkdhbWUSNwoGUmVzdWx0GAIgAigOMicuY29tLnJpY2hhcmRwaWFua2EuY2hl" + 
          "c3MubmV0d29yay5SZXN1bHQiEgoQTGVhdmVHYW1lUmVxdWVzdCISChBTdGFy" + 
          "dEdhbWVSZXF1ZXN0IkwKEVN0YXJ0R2FtZVJlc3BvbnNlEjcKBlJlc3VsdBgB" + 
          "IAIoDjInLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdvcmsuUmVzdWx0" + 
          "IkkKEEdhbWVTdGFydGVkRXZlbnQSNQoFQ29sb3IYASACKA4yJi5jb20ucmlj" + 
          "aGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLkNvbG9yIkcKEE1vdmVQaWVjZVJl" + 
          "cXVlc3QSMwoETW92ZRgBIAIoCzIlLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNz" + 
          "Lm5ldHdvcmsuTW92ZSJMChFNb3ZlUGllY2VSZXNwb25zZRI3CgZSZXN1bHQY" + 
          "ASACKA4yJy5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLlJlc3Vs" + 
          "dCJFCg5Nb3ZlUGllY2VFdmVudBIzCgRNb3ZlGAEgAigLMiUuY29tLnJpY2hh" + 
          "cmRwaWFua2EuY2hlc3MubmV0d29yay5Nb3ZlIlUKF1NwZWNpYWxNb3ZlUGll" + 
          "Y2VSZXF1ZXN0EjoKBE1vdmUYASACKAsyLC5jb20ucmljaGFyZHBpYW5rYS5j" + 
          "aGVzcy5uZXR3b3JrLlNwZWNpYWxNb3ZlIlMKGFNwZWNpYWxNb3ZlUGllY2VS" + 
          "ZXNwb25zZRI3CgZSZXN1bHQYASACKA4yJy5jb20ucmljaGFyZHBpYW5rYS5j" + 
          "aGVzcy5uZXR3b3JrLlJlc3VsdCJTChVTcGVjaWFsTW92ZVBpZWNlRXZlbnQS" + 
          "OgoETW92ZRgBIAIoCzIsLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNzLm5ldHdv" + 
          "cmsuU3BlY2lhbE1vdmUigwEKD0dhbWVTdGF0dXNFdmVudBI7CgZTdGF0dXMY" + 
          "ASABKA4yKy5jb20ucmljaGFyZHBpYW5rYS5jaGVzcy5uZXR3b3JrLkdhbWVT" + 
          "dGF0dXMSMwoEVXNlchgCIAEoCzIlLmNvbS5yaWNoYXJkcGlhbmthLmNoZXNz" + 
          "Lm5ldHdvcmsuVXNlciI7Cg1UaW1lTGVmdEV2ZW50EhQKDFdoaXRlU2Vjb25k" + 
          "cxgBIAIoDRIUCgxCbGFja1NlY29uZHMYAiACKA0qHQoFQ29sb3ISCQoFV2hp" + 
          "dGUQABIJCgVCbGFjaxABKksKCEZpZ3VyaW5lEggKBEtpbmcQABIJCgVRdWVl" + 
          "bhABEgoKBkJpc2hvcBACEgoKBktuaWdodBADEggKBFJvb2sQBBIICgRQYXdu" + 
          "EAUqRgoEUmFuaxIGCgJfMRAAEgYKAl8yEAESBgoCXzMQAhIGCgJfNBADEgYK" + 
          "Al81EAQSBgoCXzYQBRIGCgJfNxAGEgYKAl84EAcqRgoERmlsZRIGCgJfQRAA" + 
          "EgYKAl9CEAESBgoCX0MQAhIGCgJfRBADEgYKAl9FEAQSBgoCX0YQBRIGCgJf" + 
          "RxAGEgYKAl9IEAcqIgoGUmVzdWx0EgsKB1N1Y2Nlc3MQABILCgdGYWlsdXJl" + 
          "EAEqNAoJUm9vbUZsYWdzEgoKBlB1YmxpYxAAEgsKB1ByaXZhdGUQARIOCgpS" + 
          "ZXN0cmljdGVkEAIqNAoJVXNlckZsYWdzEg4KClBlZGVzdHJpYW4QABIMCghP" + 
          "cGVyYXRvchABEgkKBUFkbWluEAIqLwoJU3BlYWtNb2RlEgoKBk5vcm1hbBAA" + 
          "EgsKB1doaXNwZXIQARIJCgVFbW90ZRACKj4KDk9wZXJhdG9yQWN0aW9uEg0K" + 
          "CURlc2lnbmF0ZRAAEgoKBlJlc2lnbhABEggKBEtpY2sQAhIHCgNCYW4QAypL" + 
          "CgpHYW1lU3RhdHVzEggKBFBsYXkQABIKCgZQYXVzZWQQARILCgdWaWN0b3J5" + 
          "EAISCwoHRm9yZmVpdBADEg0KCVN0YWxlbWF0ZRAEQiwKH2NvbS5yaWNoYXJk" + 
          "cGlhbmthLmNoZXNzLm5ldHdvcmtCCUNvbnRyYWN0cw==");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_com_richardpianka_chess_network_Envelope__Descriptor = Descriptor.MessageTypes[0];
        internal__static_com_richardpianka_chess_network_Envelope__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Envelope, global::com.richardpianka.chess.network.Envelope.Builder>(internal__static_com_richardpianka_chess_network_Envelope__Descriptor,
                new string[] { "HandshakeRequest", "HandshakeResponse", "IdentifyRequest", "IdentifyResponse", "JoinChatRequest", "JoinChatResponse", "RoomListRequest", "RoomListResponse", "JoinRoomRequest", "JoinRoomResponse", "SpeakRequest", "OperatorRequest", "OperatorResponse", "ChatRoomEvent", "ChatUserEvent", "ChatSpeakEvent", "GameListRequest", "GameListResponse", "CreateGameRequest", "CreateGameResponse", "JoinGameRequest", "JoinGameResponse", "LeaveGameRequest", "StartGameRequest", "StartGameResponse", "GameStartedEvent", "MovePieceRequest", "MovePieceResponse", "MovePieceEvent", "SpecialMovePieceRequest", "SpecialMovePieceResponse", "SpecialMovePieceEvent", "GameStatusEvent", "TimeLeftEvent", });
        internal__static_com_richardpianka_chess_network_Coordinate__Descriptor = Descriptor.MessageTypes[1];
        internal__static_com_richardpianka_chess_network_Coordinate__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Coordinate, global::com.richardpianka.chess.network.Coordinate.Builder>(internal__static_com_richardpianka_chess_network_Coordinate__Descriptor,
                new string[] { "File", "Rank", });
        internal__static_com_richardpianka_chess_network_Piece__Descriptor = Descriptor.MessageTypes[2];
        internal__static_com_richardpianka_chess_network_Piece__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Piece, global::com.richardpianka.chess.network.Piece.Builder>(internal__static_com_richardpianka_chess_network_Piece__Descriptor,
                new string[] { "Color", "Figurine", "Number", });
        internal__static_com_richardpianka_chess_network_Move__Descriptor = Descriptor.MessageTypes[3];
        internal__static_com_richardpianka_chess_network_Move__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Move, global::com.richardpianka.chess.network.Move.Builder>(internal__static_com_richardpianka_chess_network_Move__Descriptor,
                new string[] { "Piece", "Start", "End", });
        internal__static_com_richardpianka_chess_network_SpecialMove__Descriptor = Descriptor.MessageTypes[4];
        internal__static_com_richardpianka_chess_network_SpecialMove__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.SpecialMove, global::com.richardpianka.chess.network.SpecialMove.Builder>(internal__static_com_richardpianka_chess_network_SpecialMove__Descriptor,
                new string[] { "Castle", });
        internal__static_com_richardpianka_chess_network_Castle__Descriptor = Descriptor.MessageTypes[5];
        internal__static_com_richardpianka_chess_network_Castle__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Castle, global::com.richardpianka.chess.network.Castle.Builder>(internal__static_com_richardpianka_chess_network_Castle__Descriptor,
                new string[] { "Rook", "King", });
        internal__static_com_richardpianka_chess_network_Version__Descriptor = Descriptor.MessageTypes[6];
        internal__static_com_richardpianka_chess_network_Version__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Version, global::com.richardpianka.chess.network.Version.Builder>(internal__static_com_richardpianka_chess_network_Version__Descriptor,
                new string[] { "VersionMajor", "VersionMinor", "VersionRevision", });
        internal__static_com_richardpianka_chess_network_Room__Descriptor = Descriptor.MessageTypes[7];
        internal__static_com_richardpianka_chess_network_Room__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Room, global::com.richardpianka.chess.network.Room.Builder>(internal__static_com_richardpianka_chess_network_Room__Descriptor,
                new string[] { "Name", "Flags", });
        internal__static_com_richardpianka_chess_network_Record__Descriptor = Descriptor.MessageTypes[8];
        internal__static_com_richardpianka_chess_network_Record__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Record, global::com.richardpianka.chess.network.Record.Builder>(internal__static_com_richardpianka_chess_network_Record__Descriptor,
                new string[] { "Wins", "Losses", "Stalemates", "Disconnects", });
        internal__static_com_richardpianka_chess_network_User__Descriptor = Descriptor.MessageTypes[9];
        internal__static_com_richardpianka_chess_network_User__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.User, global::com.richardpianka.chess.network.User.Builder>(internal__static_com_richardpianka_chess_network_User__Descriptor,
                new string[] { "Name", "Flags", "Record", });
        internal__static_com_richardpianka_chess_network_Game__Descriptor = Descriptor.MessageTypes[10];
        internal__static_com_richardpianka_chess_network_Game__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.Game, global::com.richardpianka.chess.network.Game.Builder>(internal__static_com_richardpianka_chess_network_Game__Descriptor,
                new string[] { "Name", "Password", "Private", "MetaData", });
        internal__static_com_richardpianka_chess_network_GameMetadata__Descriptor = Descriptor.MessageTypes[11];
        internal__static_com_richardpianka_chess_network_GameMetadata__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.GameMetadata, global::com.richardpianka.chess.network.GameMetadata.Builder>(internal__static_com_richardpianka_chess_network_GameMetadata__Descriptor,
                new string[] { "Created", "Joined", "UserTime", });
        internal__static_com_richardpianka_chess_network_UserTime__Descriptor = Descriptor.MessageTypes[12];
        internal__static_com_richardpianka_chess_network_UserTime__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.UserTime, global::com.richardpianka.chess.network.UserTime.Builder>(internal__static_com_richardpianka_chess_network_UserTime__Descriptor,
                new string[] { "Timed", "SecondsPerUser", });
        internal__static_com_richardpianka_chess_network_HandshakeRequest__Descriptor = Descriptor.MessageTypes[13];
        internal__static_com_richardpianka_chess_network_HandshakeRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.HandshakeRequest, global::com.richardpianka.chess.network.HandshakeRequest.Builder>(internal__static_com_richardpianka_chess_network_HandshakeRequest__Descriptor,
                new string[] { "Version", });
        internal__static_com_richardpianka_chess_network_HandshakeResponse__Descriptor = Descriptor.MessageTypes[14];
        internal__static_com_richardpianka_chess_network_HandshakeResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.HandshakeResponse, global::com.richardpianka.chess.network.HandshakeResponse.Builder>(internal__static_com_richardpianka_chess_network_HandshakeResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_IdentifyRequest__Descriptor = Descriptor.MessageTypes[15];
        internal__static_com_richardpianka_chess_network_IdentifyRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.IdentifyRequest, global::com.richardpianka.chess.network.IdentifyRequest.Builder>(internal__static_com_richardpianka_chess_network_IdentifyRequest__Descriptor,
                new string[] { "Username", "Password", });
        internal__static_com_richardpianka_chess_network_IdentifyResponse__Descriptor = Descriptor.MessageTypes[16];
        internal__static_com_richardpianka_chess_network_IdentifyResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.IdentifyResponse, global::com.richardpianka.chess.network.IdentifyResponse.Builder>(internal__static_com_richardpianka_chess_network_IdentifyResponse__Descriptor,
                new string[] { "Result", "Message", });
        internal__static_com_richardpianka_chess_network_JoinChatRequest__Descriptor = Descriptor.MessageTypes[17];
        internal__static_com_richardpianka_chess_network_JoinChatRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinChatRequest, global::com.richardpianka.chess.network.JoinChatRequest.Builder>(internal__static_com_richardpianka_chess_network_JoinChatRequest__Descriptor,
                new string[] { });
        internal__static_com_richardpianka_chess_network_JoinChatResponse__Descriptor = Descriptor.MessageTypes[18];
        internal__static_com_richardpianka_chess_network_JoinChatResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinChatResponse, global::com.richardpianka.chess.network.JoinChatResponse.Builder>(internal__static_com_richardpianka_chess_network_JoinChatResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_RoomListRequest__Descriptor = Descriptor.MessageTypes[19];
        internal__static_com_richardpianka_chess_network_RoomListRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.RoomListRequest, global::com.richardpianka.chess.network.RoomListRequest.Builder>(internal__static_com_richardpianka_chess_network_RoomListRequest__Descriptor,
                new string[] { });
        internal__static_com_richardpianka_chess_network_RoomListResponse__Descriptor = Descriptor.MessageTypes[20];
        internal__static_com_richardpianka_chess_network_RoomListResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.RoomListResponse, global::com.richardpianka.chess.network.RoomListResponse.Builder>(internal__static_com_richardpianka_chess_network_RoomListResponse__Descriptor,
                new string[] { "Rooms", });
        internal__static_com_richardpianka_chess_network_JoinRoomRequest__Descriptor = Descriptor.MessageTypes[21];
        internal__static_com_richardpianka_chess_network_JoinRoomRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinRoomRequest, global::com.richardpianka.chess.network.JoinRoomRequest.Builder>(internal__static_com_richardpianka_chess_network_JoinRoomRequest__Descriptor,
                new string[] { "Room", });
        internal__static_com_richardpianka_chess_network_JoinRoomResponse__Descriptor = Descriptor.MessageTypes[22];
        internal__static_com_richardpianka_chess_network_JoinRoomResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinRoomResponse, global::com.richardpianka.chess.network.JoinRoomResponse.Builder>(internal__static_com_richardpianka_chess_network_JoinRoomResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_SpeakRequest__Descriptor = Descriptor.MessageTypes[23];
        internal__static_com_richardpianka_chess_network_SpeakRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.SpeakRequest, global::com.richardpianka.chess.network.SpeakRequest.Builder>(internal__static_com_richardpianka_chess_network_SpeakRequest__Descriptor,
                new string[] { "Mode", "Message", "Recipient", });
        internal__static_com_richardpianka_chess_network_OperatorRequest__Descriptor = Descriptor.MessageTypes[24];
        internal__static_com_richardpianka_chess_network_OperatorRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.OperatorRequest, global::com.richardpianka.chess.network.OperatorRequest.Builder>(internal__static_com_richardpianka_chess_network_OperatorRequest__Descriptor,
                new string[] { "Action", "User", });
        internal__static_com_richardpianka_chess_network_OperatorResponse__Descriptor = Descriptor.MessageTypes[25];
        internal__static_com_richardpianka_chess_network_OperatorResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.OperatorResponse, global::com.richardpianka.chess.network.OperatorResponse.Builder>(internal__static_com_richardpianka_chess_network_OperatorResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_ChatRoomEvent__Descriptor = Descriptor.MessageTypes[26];
        internal__static_com_richardpianka_chess_network_ChatRoomEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.ChatRoomEvent, global::com.richardpianka.chess.network.ChatRoomEvent.Builder>(internal__static_com_richardpianka_chess_network_ChatRoomEvent__Descriptor,
                new string[] { "Room", "Users", });
        internal__static_com_richardpianka_chess_network_ChatUserEvent__Descriptor = Descriptor.MessageTypes[27];
        internal__static_com_richardpianka_chess_network_ChatUserEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.ChatUserEvent, global::com.richardpianka.chess.network.ChatUserEvent.Builder>(internal__static_com_richardpianka_chess_network_ChatUserEvent__Descriptor,
                new string[] { "User", "Status", "Message", });
        internal__static_com_richardpianka_chess_network_ChatSpeakEvent__Descriptor = Descriptor.MessageTypes[28];
        internal__static_com_richardpianka_chess_network_ChatSpeakEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.ChatSpeakEvent, global::com.richardpianka.chess.network.ChatSpeakEvent.Builder>(internal__static_com_richardpianka_chess_network_ChatSpeakEvent__Descriptor,
                new string[] { "User", "Message", "Mode", });
        internal__static_com_richardpianka_chess_network_GameListRequest__Descriptor = Descriptor.MessageTypes[29];
        internal__static_com_richardpianka_chess_network_GameListRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.GameListRequest, global::com.richardpianka.chess.network.GameListRequest.Builder>(internal__static_com_richardpianka_chess_network_GameListRequest__Descriptor,
                new string[] { });
        internal__static_com_richardpianka_chess_network_GameListResponse__Descriptor = Descriptor.MessageTypes[30];
        internal__static_com_richardpianka_chess_network_GameListResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.GameListResponse, global::com.richardpianka.chess.network.GameListResponse.Builder>(internal__static_com_richardpianka_chess_network_GameListResponse__Descriptor,
                new string[] { "Games", });
        internal__static_com_richardpianka_chess_network_CreateGameRequest__Descriptor = Descriptor.MessageTypes[31];
        internal__static_com_richardpianka_chess_network_CreateGameRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.CreateGameRequest, global::com.richardpianka.chess.network.CreateGameRequest.Builder>(internal__static_com_richardpianka_chess_network_CreateGameRequest__Descriptor,
                new string[] { "Name", "Password", });
        internal__static_com_richardpianka_chess_network_CreateGameResponse__Descriptor = Descriptor.MessageTypes[32];
        internal__static_com_richardpianka_chess_network_CreateGameResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.CreateGameResponse, global::com.richardpianka.chess.network.CreateGameResponse.Builder>(internal__static_com_richardpianka_chess_network_CreateGameResponse__Descriptor,
                new string[] { "Result", "Game", "Message", });
        internal__static_com_richardpianka_chess_network_JoinGameRequest__Descriptor = Descriptor.MessageTypes[33];
        internal__static_com_richardpianka_chess_network_JoinGameRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinGameRequest, global::com.richardpianka.chess.network.JoinGameRequest.Builder>(internal__static_com_richardpianka_chess_network_JoinGameRequest__Descriptor,
                new string[] { "Game", "Password", });
        internal__static_com_richardpianka_chess_network_JoinGameResponse__Descriptor = Descriptor.MessageTypes[34];
        internal__static_com_richardpianka_chess_network_JoinGameResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.JoinGameResponse, global::com.richardpianka.chess.network.JoinGameResponse.Builder>(internal__static_com_richardpianka_chess_network_JoinGameResponse__Descriptor,
                new string[] { "Game", "Result", });
        internal__static_com_richardpianka_chess_network_LeaveGameRequest__Descriptor = Descriptor.MessageTypes[35];
        internal__static_com_richardpianka_chess_network_LeaveGameRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.LeaveGameRequest, global::com.richardpianka.chess.network.LeaveGameRequest.Builder>(internal__static_com_richardpianka_chess_network_LeaveGameRequest__Descriptor,
                new string[] { });
        internal__static_com_richardpianka_chess_network_StartGameRequest__Descriptor = Descriptor.MessageTypes[36];
        internal__static_com_richardpianka_chess_network_StartGameRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.StartGameRequest, global::com.richardpianka.chess.network.StartGameRequest.Builder>(internal__static_com_richardpianka_chess_network_StartGameRequest__Descriptor,
                new string[] { });
        internal__static_com_richardpianka_chess_network_StartGameResponse__Descriptor = Descriptor.MessageTypes[37];
        internal__static_com_richardpianka_chess_network_StartGameResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.StartGameResponse, global::com.richardpianka.chess.network.StartGameResponse.Builder>(internal__static_com_richardpianka_chess_network_StartGameResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_GameStartedEvent__Descriptor = Descriptor.MessageTypes[38];
        internal__static_com_richardpianka_chess_network_GameStartedEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.GameStartedEvent, global::com.richardpianka.chess.network.GameStartedEvent.Builder>(internal__static_com_richardpianka_chess_network_GameStartedEvent__Descriptor,
                new string[] { "Color", });
        internal__static_com_richardpianka_chess_network_MovePieceRequest__Descriptor = Descriptor.MessageTypes[39];
        internal__static_com_richardpianka_chess_network_MovePieceRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.MovePieceRequest, global::com.richardpianka.chess.network.MovePieceRequest.Builder>(internal__static_com_richardpianka_chess_network_MovePieceRequest__Descriptor,
                new string[] { "Move", });
        internal__static_com_richardpianka_chess_network_MovePieceResponse__Descriptor = Descriptor.MessageTypes[40];
        internal__static_com_richardpianka_chess_network_MovePieceResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.MovePieceResponse, global::com.richardpianka.chess.network.MovePieceResponse.Builder>(internal__static_com_richardpianka_chess_network_MovePieceResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_MovePieceEvent__Descriptor = Descriptor.MessageTypes[41];
        internal__static_com_richardpianka_chess_network_MovePieceEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.MovePieceEvent, global::com.richardpianka.chess.network.MovePieceEvent.Builder>(internal__static_com_richardpianka_chess_network_MovePieceEvent__Descriptor,
                new string[] { "Move", });
        internal__static_com_richardpianka_chess_network_SpecialMovePieceRequest__Descriptor = Descriptor.MessageTypes[42];
        internal__static_com_richardpianka_chess_network_SpecialMovePieceRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.SpecialMovePieceRequest, global::com.richardpianka.chess.network.SpecialMovePieceRequest.Builder>(internal__static_com_richardpianka_chess_network_SpecialMovePieceRequest__Descriptor,
                new string[] { "Move", });
        internal__static_com_richardpianka_chess_network_SpecialMovePieceResponse__Descriptor = Descriptor.MessageTypes[43];
        internal__static_com_richardpianka_chess_network_SpecialMovePieceResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.SpecialMovePieceResponse, global::com.richardpianka.chess.network.SpecialMovePieceResponse.Builder>(internal__static_com_richardpianka_chess_network_SpecialMovePieceResponse__Descriptor,
                new string[] { "Result", });
        internal__static_com_richardpianka_chess_network_SpecialMovePieceEvent__Descriptor = Descriptor.MessageTypes[44];
        internal__static_com_richardpianka_chess_network_SpecialMovePieceEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.SpecialMovePieceEvent, global::com.richardpianka.chess.network.SpecialMovePieceEvent.Builder>(internal__static_com_richardpianka_chess_network_SpecialMovePieceEvent__Descriptor,
                new string[] { "Move", });
        internal__static_com_richardpianka_chess_network_GameStatusEvent__Descriptor = Descriptor.MessageTypes[45];
        internal__static_com_richardpianka_chess_network_GameStatusEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.GameStatusEvent, global::com.richardpianka.chess.network.GameStatusEvent.Builder>(internal__static_com_richardpianka_chess_network_GameStatusEvent__Descriptor,
                new string[] { "Status", "User", });
        internal__static_com_richardpianka_chess_network_TimeLeftEvent__Descriptor = Descriptor.MessageTypes[46];
        internal__static_com_richardpianka_chess_network_TimeLeftEvent__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::com.richardpianka.chess.network.TimeLeftEvent, global::com.richardpianka.chess.network.TimeLeftEvent.Builder>(internal__static_com_richardpianka_chess_network_TimeLeftEvent__Descriptor,
                new string[] { "WhiteSeconds", "BlackSeconds", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Enums
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum Color {
    White = 0,
    Black = 1,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum Figurine {
    King = 0,
    Queen = 1,
    Bishop = 2,
    Knight = 3,
    Rook = 4,
    Pawn = 5,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum Rank {
    _1 = 0,
    _2 = 1,
    _3 = 2,
    _4 = 3,
    _5 = 4,
    _6 = 5,
    _7 = 6,
    _8 = 7,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum File {
    _A = 0,
    _B = 1,
    _C = 2,
    _D = 3,
    _E = 4,
    _F = 5,
    _G = 6,
    _H = 7,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum Result {
    Success = 0,
    Failure = 1,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum RoomFlags {
    Public = 0,
    Private = 1,
    Restricted = 2,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum UserFlags {
    Pedestrian = 0,
    Operator = 1,
    Admin = 2,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum SpeakMode {
    Normal = 0,
    Whisper = 1,
    Emote = 2,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum OperatorAction {
    Designate = 0,
    Resign = 1,
    Kick = 2,
    Ban = 3,
  }
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public enum GameStatus {
    Play = 0,
    Paused = 1,
    Victory = 2,
    Forfeit = 3,
    Stalemate = 4,
  }
  
  #endregion
  
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Envelope : pb::GeneratedMessage<Envelope, Envelope.Builder> {
    private Envelope() { }
    private static readonly Envelope defaultInstance = new Envelope().MakeReadOnly();
    private static readonly string[] _envelopeFieldNames = new string[] { "ChatRoomEvent", "ChatSpeakEvent", "ChatUserEvent", "CreateGameRequest", "CreateGameResponse", "GameListRequest", "GameListResponse", "GameStartedEvent", "GameStatusEvent", "HandshakeRequest", "HandshakeResponse", "IdentifyRequest", "IdentifyResponse", "JoinChatRequest", "JoinChatResponse", "JoinGameRequest", "JoinGameResponse", "JoinRoomRequest", "JoinRoomResponse", "LeaveGameRequest", "MovePieceEvent", "MovePieceRequest", "MovePieceResponse", "OperatorRequest", "OperatorResponse", "RoomListRequest", "RoomListResponse", "SpeakRequest", "SpecialMovePieceEvent", "SpecialMovePieceRequest", "SpecialMovePieceResponse", "StartGameRequest", "StartGameResponse", "TimeLeftEvent" };
    private static readonly uint[] _envelopeFieldTags = new uint[] { 114, 130, 122, 154, 162, 138, 146, 210, 274, 10, 18, 26, 34, 42, 50, 170, 178, 74, 82, 186, 234, 218, 226, 98, 106, 58, 66, 90, 258, 242, 250, 194, 202, 282 };
    public static Envelope DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Envelope DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Envelope ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Envelope__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Envelope, Envelope.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Envelope__FieldAccessorTable; }
    }
    
    public const int HandshakeRequestFieldNumber = 1;
    private bool hasHandshakeRequest;
    private global::com.richardpianka.chess.network.HandshakeRequest handshakeRequest_;
    public bool HasHandshakeRequest {
      get { return hasHandshakeRequest; }
    }
    public global::com.richardpianka.chess.network.HandshakeRequest HandshakeRequest {
      get { return handshakeRequest_ ?? global::com.richardpianka.chess.network.HandshakeRequest.DefaultInstance; }
    }
    
    public const int HandshakeResponseFieldNumber = 2;
    private bool hasHandshakeResponse;
    private global::com.richardpianka.chess.network.HandshakeResponse handshakeResponse_;
    public bool HasHandshakeResponse {
      get { return hasHandshakeResponse; }
    }
    public global::com.richardpianka.chess.network.HandshakeResponse HandshakeResponse {
      get { return handshakeResponse_ ?? global::com.richardpianka.chess.network.HandshakeResponse.DefaultInstance; }
    }
    
    public const int IdentifyRequestFieldNumber = 3;
    private bool hasIdentifyRequest;
    private global::com.richardpianka.chess.network.IdentifyRequest identifyRequest_;
    public bool HasIdentifyRequest {
      get { return hasIdentifyRequest; }
    }
    public global::com.richardpianka.chess.network.IdentifyRequest IdentifyRequest {
      get { return identifyRequest_ ?? global::com.richardpianka.chess.network.IdentifyRequest.DefaultInstance; }
    }
    
    public const int IdentifyResponseFieldNumber = 4;
    private bool hasIdentifyResponse;
    private global::com.richardpianka.chess.network.IdentifyResponse identifyResponse_;
    public bool HasIdentifyResponse {
      get { return hasIdentifyResponse; }
    }
    public global::com.richardpianka.chess.network.IdentifyResponse IdentifyResponse {
      get { return identifyResponse_ ?? global::com.richardpianka.chess.network.IdentifyResponse.DefaultInstance; }
    }
    
    public const int JoinChatRequestFieldNumber = 5;
    private bool hasJoinChatRequest;
    private global::com.richardpianka.chess.network.JoinChatRequest joinChatRequest_;
    public bool HasJoinChatRequest {
      get { return hasJoinChatRequest; }
    }
    public global::com.richardpianka.chess.network.JoinChatRequest JoinChatRequest {
      get { return joinChatRequest_ ?? global::com.richardpianka.chess.network.JoinChatRequest.DefaultInstance; }
    }
    
    public const int JoinChatResponseFieldNumber = 6;
    private bool hasJoinChatResponse;
    private global::com.richardpianka.chess.network.JoinChatResponse joinChatResponse_;
    public bool HasJoinChatResponse {
      get { return hasJoinChatResponse; }
    }
    public global::com.richardpianka.chess.network.JoinChatResponse JoinChatResponse {
      get { return joinChatResponse_ ?? global::com.richardpianka.chess.network.JoinChatResponse.DefaultInstance; }
    }
    
    public const int RoomListRequestFieldNumber = 7;
    private bool hasRoomListRequest;
    private global::com.richardpianka.chess.network.RoomListRequest roomListRequest_;
    public bool HasRoomListRequest {
      get { return hasRoomListRequest; }
    }
    public global::com.richardpianka.chess.network.RoomListRequest RoomListRequest {
      get { return roomListRequest_ ?? global::com.richardpianka.chess.network.RoomListRequest.DefaultInstance; }
    }
    
    public const int RoomListResponseFieldNumber = 8;
    private bool hasRoomListResponse;
    private global::com.richardpianka.chess.network.RoomListResponse roomListResponse_;
    public bool HasRoomListResponse {
      get { return hasRoomListResponse; }
    }
    public global::com.richardpianka.chess.network.RoomListResponse RoomListResponse {
      get { return roomListResponse_ ?? global::com.richardpianka.chess.network.RoomListResponse.DefaultInstance; }
    }
    
    public const int JoinRoomRequestFieldNumber = 9;
    private bool hasJoinRoomRequest;
    private global::com.richardpianka.chess.network.JoinRoomRequest joinRoomRequest_;
    public bool HasJoinRoomRequest {
      get { return hasJoinRoomRequest; }
    }
    public global::com.richardpianka.chess.network.JoinRoomRequest JoinRoomRequest {
      get { return joinRoomRequest_ ?? global::com.richardpianka.chess.network.JoinRoomRequest.DefaultInstance; }
    }
    
    public const int JoinRoomResponseFieldNumber = 10;
    private bool hasJoinRoomResponse;
    private global::com.richardpianka.chess.network.JoinRoomResponse joinRoomResponse_;
    public bool HasJoinRoomResponse {
      get { return hasJoinRoomResponse; }
    }
    public global::com.richardpianka.chess.network.JoinRoomResponse JoinRoomResponse {
      get { return joinRoomResponse_ ?? global::com.richardpianka.chess.network.JoinRoomResponse.DefaultInstance; }
    }
    
    public const int SpeakRequestFieldNumber = 11;
    private bool hasSpeakRequest;
    private global::com.richardpianka.chess.network.SpeakRequest speakRequest_;
    public bool HasSpeakRequest {
      get { return hasSpeakRequest; }
    }
    public global::com.richardpianka.chess.network.SpeakRequest SpeakRequest {
      get { return speakRequest_ ?? global::com.richardpianka.chess.network.SpeakRequest.DefaultInstance; }
    }
    
    public const int OperatorRequestFieldNumber = 12;
    private bool hasOperatorRequest;
    private global::com.richardpianka.chess.network.OperatorRequest operatorRequest_;
    public bool HasOperatorRequest {
      get { return hasOperatorRequest; }
    }
    public global::com.richardpianka.chess.network.OperatorRequest OperatorRequest {
      get { return operatorRequest_ ?? global::com.richardpianka.chess.network.OperatorRequest.DefaultInstance; }
    }
    
    public const int OperatorResponseFieldNumber = 13;
    private bool hasOperatorResponse;
    private global::com.richardpianka.chess.network.OperatorResponse operatorResponse_;
    public bool HasOperatorResponse {
      get { return hasOperatorResponse; }
    }
    public global::com.richardpianka.chess.network.OperatorResponse OperatorResponse {
      get { return operatorResponse_ ?? global::com.richardpianka.chess.network.OperatorResponse.DefaultInstance; }
    }
    
    public const int ChatRoomEventFieldNumber = 14;
    private bool hasChatRoomEvent;
    private global::com.richardpianka.chess.network.ChatRoomEvent chatRoomEvent_;
    public bool HasChatRoomEvent {
      get { return hasChatRoomEvent; }
    }
    public global::com.richardpianka.chess.network.ChatRoomEvent ChatRoomEvent {
      get { return chatRoomEvent_ ?? global::com.richardpianka.chess.network.ChatRoomEvent.DefaultInstance; }
    }
    
    public const int ChatUserEventFieldNumber = 15;
    private bool hasChatUserEvent;
    private global::com.richardpianka.chess.network.ChatUserEvent chatUserEvent_;
    public bool HasChatUserEvent {
      get { return hasChatUserEvent; }
    }
    public global::com.richardpianka.chess.network.ChatUserEvent ChatUserEvent {
      get { return chatUserEvent_ ?? global::com.richardpianka.chess.network.ChatUserEvent.DefaultInstance; }
    }
    
    public const int ChatSpeakEventFieldNumber = 16;
    private bool hasChatSpeakEvent;
    private global::com.richardpianka.chess.network.ChatSpeakEvent chatSpeakEvent_;
    public bool HasChatSpeakEvent {
      get { return hasChatSpeakEvent; }
    }
    public global::com.richardpianka.chess.network.ChatSpeakEvent ChatSpeakEvent {
      get { return chatSpeakEvent_ ?? global::com.richardpianka.chess.network.ChatSpeakEvent.DefaultInstance; }
    }
    
    public const int GameListRequestFieldNumber = 17;
    private bool hasGameListRequest;
    private global::com.richardpianka.chess.network.GameListRequest gameListRequest_;
    public bool HasGameListRequest {
      get { return hasGameListRequest; }
    }
    public global::com.richardpianka.chess.network.GameListRequest GameListRequest {
      get { return gameListRequest_ ?? global::com.richardpianka.chess.network.GameListRequest.DefaultInstance; }
    }
    
    public const int GameListResponseFieldNumber = 18;
    private bool hasGameListResponse;
    private global::com.richardpianka.chess.network.GameListResponse gameListResponse_;
    public bool HasGameListResponse {
      get { return hasGameListResponse; }
    }
    public global::com.richardpianka.chess.network.GameListResponse GameListResponse {
      get { return gameListResponse_ ?? global::com.richardpianka.chess.network.GameListResponse.DefaultInstance; }
    }
    
    public const int CreateGameRequestFieldNumber = 19;
    private bool hasCreateGameRequest;
    private global::com.richardpianka.chess.network.CreateGameRequest createGameRequest_;
    public bool HasCreateGameRequest {
      get { return hasCreateGameRequest; }
    }
    public global::com.richardpianka.chess.network.CreateGameRequest CreateGameRequest {
      get { return createGameRequest_ ?? global::com.richardpianka.chess.network.CreateGameRequest.DefaultInstance; }
    }
    
    public const int CreateGameResponseFieldNumber = 20;
    private bool hasCreateGameResponse;
    private global::com.richardpianka.chess.network.CreateGameResponse createGameResponse_;
    public bool HasCreateGameResponse {
      get { return hasCreateGameResponse; }
    }
    public global::com.richardpianka.chess.network.CreateGameResponse CreateGameResponse {
      get { return createGameResponse_ ?? global::com.richardpianka.chess.network.CreateGameResponse.DefaultInstance; }
    }
    
    public const int JoinGameRequestFieldNumber = 21;
    private bool hasJoinGameRequest;
    private global::com.richardpianka.chess.network.JoinGameRequest joinGameRequest_;
    public bool HasJoinGameRequest {
      get { return hasJoinGameRequest; }
    }
    public global::com.richardpianka.chess.network.JoinGameRequest JoinGameRequest {
      get { return joinGameRequest_ ?? global::com.richardpianka.chess.network.JoinGameRequest.DefaultInstance; }
    }
    
    public const int JoinGameResponseFieldNumber = 22;
    private bool hasJoinGameResponse;
    private global::com.richardpianka.chess.network.JoinGameResponse joinGameResponse_;
    public bool HasJoinGameResponse {
      get { return hasJoinGameResponse; }
    }
    public global::com.richardpianka.chess.network.JoinGameResponse JoinGameResponse {
      get { return joinGameResponse_ ?? global::com.richardpianka.chess.network.JoinGameResponse.DefaultInstance; }
    }
    
    public const int LeaveGameRequestFieldNumber = 23;
    private bool hasLeaveGameRequest;
    private global::com.richardpianka.chess.network.LeaveGameRequest leaveGameRequest_;
    public bool HasLeaveGameRequest {
      get { return hasLeaveGameRequest; }
    }
    public global::com.richardpianka.chess.network.LeaveGameRequest LeaveGameRequest {
      get { return leaveGameRequest_ ?? global::com.richardpianka.chess.network.LeaveGameRequest.DefaultInstance; }
    }
    
    public const int StartGameRequestFieldNumber = 24;
    private bool hasStartGameRequest;
    private global::com.richardpianka.chess.network.StartGameRequest startGameRequest_;
    public bool HasStartGameRequest {
      get { return hasStartGameRequest; }
    }
    public global::com.richardpianka.chess.network.StartGameRequest StartGameRequest {
      get { return startGameRequest_ ?? global::com.richardpianka.chess.network.StartGameRequest.DefaultInstance; }
    }
    
    public const int StartGameResponseFieldNumber = 25;
    private bool hasStartGameResponse;
    private global::com.richardpianka.chess.network.StartGameResponse startGameResponse_;
    public bool HasStartGameResponse {
      get { return hasStartGameResponse; }
    }
    public global::com.richardpianka.chess.network.StartGameResponse StartGameResponse {
      get { return startGameResponse_ ?? global::com.richardpianka.chess.network.StartGameResponse.DefaultInstance; }
    }
    
    public const int GameStartedEventFieldNumber = 26;
    private bool hasGameStartedEvent;
    private global::com.richardpianka.chess.network.GameStartedEvent gameStartedEvent_;
    public bool HasGameStartedEvent {
      get { return hasGameStartedEvent; }
    }
    public global::com.richardpianka.chess.network.GameStartedEvent GameStartedEvent {
      get { return gameStartedEvent_ ?? global::com.richardpianka.chess.network.GameStartedEvent.DefaultInstance; }
    }
    
    public const int MovePieceRequestFieldNumber = 27;
    private bool hasMovePieceRequest;
    private global::com.richardpianka.chess.network.MovePieceRequest movePieceRequest_;
    public bool HasMovePieceRequest {
      get { return hasMovePieceRequest; }
    }
    public global::com.richardpianka.chess.network.MovePieceRequest MovePieceRequest {
      get { return movePieceRequest_ ?? global::com.richardpianka.chess.network.MovePieceRequest.DefaultInstance; }
    }
    
    public const int MovePieceResponseFieldNumber = 28;
    private bool hasMovePieceResponse;
    private global::com.richardpianka.chess.network.MovePieceResponse movePieceResponse_;
    public bool HasMovePieceResponse {
      get { return hasMovePieceResponse; }
    }
    public global::com.richardpianka.chess.network.MovePieceResponse MovePieceResponse {
      get { return movePieceResponse_ ?? global::com.richardpianka.chess.network.MovePieceResponse.DefaultInstance; }
    }
    
    public const int MovePieceEventFieldNumber = 29;
    private bool hasMovePieceEvent;
    private global::com.richardpianka.chess.network.MovePieceEvent movePieceEvent_;
    public bool HasMovePieceEvent {
      get { return hasMovePieceEvent; }
    }
    public global::com.richardpianka.chess.network.MovePieceEvent MovePieceEvent {
      get { return movePieceEvent_ ?? global::com.richardpianka.chess.network.MovePieceEvent.DefaultInstance; }
    }
    
    public const int SpecialMovePieceRequestFieldNumber = 30;
    private bool hasSpecialMovePieceRequest;
    private global::com.richardpianka.chess.network.SpecialMovePieceRequest specialMovePieceRequest_;
    public bool HasSpecialMovePieceRequest {
      get { return hasSpecialMovePieceRequest; }
    }
    public global::com.richardpianka.chess.network.SpecialMovePieceRequest SpecialMovePieceRequest {
      get { return specialMovePieceRequest_ ?? global::com.richardpianka.chess.network.SpecialMovePieceRequest.DefaultInstance; }
    }
    
    public const int SpecialMovePieceResponseFieldNumber = 31;
    private bool hasSpecialMovePieceResponse;
    private global::com.richardpianka.chess.network.SpecialMovePieceResponse specialMovePieceResponse_;
    public bool HasSpecialMovePieceResponse {
      get { return hasSpecialMovePieceResponse; }
    }
    public global::com.richardpianka.chess.network.SpecialMovePieceResponse SpecialMovePieceResponse {
      get { return specialMovePieceResponse_ ?? global::com.richardpianka.chess.network.SpecialMovePieceResponse.DefaultInstance; }
    }
    
    public const int SpecialMovePieceEventFieldNumber = 32;
    private bool hasSpecialMovePieceEvent;
    private global::com.richardpianka.chess.network.SpecialMovePieceEvent specialMovePieceEvent_;
    public bool HasSpecialMovePieceEvent {
      get { return hasSpecialMovePieceEvent; }
    }
    public global::com.richardpianka.chess.network.SpecialMovePieceEvent SpecialMovePieceEvent {
      get { return specialMovePieceEvent_ ?? global::com.richardpianka.chess.network.SpecialMovePieceEvent.DefaultInstance; }
    }
    
    public const int GameStatusEventFieldNumber = 34;
    private bool hasGameStatusEvent;
    private global::com.richardpianka.chess.network.GameStatusEvent gameStatusEvent_;
    public bool HasGameStatusEvent {
      get { return hasGameStatusEvent; }
    }
    public global::com.richardpianka.chess.network.GameStatusEvent GameStatusEvent {
      get { return gameStatusEvent_ ?? global::com.richardpianka.chess.network.GameStatusEvent.DefaultInstance; }
    }
    
    public const int TimeLeftEventFieldNumber = 35;
    private bool hasTimeLeftEvent;
    private global::com.richardpianka.chess.network.TimeLeftEvent timeLeftEvent_;
    public bool HasTimeLeftEvent {
      get { return hasTimeLeftEvent; }
    }
    public global::com.richardpianka.chess.network.TimeLeftEvent TimeLeftEvent {
      get { return timeLeftEvent_ ?? global::com.richardpianka.chess.network.TimeLeftEvent.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasHandshakeRequest) {
          if (!HandshakeRequest.IsInitialized) return false;
        }
        if (HasHandshakeResponse) {
          if (!HandshakeResponse.IsInitialized) return false;
        }
        if (HasIdentifyRequest) {
          if (!IdentifyRequest.IsInitialized) return false;
        }
        if (HasIdentifyResponse) {
          if (!IdentifyResponse.IsInitialized) return false;
        }
        if (HasJoinChatResponse) {
          if (!JoinChatResponse.IsInitialized) return false;
        }
        if (HasRoomListResponse) {
          if (!RoomListResponse.IsInitialized) return false;
        }
        if (HasJoinRoomRequest) {
          if (!JoinRoomRequest.IsInitialized) return false;
        }
        if (HasJoinRoomResponse) {
          if (!JoinRoomResponse.IsInitialized) return false;
        }
        if (HasSpeakRequest) {
          if (!SpeakRequest.IsInitialized) return false;
        }
        if (HasOperatorRequest) {
          if (!OperatorRequest.IsInitialized) return false;
        }
        if (HasOperatorResponse) {
          if (!OperatorResponse.IsInitialized) return false;
        }
        if (HasChatRoomEvent) {
          if (!ChatRoomEvent.IsInitialized) return false;
        }
        if (HasChatUserEvent) {
          if (!ChatUserEvent.IsInitialized) return false;
        }
        if (HasChatSpeakEvent) {
          if (!ChatSpeakEvent.IsInitialized) return false;
        }
        if (HasGameListResponse) {
          if (!GameListResponse.IsInitialized) return false;
        }
        if (HasCreateGameRequest) {
          if (!CreateGameRequest.IsInitialized) return false;
        }
        if (HasCreateGameResponse) {
          if (!CreateGameResponse.IsInitialized) return false;
        }
        if (HasJoinGameRequest) {
          if (!JoinGameRequest.IsInitialized) return false;
        }
        if (HasJoinGameResponse) {
          if (!JoinGameResponse.IsInitialized) return false;
        }
        if (HasStartGameResponse) {
          if (!StartGameResponse.IsInitialized) return false;
        }
        if (HasGameStartedEvent) {
          if (!GameStartedEvent.IsInitialized) return false;
        }
        if (HasMovePieceRequest) {
          if (!MovePieceRequest.IsInitialized) return false;
        }
        if (HasMovePieceResponse) {
          if (!MovePieceResponse.IsInitialized) return false;
        }
        if (HasMovePieceEvent) {
          if (!MovePieceEvent.IsInitialized) return false;
        }
        if (HasSpecialMovePieceRequest) {
          if (!SpecialMovePieceRequest.IsInitialized) return false;
        }
        if (HasSpecialMovePieceResponse) {
          if (!SpecialMovePieceResponse.IsInitialized) return false;
        }
        if (HasSpecialMovePieceEvent) {
          if (!SpecialMovePieceEvent.IsInitialized) return false;
        }
        if (HasGameStatusEvent) {
          if (!GameStatusEvent.IsInitialized) return false;
        }
        if (HasTimeLeftEvent) {
          if (!TimeLeftEvent.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _envelopeFieldNames;
      if (hasHandshakeRequest) {
        output.WriteMessage(1, field_names[9], HandshakeRequest);
      }
      if (hasHandshakeResponse) {
        output.WriteMessage(2, field_names[10], HandshakeResponse);
      }
      if (hasIdentifyRequest) {
        output.WriteMessage(3, field_names[11], IdentifyRequest);
      }
      if (hasIdentifyResponse) {
        output.WriteMessage(4, field_names[12], IdentifyResponse);
      }
      if (hasJoinChatRequest) {
        output.WriteMessage(5, field_names[13], JoinChatRequest);
      }
      if (hasJoinChatResponse) {
        output.WriteMessage(6, field_names[14], JoinChatResponse);
      }
      if (hasRoomListRequest) {
        output.WriteMessage(7, field_names[25], RoomListRequest);
      }
      if (hasRoomListResponse) {
        output.WriteMessage(8, field_names[26], RoomListResponse);
      }
      if (hasJoinRoomRequest) {
        output.WriteMessage(9, field_names[17], JoinRoomRequest);
      }
      if (hasJoinRoomResponse) {
        output.WriteMessage(10, field_names[18], JoinRoomResponse);
      }
      if (hasSpeakRequest) {
        output.WriteMessage(11, field_names[27], SpeakRequest);
      }
      if (hasOperatorRequest) {
        output.WriteMessage(12, field_names[23], OperatorRequest);
      }
      if (hasOperatorResponse) {
        output.WriteMessage(13, field_names[24], OperatorResponse);
      }
      if (hasChatRoomEvent) {
        output.WriteMessage(14, field_names[0], ChatRoomEvent);
      }
      if (hasChatUserEvent) {
        output.WriteMessage(15, field_names[2], ChatUserEvent);
      }
      if (hasChatSpeakEvent) {
        output.WriteMessage(16, field_names[1], ChatSpeakEvent);
      }
      if (hasGameListRequest) {
        output.WriteMessage(17, field_names[5], GameListRequest);
      }
      if (hasGameListResponse) {
        output.WriteMessage(18, field_names[6], GameListResponse);
      }
      if (hasCreateGameRequest) {
        output.WriteMessage(19, field_names[3], CreateGameRequest);
      }
      if (hasCreateGameResponse) {
        output.WriteMessage(20, field_names[4], CreateGameResponse);
      }
      if (hasJoinGameRequest) {
        output.WriteMessage(21, field_names[15], JoinGameRequest);
      }
      if (hasJoinGameResponse) {
        output.WriteMessage(22, field_names[16], JoinGameResponse);
      }
      if (hasLeaveGameRequest) {
        output.WriteMessage(23, field_names[19], LeaveGameRequest);
      }
      if (hasStartGameRequest) {
        output.WriteMessage(24, field_names[31], StartGameRequest);
      }
      if (hasStartGameResponse) {
        output.WriteMessage(25, field_names[32], StartGameResponse);
      }
      if (hasGameStartedEvent) {
        output.WriteMessage(26, field_names[7], GameStartedEvent);
      }
      if (hasMovePieceRequest) {
        output.WriteMessage(27, field_names[21], MovePieceRequest);
      }
      if (hasMovePieceResponse) {
        output.WriteMessage(28, field_names[22], MovePieceResponse);
      }
      if (hasMovePieceEvent) {
        output.WriteMessage(29, field_names[20], MovePieceEvent);
      }
      if (hasSpecialMovePieceRequest) {
        output.WriteMessage(30, field_names[29], SpecialMovePieceRequest);
      }
      if (hasSpecialMovePieceResponse) {
        output.WriteMessage(31, field_names[30], SpecialMovePieceResponse);
      }
      if (hasSpecialMovePieceEvent) {
        output.WriteMessage(32, field_names[28], SpecialMovePieceEvent);
      }
      if (hasGameStatusEvent) {
        output.WriteMessage(34, field_names[8], GameStatusEvent);
      }
      if (hasTimeLeftEvent) {
        output.WriteMessage(35, field_names[33], TimeLeftEvent);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasHandshakeRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, HandshakeRequest);
        }
        if (hasHandshakeResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, HandshakeResponse);
        }
        if (hasIdentifyRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, IdentifyRequest);
        }
        if (hasIdentifyResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, IdentifyResponse);
        }
        if (hasJoinChatRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(5, JoinChatRequest);
        }
        if (hasJoinChatResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(6, JoinChatResponse);
        }
        if (hasRoomListRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(7, RoomListRequest);
        }
        if (hasRoomListResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(8, RoomListResponse);
        }
        if (hasJoinRoomRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(9, JoinRoomRequest);
        }
        if (hasJoinRoomResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(10, JoinRoomResponse);
        }
        if (hasSpeakRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(11, SpeakRequest);
        }
        if (hasOperatorRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(12, OperatorRequest);
        }
        if (hasOperatorResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(13, OperatorResponse);
        }
        if (hasChatRoomEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(14, ChatRoomEvent);
        }
        if (hasChatUserEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(15, ChatUserEvent);
        }
        if (hasChatSpeakEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(16, ChatSpeakEvent);
        }
        if (hasGameListRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(17, GameListRequest);
        }
        if (hasGameListResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(18, GameListResponse);
        }
        if (hasCreateGameRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(19, CreateGameRequest);
        }
        if (hasCreateGameResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(20, CreateGameResponse);
        }
        if (hasJoinGameRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(21, JoinGameRequest);
        }
        if (hasJoinGameResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(22, JoinGameResponse);
        }
        if (hasLeaveGameRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(23, LeaveGameRequest);
        }
        if (hasStartGameRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(24, StartGameRequest);
        }
        if (hasStartGameResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(25, StartGameResponse);
        }
        if (hasGameStartedEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(26, GameStartedEvent);
        }
        if (hasMovePieceRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(27, MovePieceRequest);
        }
        if (hasMovePieceResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(28, MovePieceResponse);
        }
        if (hasMovePieceEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(29, MovePieceEvent);
        }
        if (hasSpecialMovePieceRequest) {
          size += pb::CodedOutputStream.ComputeMessageSize(30, SpecialMovePieceRequest);
        }
        if (hasSpecialMovePieceResponse) {
          size += pb::CodedOutputStream.ComputeMessageSize(31, SpecialMovePieceResponse);
        }
        if (hasSpecialMovePieceEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(32, SpecialMovePieceEvent);
        }
        if (hasGameStatusEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(34, GameStatusEvent);
        }
        if (hasTimeLeftEvent) {
          size += pb::CodedOutputStream.ComputeMessageSize(35, TimeLeftEvent);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Envelope ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Envelope ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Envelope ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Envelope ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Envelope ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Envelope ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Envelope ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Envelope ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Envelope ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Envelope ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Envelope MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Envelope prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Envelope, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Envelope cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Envelope result;
      
      private Envelope PrepareBuilder() {
        if (resultIsReadOnly) {
          Envelope original = result;
          result = new Envelope();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Envelope MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.Envelope.Descriptor; }
      }
      
      public override Envelope DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.Envelope.DefaultInstance; }
      }
      
      public override Envelope BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Envelope) {
          return MergeFrom((Envelope) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Envelope other) {
        if (other == global::com.richardpianka.chess.network.Envelope.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasHandshakeRequest) {
          MergeHandshakeRequest(other.HandshakeRequest);
        }
        if (other.HasHandshakeResponse) {
          MergeHandshakeResponse(other.HandshakeResponse);
        }
        if (other.HasIdentifyRequest) {
          MergeIdentifyRequest(other.IdentifyRequest);
        }
        if (other.HasIdentifyResponse) {
          MergeIdentifyResponse(other.IdentifyResponse);
        }
        if (other.HasJoinChatRequest) {
          MergeJoinChatRequest(other.JoinChatRequest);
        }
        if (other.HasJoinChatResponse) {
          MergeJoinChatResponse(other.JoinChatResponse);
        }
        if (other.HasRoomListRequest) {
          MergeRoomListRequest(other.RoomListRequest);
        }
        if (other.HasRoomListResponse) {
          MergeRoomListResponse(other.RoomListResponse);
        }
        if (other.HasJoinRoomRequest) {
          MergeJoinRoomRequest(other.JoinRoomRequest);
        }
        if (other.HasJoinRoomResponse) {
          MergeJoinRoomResponse(other.JoinRoomResponse);
        }
        if (other.HasSpeakRequest) {
          MergeSpeakRequest(other.SpeakRequest);
        }
        if (other.HasOperatorRequest) {
          MergeOperatorRequest(other.OperatorRequest);
        }
        if (other.HasOperatorResponse) {
          MergeOperatorResponse(other.OperatorResponse);
        }
        if (other.HasChatRoomEvent) {
          MergeChatRoomEvent(other.ChatRoomEvent);
        }
        if (other.HasChatUserEvent) {
          MergeChatUserEvent(other.ChatUserEvent);
        }
        if (other.HasChatSpeakEvent) {
          MergeChatSpeakEvent(other.ChatSpeakEvent);
        }
        if (other.HasGameListRequest) {
          MergeGameListRequest(other.GameListRequest);
        }
        if (other.HasGameListResponse) {
          MergeGameListResponse(other.GameListResponse);
        }
        if (other.HasCreateGameRequest) {
          MergeCreateGameRequest(other.CreateGameRequest);
        }
        if (other.HasCreateGameResponse) {
          MergeCreateGameResponse(other.CreateGameResponse);
        }
        if (other.HasJoinGameRequest) {
          MergeJoinGameRequest(other.JoinGameRequest);
        }
        if (other.HasJoinGameResponse) {
          MergeJoinGameResponse(other.JoinGameResponse);
        }
        if (other.HasLeaveGameRequest) {
          MergeLeaveGameRequest(other.LeaveGameRequest);
        }
        if (other.HasStartGameRequest) {
          MergeStartGameRequest(other.StartGameRequest);
        }
        if (other.HasStartGameResponse) {
          MergeStartGameResponse(other.StartGameResponse);
        }
        if (other.HasGameStartedEvent) {
          MergeGameStartedEvent(other.GameStartedEvent);
        }
        if (other.HasMovePieceRequest) {
          MergeMovePieceRequest(other.MovePieceRequest);
        }
        if (other.HasMovePieceResponse) {
          MergeMovePieceResponse(other.MovePieceResponse);
        }
        if (other.HasMovePieceEvent) {
          MergeMovePieceEvent(other.MovePieceEvent);
        }
        if (other.HasSpecialMovePieceRequest) {
          MergeSpecialMovePieceRequest(other.SpecialMovePieceRequest);
        }
        if (other.HasSpecialMovePieceResponse) {
          MergeSpecialMovePieceResponse(other.SpecialMovePieceResponse);
        }
        if (other.HasSpecialMovePieceEvent) {
          MergeSpecialMovePieceEvent(other.SpecialMovePieceEvent);
        }
        if (other.HasGameStatusEvent) {
          MergeGameStatusEvent(other.GameStatusEvent);
        }
        if (other.HasTimeLeftEvent) {
          MergeTimeLeftEvent(other.TimeLeftEvent);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_envelopeFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _envelopeFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.HandshakeRequest.Builder subBuilder = global::com.richardpianka.chess.network.HandshakeRequest.CreateBuilder();
              if (result.hasHandshakeRequest) {
                subBuilder.MergeFrom(HandshakeRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              HandshakeRequest = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::com.richardpianka.chess.network.HandshakeResponse.Builder subBuilder = global::com.richardpianka.chess.network.HandshakeResponse.CreateBuilder();
              if (result.hasHandshakeResponse) {
                subBuilder.MergeFrom(HandshakeResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              HandshakeResponse = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::com.richardpianka.chess.network.IdentifyRequest.Builder subBuilder = global::com.richardpianka.chess.network.IdentifyRequest.CreateBuilder();
              if (result.hasIdentifyRequest) {
                subBuilder.MergeFrom(IdentifyRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              IdentifyRequest = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::com.richardpianka.chess.network.IdentifyResponse.Builder subBuilder = global::com.richardpianka.chess.network.IdentifyResponse.CreateBuilder();
              if (result.hasIdentifyResponse) {
                subBuilder.MergeFrom(IdentifyResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              IdentifyResponse = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              global::com.richardpianka.chess.network.JoinChatRequest.Builder subBuilder = global::com.richardpianka.chess.network.JoinChatRequest.CreateBuilder();
              if (result.hasJoinChatRequest) {
                subBuilder.MergeFrom(JoinChatRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JoinChatRequest = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              global::com.richardpianka.chess.network.JoinChatResponse.Builder subBuilder = global::com.richardpianka.chess.network.JoinChatResponse.CreateBuilder();
              if (result.hasJoinChatResponse) {
                subBuilder.MergeFrom(JoinChatResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JoinChatResponse = subBuilder.BuildPartial();
              break;
            }
            case 58: {
              global::com.richardpianka.chess.network.RoomListRequest.Builder subBuilder = global::com.richardpianka.chess.network.RoomListRequest.CreateBuilder();
              if (result.hasRoomListRequest) {
                subBuilder.MergeFrom(RoomListRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              RoomListRequest = subBuilder.BuildPartial();
              break;
            }
            case 66: {
              global::com.richardpianka.chess.network.RoomListResponse.Builder subBuilder = global::com.richardpianka.chess.network.RoomListResponse.CreateBuilder();
              if (result.hasRoomListResponse) {
                subBuilder.MergeFrom(RoomListResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              RoomListResponse = subBuilder.BuildPartial();
              break;
            }
            case 74: {
              global::com.richardpianka.chess.network.JoinRoomRequest.Builder subBuilder = global::com.richardpianka.chess.network.JoinRoomRequest.CreateBuilder();
              if (result.hasJoinRoomRequest) {
                subBuilder.MergeFrom(JoinRoomRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JoinRoomRequest = subBuilder.BuildPartial();
              break;
            }
            case 82: {
              global::com.richardpianka.chess.network.JoinRoomResponse.Builder subBuilder = global::com.richardpianka.chess.network.JoinRoomResponse.CreateBuilder();
              if (result.hasJoinRoomResponse) {
                subBuilder.MergeFrom(JoinRoomResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JoinRoomResponse = subBuilder.BuildPartial();
              break;
            }
            case 90: {
              global::com.richardpianka.chess.network.SpeakRequest.Builder subBuilder = global::com.richardpianka.chess.network.SpeakRequest.CreateBuilder();
              if (result.hasSpeakRequest) {
                subBuilder.MergeFrom(SpeakRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              SpeakRequest = subBuilder.BuildPartial();
              break;
            }
            case 98: {
              global::com.richardpianka.chess.network.OperatorRequest.Builder subBuilder = global::com.richardpianka.chess.network.OperatorRequest.CreateBuilder();
              if (result.hasOperatorRequest) {
                subBuilder.MergeFrom(OperatorRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              OperatorRequest = subBuilder.BuildPartial();
              break;
            }
            case 106: {
              global::com.richardpianka.chess.network.OperatorResponse.Builder subBuilder = global::com.richardpianka.chess.network.OperatorResponse.CreateBuilder();
              if (result.hasOperatorResponse) {
                subBuilder.MergeFrom(OperatorResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              OperatorResponse = subBuilder.BuildPartial();
              break;
            }
            case 114: {
              global::com.richardpianka.chess.network.ChatRoomEvent.Builder subBuilder = global::com.richardpianka.chess.network.ChatRoomEvent.CreateBuilder();
              if (result.hasChatRoomEvent) {
                subBuilder.MergeFrom(ChatRoomEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ChatRoomEvent = subBuilder.BuildPartial();
              break;
            }
            case 122: {
              global::com.richardpianka.chess.network.ChatUserEvent.Builder subBuilder = global::com.richardpianka.chess.network.ChatUserEvent.CreateBuilder();
              if (result.hasChatUserEvent) {
                subBuilder.MergeFrom(ChatUserEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ChatUserEvent = subBuilder.BuildPartial();
              break;
            }
            case 130: {
              global::com.richardpianka.chess.network.ChatSpeakEvent.Builder subBuilder = global::com.richardpianka.chess.network.ChatSpeakEvent.CreateBuilder();
              if (result.hasChatSpeakEvent) {
                subBuilder.MergeFrom(ChatSpeakEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ChatSpeakEvent = subBuilder.BuildPartial();
              break;
            }
            case 138: {
              global::com.richardpianka.chess.network.GameListRequest.Builder subBuilder = global::com.richardpianka.chess.network.GameListRequest.CreateBuilder();
              if (result.hasGameListRequest) {
                subBuilder.MergeFrom(GameListRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              GameListRequest = subBuilder.BuildPartial();
              break;
            }
            case 146: {
              global::com.richardpianka.chess.network.GameListResponse.Builder subBuilder = global::com.richardpianka.chess.network.GameListResponse.CreateBuilder();
              if (result.hasGameListResponse) {
                subBuilder.MergeFrom(GameListResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              GameListResponse = subBuilder.BuildPartial();
              break;
            }
            case 154: {
              global::com.richardpianka.chess.network.CreateGameRequest.Builder subBuilder = global::com.richardpianka.chess.network.CreateGameRequest.CreateBuilder();
              if (result.hasCreateGameRequest) {
                subBuilder.MergeFrom(CreateGameRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              CreateGameRequest = subBuilder.BuildPartial();
              break;
            }
            case 162: {
              global::com.richardpianka.chess.network.CreateGameResponse.Builder subBuilder = global::com.richardpianka.chess.network.CreateGameResponse.CreateBuilder();
              if (result.hasCreateGameResponse) {
                subBuilder.MergeFrom(CreateGameResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              CreateGameResponse = subBuilder.BuildPartial();
              break;
            }
            case 170: {
              global::com.richardpianka.chess.network.JoinGameRequest.Builder subBuilder = global::com.richardpianka.chess.network.JoinGameRequest.CreateBuilder();
              if (result.hasJoinGameRequest) {
                subBuilder.MergeFrom(JoinGameRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JoinGameRequest = subBuilder.BuildPartial();
              break;
            }
            case 178: {
              global::com.richardpianka.chess.network.JoinGameResponse.Builder subBuilder = global::com.richardpianka.chess.network.JoinGameResponse.CreateBuilder();
              if (result.hasJoinGameResponse) {
                subBuilder.MergeFrom(JoinGameResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JoinGameResponse = subBuilder.BuildPartial();
              break;
            }
            case 186: {
              global::com.richardpianka.chess.network.LeaveGameRequest.Builder subBuilder = global::com.richardpianka.chess.network.LeaveGameRequest.CreateBuilder();
              if (result.hasLeaveGameRequest) {
                subBuilder.MergeFrom(LeaveGameRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              LeaveGameRequest = subBuilder.BuildPartial();
              break;
            }
            case 194: {
              global::com.richardpianka.chess.network.StartGameRequest.Builder subBuilder = global::com.richardpianka.chess.network.StartGameRequest.CreateBuilder();
              if (result.hasStartGameRequest) {
                subBuilder.MergeFrom(StartGameRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              StartGameRequest = subBuilder.BuildPartial();
              break;
            }
            case 202: {
              global::com.richardpianka.chess.network.StartGameResponse.Builder subBuilder = global::com.richardpianka.chess.network.StartGameResponse.CreateBuilder();
              if (result.hasStartGameResponse) {
                subBuilder.MergeFrom(StartGameResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              StartGameResponse = subBuilder.BuildPartial();
              break;
            }
            case 210: {
              global::com.richardpianka.chess.network.GameStartedEvent.Builder subBuilder = global::com.richardpianka.chess.network.GameStartedEvent.CreateBuilder();
              if (result.hasGameStartedEvent) {
                subBuilder.MergeFrom(GameStartedEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              GameStartedEvent = subBuilder.BuildPartial();
              break;
            }
            case 218: {
              global::com.richardpianka.chess.network.MovePieceRequest.Builder subBuilder = global::com.richardpianka.chess.network.MovePieceRequest.CreateBuilder();
              if (result.hasMovePieceRequest) {
                subBuilder.MergeFrom(MovePieceRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              MovePieceRequest = subBuilder.BuildPartial();
              break;
            }
            case 226: {
              global::com.richardpianka.chess.network.MovePieceResponse.Builder subBuilder = global::com.richardpianka.chess.network.MovePieceResponse.CreateBuilder();
              if (result.hasMovePieceResponse) {
                subBuilder.MergeFrom(MovePieceResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              MovePieceResponse = subBuilder.BuildPartial();
              break;
            }
            case 234: {
              global::com.richardpianka.chess.network.MovePieceEvent.Builder subBuilder = global::com.richardpianka.chess.network.MovePieceEvent.CreateBuilder();
              if (result.hasMovePieceEvent) {
                subBuilder.MergeFrom(MovePieceEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              MovePieceEvent = subBuilder.BuildPartial();
              break;
            }
            case 242: {
              global::com.richardpianka.chess.network.SpecialMovePieceRequest.Builder subBuilder = global::com.richardpianka.chess.network.SpecialMovePieceRequest.CreateBuilder();
              if (result.hasSpecialMovePieceRequest) {
                subBuilder.MergeFrom(SpecialMovePieceRequest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              SpecialMovePieceRequest = subBuilder.BuildPartial();
              break;
            }
            case 250: {
              global::com.richardpianka.chess.network.SpecialMovePieceResponse.Builder subBuilder = global::com.richardpianka.chess.network.SpecialMovePieceResponse.CreateBuilder();
              if (result.hasSpecialMovePieceResponse) {
                subBuilder.MergeFrom(SpecialMovePieceResponse);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              SpecialMovePieceResponse = subBuilder.BuildPartial();
              break;
            }
            case 258: {
              global::com.richardpianka.chess.network.SpecialMovePieceEvent.Builder subBuilder = global::com.richardpianka.chess.network.SpecialMovePieceEvent.CreateBuilder();
              if (result.hasSpecialMovePieceEvent) {
                subBuilder.MergeFrom(SpecialMovePieceEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              SpecialMovePieceEvent = subBuilder.BuildPartial();
              break;
            }
            case 274: {
              global::com.richardpianka.chess.network.GameStatusEvent.Builder subBuilder = global::com.richardpianka.chess.network.GameStatusEvent.CreateBuilder();
              if (result.hasGameStatusEvent) {
                subBuilder.MergeFrom(GameStatusEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              GameStatusEvent = subBuilder.BuildPartial();
              break;
            }
            case 282: {
              global::com.richardpianka.chess.network.TimeLeftEvent.Builder subBuilder = global::com.richardpianka.chess.network.TimeLeftEvent.CreateBuilder();
              if (result.hasTimeLeftEvent) {
                subBuilder.MergeFrom(TimeLeftEvent);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              TimeLeftEvent = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasHandshakeRequest {
       get { return result.hasHandshakeRequest; }
      }
      public global::com.richardpianka.chess.network.HandshakeRequest HandshakeRequest {
        get { return result.HandshakeRequest; }
        set { SetHandshakeRequest(value); }
      }
      public Builder SetHandshakeRequest(global::com.richardpianka.chess.network.HandshakeRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHandshakeRequest = true;
        result.handshakeRequest_ = value;
        return this;
      }
      public Builder SetHandshakeRequest(global::com.richardpianka.chess.network.HandshakeRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHandshakeRequest = true;
        result.handshakeRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHandshakeRequest(global::com.richardpianka.chess.network.HandshakeRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasHandshakeRequest &&
            result.handshakeRequest_ != global::com.richardpianka.chess.network.HandshakeRequest.DefaultInstance) {
            result.handshakeRequest_ = global::com.richardpianka.chess.network.HandshakeRequest.CreateBuilder(result.handshakeRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.handshakeRequest_ = value;
        }
        result.hasHandshakeRequest = true;
        return this;
      }
      public Builder ClearHandshakeRequest() {
        PrepareBuilder();
        result.hasHandshakeRequest = false;
        result.handshakeRequest_ = null;
        return this;
      }
      
      public bool HasHandshakeResponse {
       get { return result.hasHandshakeResponse; }
      }
      public global::com.richardpianka.chess.network.HandshakeResponse HandshakeResponse {
        get { return result.HandshakeResponse; }
        set { SetHandshakeResponse(value); }
      }
      public Builder SetHandshakeResponse(global::com.richardpianka.chess.network.HandshakeResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHandshakeResponse = true;
        result.handshakeResponse_ = value;
        return this;
      }
      public Builder SetHandshakeResponse(global::com.richardpianka.chess.network.HandshakeResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHandshakeResponse = true;
        result.handshakeResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHandshakeResponse(global::com.richardpianka.chess.network.HandshakeResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasHandshakeResponse &&
            result.handshakeResponse_ != global::com.richardpianka.chess.network.HandshakeResponse.DefaultInstance) {
            result.handshakeResponse_ = global::com.richardpianka.chess.network.HandshakeResponse.CreateBuilder(result.handshakeResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.handshakeResponse_ = value;
        }
        result.hasHandshakeResponse = true;
        return this;
      }
      public Builder ClearHandshakeResponse() {
        PrepareBuilder();
        result.hasHandshakeResponse = false;
        result.handshakeResponse_ = null;
        return this;
      }
      
      public bool HasIdentifyRequest {
       get { return result.hasIdentifyRequest; }
      }
      public global::com.richardpianka.chess.network.IdentifyRequest IdentifyRequest {
        get { return result.IdentifyRequest; }
        set { SetIdentifyRequest(value); }
      }
      public Builder SetIdentifyRequest(global::com.richardpianka.chess.network.IdentifyRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasIdentifyRequest = true;
        result.identifyRequest_ = value;
        return this;
      }
      public Builder SetIdentifyRequest(global::com.richardpianka.chess.network.IdentifyRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasIdentifyRequest = true;
        result.identifyRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeIdentifyRequest(global::com.richardpianka.chess.network.IdentifyRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasIdentifyRequest &&
            result.identifyRequest_ != global::com.richardpianka.chess.network.IdentifyRequest.DefaultInstance) {
            result.identifyRequest_ = global::com.richardpianka.chess.network.IdentifyRequest.CreateBuilder(result.identifyRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.identifyRequest_ = value;
        }
        result.hasIdentifyRequest = true;
        return this;
      }
      public Builder ClearIdentifyRequest() {
        PrepareBuilder();
        result.hasIdentifyRequest = false;
        result.identifyRequest_ = null;
        return this;
      }
      
      public bool HasIdentifyResponse {
       get { return result.hasIdentifyResponse; }
      }
      public global::com.richardpianka.chess.network.IdentifyResponse IdentifyResponse {
        get { return result.IdentifyResponse; }
        set { SetIdentifyResponse(value); }
      }
      public Builder SetIdentifyResponse(global::com.richardpianka.chess.network.IdentifyResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasIdentifyResponse = true;
        result.identifyResponse_ = value;
        return this;
      }
      public Builder SetIdentifyResponse(global::com.richardpianka.chess.network.IdentifyResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasIdentifyResponse = true;
        result.identifyResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeIdentifyResponse(global::com.richardpianka.chess.network.IdentifyResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasIdentifyResponse &&
            result.identifyResponse_ != global::com.richardpianka.chess.network.IdentifyResponse.DefaultInstance) {
            result.identifyResponse_ = global::com.richardpianka.chess.network.IdentifyResponse.CreateBuilder(result.identifyResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.identifyResponse_ = value;
        }
        result.hasIdentifyResponse = true;
        return this;
      }
      public Builder ClearIdentifyResponse() {
        PrepareBuilder();
        result.hasIdentifyResponse = false;
        result.identifyResponse_ = null;
        return this;
      }
      
      public bool HasJoinChatRequest {
       get { return result.hasJoinChatRequest; }
      }
      public global::com.richardpianka.chess.network.JoinChatRequest JoinChatRequest {
        get { return result.JoinChatRequest; }
        set { SetJoinChatRequest(value); }
      }
      public Builder SetJoinChatRequest(global::com.richardpianka.chess.network.JoinChatRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoinChatRequest = true;
        result.joinChatRequest_ = value;
        return this;
      }
      public Builder SetJoinChatRequest(global::com.richardpianka.chess.network.JoinChatRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoinChatRequest = true;
        result.joinChatRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoinChatRequest(global::com.richardpianka.chess.network.JoinChatRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoinChatRequest &&
            result.joinChatRequest_ != global::com.richardpianka.chess.network.JoinChatRequest.DefaultInstance) {
            result.joinChatRequest_ = global::com.richardpianka.chess.network.JoinChatRequest.CreateBuilder(result.joinChatRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.joinChatRequest_ = value;
        }
        result.hasJoinChatRequest = true;
        return this;
      }
      public Builder ClearJoinChatRequest() {
        PrepareBuilder();
        result.hasJoinChatRequest = false;
        result.joinChatRequest_ = null;
        return this;
      }
      
      public bool HasJoinChatResponse {
       get { return result.hasJoinChatResponse; }
      }
      public global::com.richardpianka.chess.network.JoinChatResponse JoinChatResponse {
        get { return result.JoinChatResponse; }
        set { SetJoinChatResponse(value); }
      }
      public Builder SetJoinChatResponse(global::com.richardpianka.chess.network.JoinChatResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoinChatResponse = true;
        result.joinChatResponse_ = value;
        return this;
      }
      public Builder SetJoinChatResponse(global::com.richardpianka.chess.network.JoinChatResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoinChatResponse = true;
        result.joinChatResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoinChatResponse(global::com.richardpianka.chess.network.JoinChatResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoinChatResponse &&
            result.joinChatResponse_ != global::com.richardpianka.chess.network.JoinChatResponse.DefaultInstance) {
            result.joinChatResponse_ = global::com.richardpianka.chess.network.JoinChatResponse.CreateBuilder(result.joinChatResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.joinChatResponse_ = value;
        }
        result.hasJoinChatResponse = true;
        return this;
      }
      public Builder ClearJoinChatResponse() {
        PrepareBuilder();
        result.hasJoinChatResponse = false;
        result.joinChatResponse_ = null;
        return this;
      }
      
      public bool HasRoomListRequest {
       get { return result.hasRoomListRequest; }
      }
      public global::com.richardpianka.chess.network.RoomListRequest RoomListRequest {
        get { return result.RoomListRequest; }
        set { SetRoomListRequest(value); }
      }
      public Builder SetRoomListRequest(global::com.richardpianka.chess.network.RoomListRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRoomListRequest = true;
        result.roomListRequest_ = value;
        return this;
      }
      public Builder SetRoomListRequest(global::com.richardpianka.chess.network.RoomListRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRoomListRequest = true;
        result.roomListRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRoomListRequest(global::com.richardpianka.chess.network.RoomListRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRoomListRequest &&
            result.roomListRequest_ != global::com.richardpianka.chess.network.RoomListRequest.DefaultInstance) {
            result.roomListRequest_ = global::com.richardpianka.chess.network.RoomListRequest.CreateBuilder(result.roomListRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.roomListRequest_ = value;
        }
        result.hasRoomListRequest = true;
        return this;
      }
      public Builder ClearRoomListRequest() {
        PrepareBuilder();
        result.hasRoomListRequest = false;
        result.roomListRequest_ = null;
        return this;
      }
      
      public bool HasRoomListResponse {
       get { return result.hasRoomListResponse; }
      }
      public global::com.richardpianka.chess.network.RoomListResponse RoomListResponse {
        get { return result.RoomListResponse; }
        set { SetRoomListResponse(value); }
      }
      public Builder SetRoomListResponse(global::com.richardpianka.chess.network.RoomListResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRoomListResponse = true;
        result.roomListResponse_ = value;
        return this;
      }
      public Builder SetRoomListResponse(global::com.richardpianka.chess.network.RoomListResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRoomListResponse = true;
        result.roomListResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRoomListResponse(global::com.richardpianka.chess.network.RoomListResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRoomListResponse &&
            result.roomListResponse_ != global::com.richardpianka.chess.network.RoomListResponse.DefaultInstance) {
            result.roomListResponse_ = global::com.richardpianka.chess.network.RoomListResponse.CreateBuilder(result.roomListResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.roomListResponse_ = value;
        }
        result.hasRoomListResponse = true;
        return this;
      }
      public Builder ClearRoomListResponse() {
        PrepareBuilder();
        result.hasRoomListResponse = false;
        result.roomListResponse_ = null;
        return this;
      }
      
      public bool HasJoinRoomRequest {
       get { return result.hasJoinRoomRequest; }
      }
      public global::com.richardpianka.chess.network.JoinRoomRequest JoinRoomRequest {
        get { return result.JoinRoomRequest; }
        set { SetJoinRoomRequest(value); }
      }
      public Builder SetJoinRoomRequest(global::com.richardpianka.chess.network.JoinRoomRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoinRoomRequest = true;
        result.joinRoomRequest_ = value;
        return this;
      }
      public Builder SetJoinRoomRequest(global::com.richardpianka.chess.network.JoinRoomRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoinRoomRequest = true;
        result.joinRoomRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoinRoomRequest(global::com.richardpianka.chess.network.JoinRoomRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoinRoomRequest &&
            result.joinRoomRequest_ != global::com.richardpianka.chess.network.JoinRoomRequest.DefaultInstance) {
            result.joinRoomRequest_ = global::com.richardpianka.chess.network.JoinRoomRequest.CreateBuilder(result.joinRoomRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.joinRoomRequest_ = value;
        }
        result.hasJoinRoomRequest = true;
        return this;
      }
      public Builder ClearJoinRoomRequest() {
        PrepareBuilder();
        result.hasJoinRoomRequest = false;
        result.joinRoomRequest_ = null;
        return this;
      }
      
      public bool HasJoinRoomResponse {
       get { return result.hasJoinRoomResponse; }
      }
      public global::com.richardpianka.chess.network.JoinRoomResponse JoinRoomResponse {
        get { return result.JoinRoomResponse; }
        set { SetJoinRoomResponse(value); }
      }
      public Builder SetJoinRoomResponse(global::com.richardpianka.chess.network.JoinRoomResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoinRoomResponse = true;
        result.joinRoomResponse_ = value;
        return this;
      }
      public Builder SetJoinRoomResponse(global::com.richardpianka.chess.network.JoinRoomResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoinRoomResponse = true;
        result.joinRoomResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoinRoomResponse(global::com.richardpianka.chess.network.JoinRoomResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoinRoomResponse &&
            result.joinRoomResponse_ != global::com.richardpianka.chess.network.JoinRoomResponse.DefaultInstance) {
            result.joinRoomResponse_ = global::com.richardpianka.chess.network.JoinRoomResponse.CreateBuilder(result.joinRoomResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.joinRoomResponse_ = value;
        }
        result.hasJoinRoomResponse = true;
        return this;
      }
      public Builder ClearJoinRoomResponse() {
        PrepareBuilder();
        result.hasJoinRoomResponse = false;
        result.joinRoomResponse_ = null;
        return this;
      }
      
      public bool HasSpeakRequest {
       get { return result.hasSpeakRequest; }
      }
      public global::com.richardpianka.chess.network.SpeakRequest SpeakRequest {
        get { return result.SpeakRequest; }
        set { SetSpeakRequest(value); }
      }
      public Builder SetSpeakRequest(global::com.richardpianka.chess.network.SpeakRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSpeakRequest = true;
        result.speakRequest_ = value;
        return this;
      }
      public Builder SetSpeakRequest(global::com.richardpianka.chess.network.SpeakRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasSpeakRequest = true;
        result.speakRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeSpeakRequest(global::com.richardpianka.chess.network.SpeakRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasSpeakRequest &&
            result.speakRequest_ != global::com.richardpianka.chess.network.SpeakRequest.DefaultInstance) {
            result.speakRequest_ = global::com.richardpianka.chess.network.SpeakRequest.CreateBuilder(result.speakRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.speakRequest_ = value;
        }
        result.hasSpeakRequest = true;
        return this;
      }
      public Builder ClearSpeakRequest() {
        PrepareBuilder();
        result.hasSpeakRequest = false;
        result.speakRequest_ = null;
        return this;
      }
      
      public bool HasOperatorRequest {
       get { return result.hasOperatorRequest; }
      }
      public global::com.richardpianka.chess.network.OperatorRequest OperatorRequest {
        get { return result.OperatorRequest; }
        set { SetOperatorRequest(value); }
      }
      public Builder SetOperatorRequest(global::com.richardpianka.chess.network.OperatorRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOperatorRequest = true;
        result.operatorRequest_ = value;
        return this;
      }
      public Builder SetOperatorRequest(global::com.richardpianka.chess.network.OperatorRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasOperatorRequest = true;
        result.operatorRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeOperatorRequest(global::com.richardpianka.chess.network.OperatorRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasOperatorRequest &&
            result.operatorRequest_ != global::com.richardpianka.chess.network.OperatorRequest.DefaultInstance) {
            result.operatorRequest_ = global::com.richardpianka.chess.network.OperatorRequest.CreateBuilder(result.operatorRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.operatorRequest_ = value;
        }
        result.hasOperatorRequest = true;
        return this;
      }
      public Builder ClearOperatorRequest() {
        PrepareBuilder();
        result.hasOperatorRequest = false;
        result.operatorRequest_ = null;
        return this;
      }
      
      public bool HasOperatorResponse {
       get { return result.hasOperatorResponse; }
      }
      public global::com.richardpianka.chess.network.OperatorResponse OperatorResponse {
        get { return result.OperatorResponse; }
        set { SetOperatorResponse(value); }
      }
      public Builder SetOperatorResponse(global::com.richardpianka.chess.network.OperatorResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOperatorResponse = true;
        result.operatorResponse_ = value;
        return this;
      }
      public Builder SetOperatorResponse(global::com.richardpianka.chess.network.OperatorResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasOperatorResponse = true;
        result.operatorResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeOperatorResponse(global::com.richardpianka.chess.network.OperatorResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasOperatorResponse &&
            result.operatorResponse_ != global::com.richardpianka.chess.network.OperatorResponse.DefaultInstance) {
            result.operatorResponse_ = global::com.richardpianka.chess.network.OperatorResponse.CreateBuilder(result.operatorResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.operatorResponse_ = value;
        }
        result.hasOperatorResponse = true;
        return this;
      }
      public Builder ClearOperatorResponse() {
        PrepareBuilder();
        result.hasOperatorResponse = false;
        result.operatorResponse_ = null;
        return this;
      }
      
      public bool HasChatRoomEvent {
       get { return result.hasChatRoomEvent; }
      }
      public global::com.richardpianka.chess.network.ChatRoomEvent ChatRoomEvent {
        get { return result.ChatRoomEvent; }
        set { SetChatRoomEvent(value); }
      }
      public Builder SetChatRoomEvent(global::com.richardpianka.chess.network.ChatRoomEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChatRoomEvent = true;
        result.chatRoomEvent_ = value;
        return this;
      }
      public Builder SetChatRoomEvent(global::com.richardpianka.chess.network.ChatRoomEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasChatRoomEvent = true;
        result.chatRoomEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeChatRoomEvent(global::com.richardpianka.chess.network.ChatRoomEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasChatRoomEvent &&
            result.chatRoomEvent_ != global::com.richardpianka.chess.network.ChatRoomEvent.DefaultInstance) {
            result.chatRoomEvent_ = global::com.richardpianka.chess.network.ChatRoomEvent.CreateBuilder(result.chatRoomEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.chatRoomEvent_ = value;
        }
        result.hasChatRoomEvent = true;
        return this;
      }
      public Builder ClearChatRoomEvent() {
        PrepareBuilder();
        result.hasChatRoomEvent = false;
        result.chatRoomEvent_ = null;
        return this;
      }
      
      public bool HasChatUserEvent {
       get { return result.hasChatUserEvent; }
      }
      public global::com.richardpianka.chess.network.ChatUserEvent ChatUserEvent {
        get { return result.ChatUserEvent; }
        set { SetChatUserEvent(value); }
      }
      public Builder SetChatUserEvent(global::com.richardpianka.chess.network.ChatUserEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChatUserEvent = true;
        result.chatUserEvent_ = value;
        return this;
      }
      public Builder SetChatUserEvent(global::com.richardpianka.chess.network.ChatUserEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasChatUserEvent = true;
        result.chatUserEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeChatUserEvent(global::com.richardpianka.chess.network.ChatUserEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasChatUserEvent &&
            result.chatUserEvent_ != global::com.richardpianka.chess.network.ChatUserEvent.DefaultInstance) {
            result.chatUserEvent_ = global::com.richardpianka.chess.network.ChatUserEvent.CreateBuilder(result.chatUserEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.chatUserEvent_ = value;
        }
        result.hasChatUserEvent = true;
        return this;
      }
      public Builder ClearChatUserEvent() {
        PrepareBuilder();
        result.hasChatUserEvent = false;
        result.chatUserEvent_ = null;
        return this;
      }
      
      public bool HasChatSpeakEvent {
       get { return result.hasChatSpeakEvent; }
      }
      public global::com.richardpianka.chess.network.ChatSpeakEvent ChatSpeakEvent {
        get { return result.ChatSpeakEvent; }
        set { SetChatSpeakEvent(value); }
      }
      public Builder SetChatSpeakEvent(global::com.richardpianka.chess.network.ChatSpeakEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChatSpeakEvent = true;
        result.chatSpeakEvent_ = value;
        return this;
      }
      public Builder SetChatSpeakEvent(global::com.richardpianka.chess.network.ChatSpeakEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasChatSpeakEvent = true;
        result.chatSpeakEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeChatSpeakEvent(global::com.richardpianka.chess.network.ChatSpeakEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasChatSpeakEvent &&
            result.chatSpeakEvent_ != global::com.richardpianka.chess.network.ChatSpeakEvent.DefaultInstance) {
            result.chatSpeakEvent_ = global::com.richardpianka.chess.network.ChatSpeakEvent.CreateBuilder(result.chatSpeakEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.chatSpeakEvent_ = value;
        }
        result.hasChatSpeakEvent = true;
        return this;
      }
      public Builder ClearChatSpeakEvent() {
        PrepareBuilder();
        result.hasChatSpeakEvent = false;
        result.chatSpeakEvent_ = null;
        return this;
      }
      
      public bool HasGameListRequest {
       get { return result.hasGameListRequest; }
      }
      public global::com.richardpianka.chess.network.GameListRequest GameListRequest {
        get { return result.GameListRequest; }
        set { SetGameListRequest(value); }
      }
      public Builder SetGameListRequest(global::com.richardpianka.chess.network.GameListRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGameListRequest = true;
        result.gameListRequest_ = value;
        return this;
      }
      public Builder SetGameListRequest(global::com.richardpianka.chess.network.GameListRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGameListRequest = true;
        result.gameListRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGameListRequest(global::com.richardpianka.chess.network.GameListRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGameListRequest &&
            result.gameListRequest_ != global::com.richardpianka.chess.network.GameListRequest.DefaultInstance) {
            result.gameListRequest_ = global::com.richardpianka.chess.network.GameListRequest.CreateBuilder(result.gameListRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.gameListRequest_ = value;
        }
        result.hasGameListRequest = true;
        return this;
      }
      public Builder ClearGameListRequest() {
        PrepareBuilder();
        result.hasGameListRequest = false;
        result.gameListRequest_ = null;
        return this;
      }
      
      public bool HasGameListResponse {
       get { return result.hasGameListResponse; }
      }
      public global::com.richardpianka.chess.network.GameListResponse GameListResponse {
        get { return result.GameListResponse; }
        set { SetGameListResponse(value); }
      }
      public Builder SetGameListResponse(global::com.richardpianka.chess.network.GameListResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGameListResponse = true;
        result.gameListResponse_ = value;
        return this;
      }
      public Builder SetGameListResponse(global::com.richardpianka.chess.network.GameListResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGameListResponse = true;
        result.gameListResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGameListResponse(global::com.richardpianka.chess.network.GameListResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGameListResponse &&
            result.gameListResponse_ != global::com.richardpianka.chess.network.GameListResponse.DefaultInstance) {
            result.gameListResponse_ = global::com.richardpianka.chess.network.GameListResponse.CreateBuilder(result.gameListResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.gameListResponse_ = value;
        }
        result.hasGameListResponse = true;
        return this;
      }
      public Builder ClearGameListResponse() {
        PrepareBuilder();
        result.hasGameListResponse = false;
        result.gameListResponse_ = null;
        return this;
      }
      
      public bool HasCreateGameRequest {
       get { return result.hasCreateGameRequest; }
      }
      public global::com.richardpianka.chess.network.CreateGameRequest CreateGameRequest {
        get { return result.CreateGameRequest; }
        set { SetCreateGameRequest(value); }
      }
      public Builder SetCreateGameRequest(global::com.richardpianka.chess.network.CreateGameRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCreateGameRequest = true;
        result.createGameRequest_ = value;
        return this;
      }
      public Builder SetCreateGameRequest(global::com.richardpianka.chess.network.CreateGameRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCreateGameRequest = true;
        result.createGameRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCreateGameRequest(global::com.richardpianka.chess.network.CreateGameRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCreateGameRequest &&
            result.createGameRequest_ != global::com.richardpianka.chess.network.CreateGameRequest.DefaultInstance) {
            result.createGameRequest_ = global::com.richardpianka.chess.network.CreateGameRequest.CreateBuilder(result.createGameRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.createGameRequest_ = value;
        }
        result.hasCreateGameRequest = true;
        return this;
      }
      public Builder ClearCreateGameRequest() {
        PrepareBuilder();
        result.hasCreateGameRequest = false;
        result.createGameRequest_ = null;
        return this;
      }
      
      public bool HasCreateGameResponse {
       get { return result.hasCreateGameResponse; }
      }
      public global::com.richardpianka.chess.network.CreateGameResponse CreateGameResponse {
        get { return result.CreateGameResponse; }
        set { SetCreateGameResponse(value); }
      }
      public Builder SetCreateGameResponse(global::com.richardpianka.chess.network.CreateGameResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCreateGameResponse = true;
        result.createGameResponse_ = value;
        return this;
      }
      public Builder SetCreateGameResponse(global::com.richardpianka.chess.network.CreateGameResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCreateGameResponse = true;
        result.createGameResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCreateGameResponse(global::com.richardpianka.chess.network.CreateGameResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCreateGameResponse &&
            result.createGameResponse_ != global::com.richardpianka.chess.network.CreateGameResponse.DefaultInstance) {
            result.createGameResponse_ = global::com.richardpianka.chess.network.CreateGameResponse.CreateBuilder(result.createGameResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.createGameResponse_ = value;
        }
        result.hasCreateGameResponse = true;
        return this;
      }
      public Builder ClearCreateGameResponse() {
        PrepareBuilder();
        result.hasCreateGameResponse = false;
        result.createGameResponse_ = null;
        return this;
      }
      
      public bool HasJoinGameRequest {
       get { return result.hasJoinGameRequest; }
      }
      public global::com.richardpianka.chess.network.JoinGameRequest JoinGameRequest {
        get { return result.JoinGameRequest; }
        set { SetJoinGameRequest(value); }
      }
      public Builder SetJoinGameRequest(global::com.richardpianka.chess.network.JoinGameRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoinGameRequest = true;
        result.joinGameRequest_ = value;
        return this;
      }
      public Builder SetJoinGameRequest(global::com.richardpianka.chess.network.JoinGameRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoinGameRequest = true;
        result.joinGameRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoinGameRequest(global::com.richardpianka.chess.network.JoinGameRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoinGameRequest &&
            result.joinGameRequest_ != global::com.richardpianka.chess.network.JoinGameRequest.DefaultInstance) {
            result.joinGameRequest_ = global::com.richardpianka.chess.network.JoinGameRequest.CreateBuilder(result.joinGameRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.joinGameRequest_ = value;
        }
        result.hasJoinGameRequest = true;
        return this;
      }
      public Builder ClearJoinGameRequest() {
        PrepareBuilder();
        result.hasJoinGameRequest = false;
        result.joinGameRequest_ = null;
        return this;
      }
      
      public bool HasJoinGameResponse {
       get { return result.hasJoinGameResponse; }
      }
      public global::com.richardpianka.chess.network.JoinGameResponse JoinGameResponse {
        get { return result.JoinGameResponse; }
        set { SetJoinGameResponse(value); }
      }
      public Builder SetJoinGameResponse(global::com.richardpianka.chess.network.JoinGameResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoinGameResponse = true;
        result.joinGameResponse_ = value;
        return this;
      }
      public Builder SetJoinGameResponse(global::com.richardpianka.chess.network.JoinGameResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoinGameResponse = true;
        result.joinGameResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoinGameResponse(global::com.richardpianka.chess.network.JoinGameResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoinGameResponse &&
            result.joinGameResponse_ != global::com.richardpianka.chess.network.JoinGameResponse.DefaultInstance) {
            result.joinGameResponse_ = global::com.richardpianka.chess.network.JoinGameResponse.CreateBuilder(result.joinGameResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.joinGameResponse_ = value;
        }
        result.hasJoinGameResponse = true;
        return this;
      }
      public Builder ClearJoinGameResponse() {
        PrepareBuilder();
        result.hasJoinGameResponse = false;
        result.joinGameResponse_ = null;
        return this;
      }
      
      public bool HasLeaveGameRequest {
       get { return result.hasLeaveGameRequest; }
      }
      public global::com.richardpianka.chess.network.LeaveGameRequest LeaveGameRequest {
        get { return result.LeaveGameRequest; }
        set { SetLeaveGameRequest(value); }
      }
      public Builder SetLeaveGameRequest(global::com.richardpianka.chess.network.LeaveGameRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLeaveGameRequest = true;
        result.leaveGameRequest_ = value;
        return this;
      }
      public Builder SetLeaveGameRequest(global::com.richardpianka.chess.network.LeaveGameRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLeaveGameRequest = true;
        result.leaveGameRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLeaveGameRequest(global::com.richardpianka.chess.network.LeaveGameRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLeaveGameRequest &&
            result.leaveGameRequest_ != global::com.richardpianka.chess.network.LeaveGameRequest.DefaultInstance) {
            result.leaveGameRequest_ = global::com.richardpianka.chess.network.LeaveGameRequest.CreateBuilder(result.leaveGameRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.leaveGameRequest_ = value;
        }
        result.hasLeaveGameRequest = true;
        return this;
      }
      public Builder ClearLeaveGameRequest() {
        PrepareBuilder();
        result.hasLeaveGameRequest = false;
        result.leaveGameRequest_ = null;
        return this;
      }
      
      public bool HasStartGameRequest {
       get { return result.hasStartGameRequest; }
      }
      public global::com.richardpianka.chess.network.StartGameRequest StartGameRequest {
        get { return result.StartGameRequest; }
        set { SetStartGameRequest(value); }
      }
      public Builder SetStartGameRequest(global::com.richardpianka.chess.network.StartGameRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasStartGameRequest = true;
        result.startGameRequest_ = value;
        return this;
      }
      public Builder SetStartGameRequest(global::com.richardpianka.chess.network.StartGameRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasStartGameRequest = true;
        result.startGameRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeStartGameRequest(global::com.richardpianka.chess.network.StartGameRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasStartGameRequest &&
            result.startGameRequest_ != global::com.richardpianka.chess.network.StartGameRequest.DefaultInstance) {
            result.startGameRequest_ = global::com.richardpianka.chess.network.StartGameRequest.CreateBuilder(result.startGameRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.startGameRequest_ = value;
        }
        result.hasStartGameRequest = true;
        return this;
      }
      public Builder ClearStartGameRequest() {
        PrepareBuilder();
        result.hasStartGameRequest = false;
        result.startGameRequest_ = null;
        return this;
      }
      
      public bool HasStartGameResponse {
       get { return result.hasStartGameResponse; }
      }
      public global::com.richardpianka.chess.network.StartGameResponse StartGameResponse {
        get { return result.StartGameResponse; }
        set { SetStartGameResponse(value); }
      }
      public Builder SetStartGameResponse(global::com.richardpianka.chess.network.StartGameResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasStartGameResponse = true;
        result.startGameResponse_ = value;
        return this;
      }
      public Builder SetStartGameResponse(global::com.richardpianka.chess.network.StartGameResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasStartGameResponse = true;
        result.startGameResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeStartGameResponse(global::com.richardpianka.chess.network.StartGameResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasStartGameResponse &&
            result.startGameResponse_ != global::com.richardpianka.chess.network.StartGameResponse.DefaultInstance) {
            result.startGameResponse_ = global::com.richardpianka.chess.network.StartGameResponse.CreateBuilder(result.startGameResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.startGameResponse_ = value;
        }
        result.hasStartGameResponse = true;
        return this;
      }
      public Builder ClearStartGameResponse() {
        PrepareBuilder();
        result.hasStartGameResponse = false;
        result.startGameResponse_ = null;
        return this;
      }
      
      public bool HasGameStartedEvent {
       get { return result.hasGameStartedEvent; }
      }
      public global::com.richardpianka.chess.network.GameStartedEvent GameStartedEvent {
        get { return result.GameStartedEvent; }
        set { SetGameStartedEvent(value); }
      }
      public Builder SetGameStartedEvent(global::com.richardpianka.chess.network.GameStartedEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGameStartedEvent = true;
        result.gameStartedEvent_ = value;
        return this;
      }
      public Builder SetGameStartedEvent(global::com.richardpianka.chess.network.GameStartedEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGameStartedEvent = true;
        result.gameStartedEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGameStartedEvent(global::com.richardpianka.chess.network.GameStartedEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGameStartedEvent &&
            result.gameStartedEvent_ != global::com.richardpianka.chess.network.GameStartedEvent.DefaultInstance) {
            result.gameStartedEvent_ = global::com.richardpianka.chess.network.GameStartedEvent.CreateBuilder(result.gameStartedEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.gameStartedEvent_ = value;
        }
        result.hasGameStartedEvent = true;
        return this;
      }
      public Builder ClearGameStartedEvent() {
        PrepareBuilder();
        result.hasGameStartedEvent = false;
        result.gameStartedEvent_ = null;
        return this;
      }
      
      public bool HasMovePieceRequest {
       get { return result.hasMovePieceRequest; }
      }
      public global::com.richardpianka.chess.network.MovePieceRequest MovePieceRequest {
        get { return result.MovePieceRequest; }
        set { SetMovePieceRequest(value); }
      }
      public Builder SetMovePieceRequest(global::com.richardpianka.chess.network.MovePieceRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMovePieceRequest = true;
        result.movePieceRequest_ = value;
        return this;
      }
      public Builder SetMovePieceRequest(global::com.richardpianka.chess.network.MovePieceRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMovePieceRequest = true;
        result.movePieceRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMovePieceRequest(global::com.richardpianka.chess.network.MovePieceRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMovePieceRequest &&
            result.movePieceRequest_ != global::com.richardpianka.chess.network.MovePieceRequest.DefaultInstance) {
            result.movePieceRequest_ = global::com.richardpianka.chess.network.MovePieceRequest.CreateBuilder(result.movePieceRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.movePieceRequest_ = value;
        }
        result.hasMovePieceRequest = true;
        return this;
      }
      public Builder ClearMovePieceRequest() {
        PrepareBuilder();
        result.hasMovePieceRequest = false;
        result.movePieceRequest_ = null;
        return this;
      }
      
      public bool HasMovePieceResponse {
       get { return result.hasMovePieceResponse; }
      }
      public global::com.richardpianka.chess.network.MovePieceResponse MovePieceResponse {
        get { return result.MovePieceResponse; }
        set { SetMovePieceResponse(value); }
      }
      public Builder SetMovePieceResponse(global::com.richardpianka.chess.network.MovePieceResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMovePieceResponse = true;
        result.movePieceResponse_ = value;
        return this;
      }
      public Builder SetMovePieceResponse(global::com.richardpianka.chess.network.MovePieceResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMovePieceResponse = true;
        result.movePieceResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMovePieceResponse(global::com.richardpianka.chess.network.MovePieceResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMovePieceResponse &&
            result.movePieceResponse_ != global::com.richardpianka.chess.network.MovePieceResponse.DefaultInstance) {
            result.movePieceResponse_ = global::com.richardpianka.chess.network.MovePieceResponse.CreateBuilder(result.movePieceResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.movePieceResponse_ = value;
        }
        result.hasMovePieceResponse = true;
        return this;
      }
      public Builder ClearMovePieceResponse() {
        PrepareBuilder();
        result.hasMovePieceResponse = false;
        result.movePieceResponse_ = null;
        return this;
      }
      
      public bool HasMovePieceEvent {
       get { return result.hasMovePieceEvent; }
      }
      public global::com.richardpianka.chess.network.MovePieceEvent MovePieceEvent {
        get { return result.MovePieceEvent; }
        set { SetMovePieceEvent(value); }
      }
      public Builder SetMovePieceEvent(global::com.richardpianka.chess.network.MovePieceEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMovePieceEvent = true;
        result.movePieceEvent_ = value;
        return this;
      }
      public Builder SetMovePieceEvent(global::com.richardpianka.chess.network.MovePieceEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMovePieceEvent = true;
        result.movePieceEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMovePieceEvent(global::com.richardpianka.chess.network.MovePieceEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMovePieceEvent &&
            result.movePieceEvent_ != global::com.richardpianka.chess.network.MovePieceEvent.DefaultInstance) {
            result.movePieceEvent_ = global::com.richardpianka.chess.network.MovePieceEvent.CreateBuilder(result.movePieceEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.movePieceEvent_ = value;
        }
        result.hasMovePieceEvent = true;
        return this;
      }
      public Builder ClearMovePieceEvent() {
        PrepareBuilder();
        result.hasMovePieceEvent = false;
        result.movePieceEvent_ = null;
        return this;
      }
      
      public bool HasSpecialMovePieceRequest {
       get { return result.hasSpecialMovePieceRequest; }
      }
      public global::com.richardpianka.chess.network.SpecialMovePieceRequest SpecialMovePieceRequest {
        get { return result.SpecialMovePieceRequest; }
        set { SetSpecialMovePieceRequest(value); }
      }
      public Builder SetSpecialMovePieceRequest(global::com.richardpianka.chess.network.SpecialMovePieceRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSpecialMovePieceRequest = true;
        result.specialMovePieceRequest_ = value;
        return this;
      }
      public Builder SetSpecialMovePieceRequest(global::com.richardpianka.chess.network.SpecialMovePieceRequest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasSpecialMovePieceRequest = true;
        result.specialMovePieceRequest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeSpecialMovePieceRequest(global::com.richardpianka.chess.network.SpecialMovePieceRequest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasSpecialMovePieceRequest &&
            result.specialMovePieceRequest_ != global::com.richardpianka.chess.network.SpecialMovePieceRequest.DefaultInstance) {
            result.specialMovePieceRequest_ = global::com.richardpianka.chess.network.SpecialMovePieceRequest.CreateBuilder(result.specialMovePieceRequest_).MergeFrom(value).BuildPartial();
        } else {
          result.specialMovePieceRequest_ = value;
        }
        result.hasSpecialMovePieceRequest = true;
        return this;
      }
      public Builder ClearSpecialMovePieceRequest() {
        PrepareBuilder();
        result.hasSpecialMovePieceRequest = false;
        result.specialMovePieceRequest_ = null;
        return this;
      }
      
      public bool HasSpecialMovePieceResponse {
       get { return result.hasSpecialMovePieceResponse; }
      }
      public global::com.richardpianka.chess.network.SpecialMovePieceResponse SpecialMovePieceResponse {
        get { return result.SpecialMovePieceResponse; }
        set { SetSpecialMovePieceResponse(value); }
      }
      public Builder SetSpecialMovePieceResponse(global::com.richardpianka.chess.network.SpecialMovePieceResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSpecialMovePieceResponse = true;
        result.specialMovePieceResponse_ = value;
        return this;
      }
      public Builder SetSpecialMovePieceResponse(global::com.richardpianka.chess.network.SpecialMovePieceResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasSpecialMovePieceResponse = true;
        result.specialMovePieceResponse_ = builderForValue.Build();
        return this;
      }
      public Builder MergeSpecialMovePieceResponse(global::com.richardpianka.chess.network.SpecialMovePieceResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasSpecialMovePieceResponse &&
            result.specialMovePieceResponse_ != global::com.richardpianka.chess.network.SpecialMovePieceResponse.DefaultInstance) {
            result.specialMovePieceResponse_ = global::com.richardpianka.chess.network.SpecialMovePieceResponse.CreateBuilder(result.specialMovePieceResponse_).MergeFrom(value).BuildPartial();
        } else {
          result.specialMovePieceResponse_ = value;
        }
        result.hasSpecialMovePieceResponse = true;
        return this;
      }
      public Builder ClearSpecialMovePieceResponse() {
        PrepareBuilder();
        result.hasSpecialMovePieceResponse = false;
        result.specialMovePieceResponse_ = null;
        return this;
      }
      
      public bool HasSpecialMovePieceEvent {
       get { return result.hasSpecialMovePieceEvent; }
      }
      public global::com.richardpianka.chess.network.SpecialMovePieceEvent SpecialMovePieceEvent {
        get { return result.SpecialMovePieceEvent; }
        set { SetSpecialMovePieceEvent(value); }
      }
      public Builder SetSpecialMovePieceEvent(global::com.richardpianka.chess.network.SpecialMovePieceEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSpecialMovePieceEvent = true;
        result.specialMovePieceEvent_ = value;
        return this;
      }
      public Builder SetSpecialMovePieceEvent(global::com.richardpianka.chess.network.SpecialMovePieceEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasSpecialMovePieceEvent = true;
        result.specialMovePieceEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeSpecialMovePieceEvent(global::com.richardpianka.chess.network.SpecialMovePieceEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasSpecialMovePieceEvent &&
            result.specialMovePieceEvent_ != global::com.richardpianka.chess.network.SpecialMovePieceEvent.DefaultInstance) {
            result.specialMovePieceEvent_ = global::com.richardpianka.chess.network.SpecialMovePieceEvent.CreateBuilder(result.specialMovePieceEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.specialMovePieceEvent_ = value;
        }
        result.hasSpecialMovePieceEvent = true;
        return this;
      }
      public Builder ClearSpecialMovePieceEvent() {
        PrepareBuilder();
        result.hasSpecialMovePieceEvent = false;
        result.specialMovePieceEvent_ = null;
        return this;
      }
      
      public bool HasGameStatusEvent {
       get { return result.hasGameStatusEvent; }
      }
      public global::com.richardpianka.chess.network.GameStatusEvent GameStatusEvent {
        get { return result.GameStatusEvent; }
        set { SetGameStatusEvent(value); }
      }
      public Builder SetGameStatusEvent(global::com.richardpianka.chess.network.GameStatusEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGameStatusEvent = true;
        result.gameStatusEvent_ = value;
        return this;
      }
      public Builder SetGameStatusEvent(global::com.richardpianka.chess.network.GameStatusEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGameStatusEvent = true;
        result.gameStatusEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGameStatusEvent(global::com.richardpianka.chess.network.GameStatusEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGameStatusEvent &&
            result.gameStatusEvent_ != global::com.richardpianka.chess.network.GameStatusEvent.DefaultInstance) {
            result.gameStatusEvent_ = global::com.richardpianka.chess.network.GameStatusEvent.CreateBuilder(result.gameStatusEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.gameStatusEvent_ = value;
        }
        result.hasGameStatusEvent = true;
        return this;
      }
      public Builder ClearGameStatusEvent() {
        PrepareBuilder();
        result.hasGameStatusEvent = false;
        result.gameStatusEvent_ = null;
        return this;
      }
      
      public bool HasTimeLeftEvent {
       get { return result.hasTimeLeftEvent; }
      }
      public global::com.richardpianka.chess.network.TimeLeftEvent TimeLeftEvent {
        get { return result.TimeLeftEvent; }
        set { SetTimeLeftEvent(value); }
      }
      public Builder SetTimeLeftEvent(global::com.richardpianka.chess.network.TimeLeftEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTimeLeftEvent = true;
        result.timeLeftEvent_ = value;
        return this;
      }
      public Builder SetTimeLeftEvent(global::com.richardpianka.chess.network.TimeLeftEvent.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasTimeLeftEvent = true;
        result.timeLeftEvent_ = builderForValue.Build();
        return this;
      }
      public Builder MergeTimeLeftEvent(global::com.richardpianka.chess.network.TimeLeftEvent value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasTimeLeftEvent &&
            result.timeLeftEvent_ != global::com.richardpianka.chess.network.TimeLeftEvent.DefaultInstance) {
            result.timeLeftEvent_ = global::com.richardpianka.chess.network.TimeLeftEvent.CreateBuilder(result.timeLeftEvent_).MergeFrom(value).BuildPartial();
        } else {
          result.timeLeftEvent_ = value;
        }
        result.hasTimeLeftEvent = true;
        return this;
      }
      public Builder ClearTimeLeftEvent() {
        PrepareBuilder();
        result.hasTimeLeftEvent = false;
        result.timeLeftEvent_ = null;
        return this;
      }
    }
    static Envelope() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Coordinate : pb::GeneratedMessage<Coordinate, Coordinate.Builder> {
    private Coordinate() { }
    private static readonly Coordinate defaultInstance = new Coordinate().MakeReadOnly();
    private static readonly string[] _coordinateFieldNames = new string[] { "File", "Rank" };
    private static readonly uint[] _coordinateFieldTags = new uint[] { 8, 16 };
    public static Coordinate DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Coordinate DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Coordinate ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Coordinate__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Coordinate, Coordinate.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Coordinate__FieldAccessorTable; }
    }
    
    public const int FileFieldNumber = 1;
    private bool hasFile;
    private global::com.richardpianka.chess.network.File file_ = global::com.richardpianka.chess.network.File._A;
    public bool HasFile {
      get { return hasFile; }
    }
    public global::com.richardpianka.chess.network.File File {
      get { return file_; }
    }
    
    public const int RankFieldNumber = 2;
    private bool hasRank;
    private global::com.richardpianka.chess.network.Rank rank_ = global::com.richardpianka.chess.network.Rank._1;
    public bool HasRank {
      get { return hasRank; }
    }
    public global::com.richardpianka.chess.network.Rank Rank {
      get { return rank_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasFile) return false;
        if (!hasRank) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _coordinateFieldNames;
      if (hasFile) {
        output.WriteEnum(1, field_names[0], (int) File, File);
      }
      if (hasRank) {
        output.WriteEnum(2, field_names[1], (int) Rank, Rank);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasFile) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) File);
        }
        if (hasRank) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Rank);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Coordinate ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Coordinate ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Coordinate ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Coordinate ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Coordinate ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Coordinate ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Coordinate ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Coordinate ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Coordinate ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Coordinate ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Coordinate MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Coordinate prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Coordinate, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Coordinate cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Coordinate result;
      
      private Coordinate PrepareBuilder() {
        if (resultIsReadOnly) {
          Coordinate original = result;
          result = new Coordinate();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Coordinate MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.Coordinate.Descriptor; }
      }
      
      public override Coordinate DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.Coordinate.DefaultInstance; }
      }
      
      public override Coordinate BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Coordinate) {
          return MergeFrom((Coordinate) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Coordinate other) {
        if (other == global::com.richardpianka.chess.network.Coordinate.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasFile) {
          File = other.File;
        }
        if (other.HasRank) {
          Rank = other.Rank;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_coordinateFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _coordinateFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.file_, out unknown)) {
                result.hasFile = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.rank_, out unknown)) {
                result.hasRank = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasFile {
       get { return result.hasFile; }
      }
      public global::com.richardpianka.chess.network.File File {
        get { return result.File; }
        set { SetFile(value); }
      }
      public Builder SetFile(global::com.richardpianka.chess.network.File value) {
        PrepareBuilder();
        result.hasFile = true;
        result.file_ = value;
        return this;
      }
      public Builder ClearFile() {
        PrepareBuilder();
        result.hasFile = false;
        result.file_ = global::com.richardpianka.chess.network.File._A;
        return this;
      }
      
      public bool HasRank {
       get { return result.hasRank; }
      }
      public global::com.richardpianka.chess.network.Rank Rank {
        get { return result.Rank; }
        set { SetRank(value); }
      }
      public Builder SetRank(global::com.richardpianka.chess.network.Rank value) {
        PrepareBuilder();
        result.hasRank = true;
        result.rank_ = value;
        return this;
      }
      public Builder ClearRank() {
        PrepareBuilder();
        result.hasRank = false;
        result.rank_ = global::com.richardpianka.chess.network.Rank._1;
        return this;
      }
    }
    static Coordinate() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Piece : pb::GeneratedMessage<Piece, Piece.Builder> {
    private Piece() { }
    private static readonly Piece defaultInstance = new Piece().MakeReadOnly();
    private static readonly string[] _pieceFieldNames = new string[] { "Color", "Figurine", "Number" };
    private static readonly uint[] _pieceFieldTags = new uint[] { 8, 16, 24 };
    public static Piece DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Piece DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Piece ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Piece__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Piece, Piece.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Piece__FieldAccessorTable; }
    }
    
    public const int ColorFieldNumber = 1;
    private bool hasColor;
    private global::com.richardpianka.chess.network.Color color_ = global::com.richardpianka.chess.network.Color.White;
    public bool HasColor {
      get { return hasColor; }
    }
    public global::com.richardpianka.chess.network.Color Color {
      get { return color_; }
    }
    
    public const int FigurineFieldNumber = 2;
    private bool hasFigurine;
    private global::com.richardpianka.chess.network.Figurine figurine_ = global::com.richardpianka.chess.network.Figurine.King;
    public bool HasFigurine {
      get { return hasFigurine; }
    }
    public global::com.richardpianka.chess.network.Figurine Figurine {
      get { return figurine_; }
    }
    
    public const int NumberFieldNumber = 3;
    private bool hasNumber;
    private uint number_;
    public bool HasNumber {
      get { return hasNumber; }
    }
    [global::System.CLSCompliant(false)]
    public uint Number {
      get { return number_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasColor) return false;
        if (!hasFigurine) return false;
        if (!hasNumber) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _pieceFieldNames;
      if (hasColor) {
        output.WriteEnum(1, field_names[0], (int) Color, Color);
      }
      if (hasFigurine) {
        output.WriteEnum(2, field_names[1], (int) Figurine, Figurine);
      }
      if (hasNumber) {
        output.WriteUInt32(3, field_names[2], Number);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasColor) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Color);
        }
        if (hasFigurine) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Figurine);
        }
        if (hasNumber) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, Number);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Piece ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Piece ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Piece ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Piece ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Piece ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Piece ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Piece ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Piece ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Piece ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Piece ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Piece MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Piece prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Piece, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Piece cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Piece result;
      
      private Piece PrepareBuilder() {
        if (resultIsReadOnly) {
          Piece original = result;
          result = new Piece();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Piece MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.Piece.Descriptor; }
      }
      
      public override Piece DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.Piece.DefaultInstance; }
      }
      
      public override Piece BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Piece) {
          return MergeFrom((Piece) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Piece other) {
        if (other == global::com.richardpianka.chess.network.Piece.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasColor) {
          Color = other.Color;
        }
        if (other.HasFigurine) {
          Figurine = other.Figurine;
        }
        if (other.HasNumber) {
          Number = other.Number;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_pieceFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _pieceFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.color_, out unknown)) {
                result.hasColor = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.figurine_, out unknown)) {
                result.hasFigurine = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 24: {
              result.hasNumber = input.ReadUInt32(ref result.number_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasColor {
       get { return result.hasColor; }
      }
      public global::com.richardpianka.chess.network.Color Color {
        get { return result.Color; }
        set { SetColor(value); }
      }
      public Builder SetColor(global::com.richardpianka.chess.network.Color value) {
        PrepareBuilder();
        result.hasColor = true;
        result.color_ = value;
        return this;
      }
      public Builder ClearColor() {
        PrepareBuilder();
        result.hasColor = false;
        result.color_ = global::com.richardpianka.chess.network.Color.White;
        return this;
      }
      
      public bool HasFigurine {
       get { return result.hasFigurine; }
      }
      public global::com.richardpianka.chess.network.Figurine Figurine {
        get { return result.Figurine; }
        set { SetFigurine(value); }
      }
      public Builder SetFigurine(global::com.richardpianka.chess.network.Figurine value) {
        PrepareBuilder();
        result.hasFigurine = true;
        result.figurine_ = value;
        return this;
      }
      public Builder ClearFigurine() {
        PrepareBuilder();
        result.hasFigurine = false;
        result.figurine_ = global::com.richardpianka.chess.network.Figurine.King;
        return this;
      }
      
      public bool HasNumber {
        get { return result.hasNumber; }
      }
      [global::System.CLSCompliant(false)]
      public uint Number {
        get { return result.Number; }
        set { SetNumber(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetNumber(uint value) {
        PrepareBuilder();
        result.hasNumber = true;
        result.number_ = value;
        return this;
      }
      public Builder ClearNumber() {
        PrepareBuilder();
        result.hasNumber = false;
        result.number_ = 0;
        return this;
      }
    }
    static Piece() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Move : pb::GeneratedMessage<Move, Move.Builder> {
    private Move() { }
    private static readonly Move defaultInstance = new Move().MakeReadOnly();
    private static readonly string[] _moveFieldNames = new string[] { "End", "Piece", "Start" };
    private static readonly uint[] _moveFieldTags = new uint[] { 26, 10, 18 };
    public static Move DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Move DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Move ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Move__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Move, Move.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Move__FieldAccessorTable; }
    }
    
    public const int PieceFieldNumber = 1;
    private bool hasPiece;
    private global::com.richardpianka.chess.network.Piece piece_;
    public bool HasPiece {
      get { return hasPiece; }
    }
    public global::com.richardpianka.chess.network.Piece Piece {
      get { return piece_ ?? global::com.richardpianka.chess.network.Piece.DefaultInstance; }
    }
    
    public const int StartFieldNumber = 2;
    private bool hasStart;
    private global::com.richardpianka.chess.network.Coordinate start_;
    public bool HasStart {
      get { return hasStart; }
    }
    public global::com.richardpianka.chess.network.Coordinate Start {
      get { return start_ ?? global::com.richardpianka.chess.network.Coordinate.DefaultInstance; }
    }
    
    public const int EndFieldNumber = 3;
    private bool hasEnd;
    private global::com.richardpianka.chess.network.Coordinate end_;
    public bool HasEnd {
      get { return hasEnd; }
    }
    public global::com.richardpianka.chess.network.Coordinate End {
      get { return end_ ?? global::com.richardpianka.chess.network.Coordinate.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasPiece) return false;
        if (!hasStart) return false;
        if (!hasEnd) return false;
        if (!Piece.IsInitialized) return false;
        if (!Start.IsInitialized) return false;
        if (!End.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _moveFieldNames;
      if (hasPiece) {
        output.WriteMessage(1, field_names[1], Piece);
      }
      if (hasStart) {
        output.WriteMessage(2, field_names[2], Start);
      }
      if (hasEnd) {
        output.WriteMessage(3, field_names[0], End);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasPiece) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Piece);
        }
        if (hasStart) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Start);
        }
        if (hasEnd) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, End);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Move ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Move ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Move ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Move ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Move ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Move ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Move ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Move ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Move ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Move ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Move MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Move prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Move, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Move cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Move result;
      
      private Move PrepareBuilder() {
        if (resultIsReadOnly) {
          Move original = result;
          result = new Move();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Move MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.Move.Descriptor; }
      }
      
      public override Move DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.Move.DefaultInstance; }
      }
      
      public override Move BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Move) {
          return MergeFrom((Move) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Move other) {
        if (other == global::com.richardpianka.chess.network.Move.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasPiece) {
          MergePiece(other.Piece);
        }
        if (other.HasStart) {
          MergeStart(other.Start);
        }
        if (other.HasEnd) {
          MergeEnd(other.End);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_moveFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _moveFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.Piece.Builder subBuilder = global::com.richardpianka.chess.network.Piece.CreateBuilder();
              if (result.hasPiece) {
                subBuilder.MergeFrom(Piece);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Piece = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::com.richardpianka.chess.network.Coordinate.Builder subBuilder = global::com.richardpianka.chess.network.Coordinate.CreateBuilder();
              if (result.hasStart) {
                subBuilder.MergeFrom(Start);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Start = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::com.richardpianka.chess.network.Coordinate.Builder subBuilder = global::com.richardpianka.chess.network.Coordinate.CreateBuilder();
              if (result.hasEnd) {
                subBuilder.MergeFrom(End);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              End = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasPiece {
       get { return result.hasPiece; }
      }
      public global::com.richardpianka.chess.network.Piece Piece {
        get { return result.Piece; }
        set { SetPiece(value); }
      }
      public Builder SetPiece(global::com.richardpianka.chess.network.Piece value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPiece = true;
        result.piece_ = value;
        return this;
      }
      public Builder SetPiece(global::com.richardpianka.chess.network.Piece.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPiece = true;
        result.piece_ = builderForValue.Build();
        return this;
      }
      public Builder MergePiece(global::com.richardpianka.chess.network.Piece value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPiece &&
            result.piece_ != global::com.richardpianka.chess.network.Piece.DefaultInstance) {
            result.piece_ = global::com.richardpianka.chess.network.Piece.CreateBuilder(result.piece_).MergeFrom(value).BuildPartial();
        } else {
          result.piece_ = value;
        }
        result.hasPiece = true;
        return this;
      }
      public Builder ClearPiece() {
        PrepareBuilder();
        result.hasPiece = false;
        result.piece_ = null;
        return this;
      }
      
      public bool HasStart {
       get { return result.hasStart; }
      }
      public global::com.richardpianka.chess.network.Coordinate Start {
        get { return result.Start; }
        set { SetStart(value); }
      }
      public Builder SetStart(global::com.richardpianka.chess.network.Coordinate value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasStart = true;
        result.start_ = value;
        return this;
      }
      public Builder SetStart(global::com.richardpianka.chess.network.Coordinate.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasStart = true;
        result.start_ = builderForValue.Build();
        return this;
      }
      public Builder MergeStart(global::com.richardpianka.chess.network.Coordinate value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasStart &&
            result.start_ != global::com.richardpianka.chess.network.Coordinate.DefaultInstance) {
            result.start_ = global::com.richardpianka.chess.network.Coordinate.CreateBuilder(result.start_).MergeFrom(value).BuildPartial();
        } else {
          result.start_ = value;
        }
        result.hasStart = true;
        return this;
      }
      public Builder ClearStart() {
        PrepareBuilder();
        result.hasStart = false;
        result.start_ = null;
        return this;
      }
      
      public bool HasEnd {
       get { return result.hasEnd; }
      }
      public global::com.richardpianka.chess.network.Coordinate End {
        get { return result.End; }
        set { SetEnd(value); }
      }
      public Builder SetEnd(global::com.richardpianka.chess.network.Coordinate value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEnd = true;
        result.end_ = value;
        return this;
      }
      public Builder SetEnd(global::com.richardpianka.chess.network.Coordinate.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasEnd = true;
        result.end_ = builderForValue.Build();
        return this;
      }
      public Builder MergeEnd(global::com.richardpianka.chess.network.Coordinate value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasEnd &&
            result.end_ != global::com.richardpianka.chess.network.Coordinate.DefaultInstance) {
            result.end_ = global::com.richardpianka.chess.network.Coordinate.CreateBuilder(result.end_).MergeFrom(value).BuildPartial();
        } else {
          result.end_ = value;
        }
        result.hasEnd = true;
        return this;
      }
      public Builder ClearEnd() {
        PrepareBuilder();
        result.hasEnd = false;
        result.end_ = null;
        return this;
      }
    }
    static Move() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class SpecialMove : pb::GeneratedMessage<SpecialMove, SpecialMove.Builder> {
    private SpecialMove() { }
    private static readonly SpecialMove defaultInstance = new SpecialMove().MakeReadOnly();
    private static readonly string[] _specialMoveFieldNames = new string[] { "Castle" };
    private static readonly uint[] _specialMoveFieldTags = new uint[] { 10 };
    public static SpecialMove DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SpecialMove DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SpecialMove ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_SpecialMove__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SpecialMove, SpecialMove.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_SpecialMove__FieldAccessorTable; }
    }
    
    public const int CastleFieldNumber = 1;
    private bool hasCastle;
    private global::com.richardpianka.chess.network.Castle castle_;
    public bool HasCastle {
      get { return hasCastle; }
    }
    public global::com.richardpianka.chess.network.Castle Castle {
      get { return castle_ ?? global::com.richardpianka.chess.network.Castle.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasCastle) {
          if (!Castle.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _specialMoveFieldNames;
      if (hasCastle) {
        output.WriteMessage(1, field_names[0], Castle);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCastle) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Castle);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SpecialMove ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpecialMove ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpecialMove ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpecialMove ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpecialMove ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpecialMove ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SpecialMove ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SpecialMove ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SpecialMove ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpecialMove ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SpecialMove MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SpecialMove prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<SpecialMove, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SpecialMove cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SpecialMove result;
      
      private SpecialMove PrepareBuilder() {
        if (resultIsReadOnly) {
          SpecialMove original = result;
          result = new SpecialMove();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SpecialMove MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.SpecialMove.Descriptor; }
      }
      
      public override SpecialMove DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.SpecialMove.DefaultInstance; }
      }
      
      public override SpecialMove BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SpecialMove) {
          return MergeFrom((SpecialMove) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SpecialMove other) {
        if (other == global::com.richardpianka.chess.network.SpecialMove.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCastle) {
          MergeCastle(other.Castle);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_specialMoveFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _specialMoveFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.Castle.Builder subBuilder = global::com.richardpianka.chess.network.Castle.CreateBuilder();
              if (result.hasCastle) {
                subBuilder.MergeFrom(Castle);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Castle = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCastle {
       get { return result.hasCastle; }
      }
      public global::com.richardpianka.chess.network.Castle Castle {
        get { return result.Castle; }
        set { SetCastle(value); }
      }
      public Builder SetCastle(global::com.richardpianka.chess.network.Castle value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCastle = true;
        result.castle_ = value;
        return this;
      }
      public Builder SetCastle(global::com.richardpianka.chess.network.Castle.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCastle = true;
        result.castle_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCastle(global::com.richardpianka.chess.network.Castle value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCastle &&
            result.castle_ != global::com.richardpianka.chess.network.Castle.DefaultInstance) {
            result.castle_ = global::com.richardpianka.chess.network.Castle.CreateBuilder(result.castle_).MergeFrom(value).BuildPartial();
        } else {
          result.castle_ = value;
        }
        result.hasCastle = true;
        return this;
      }
      public Builder ClearCastle() {
        PrepareBuilder();
        result.hasCastle = false;
        result.castle_ = null;
        return this;
      }
    }
    static SpecialMove() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Castle : pb::GeneratedMessage<Castle, Castle.Builder> {
    private Castle() { }
    private static readonly Castle defaultInstance = new Castle().MakeReadOnly();
    private static readonly string[] _castleFieldNames = new string[] { "King", "Rook" };
    private static readonly uint[] _castleFieldTags = new uint[] { 18, 10 };
    public static Castle DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Castle DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Castle ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Castle__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Castle, Castle.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Castle__FieldAccessorTable; }
    }
    
    public const int RookFieldNumber = 1;
    private bool hasRook;
    private global::com.richardpianka.chess.network.Piece rook_;
    public bool HasRook {
      get { return hasRook; }
    }
    public global::com.richardpianka.chess.network.Piece Rook {
      get { return rook_ ?? global::com.richardpianka.chess.network.Piece.DefaultInstance; }
    }
    
    public const int KingFieldNumber = 2;
    private bool hasKing;
    private global::com.richardpianka.chess.network.Piece king_;
    public bool HasKing {
      get { return hasKing; }
    }
    public global::com.richardpianka.chess.network.Piece King {
      get { return king_ ?? global::com.richardpianka.chess.network.Piece.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRook) return false;
        if (!hasKing) return false;
        if (!Rook.IsInitialized) return false;
        if (!King.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _castleFieldNames;
      if (hasRook) {
        output.WriteMessage(1, field_names[1], Rook);
      }
      if (hasKing) {
        output.WriteMessage(2, field_names[0], King);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRook) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Rook);
        }
        if (hasKing) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, King);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Castle ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Castle ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Castle ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Castle ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Castle ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Castle ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Castle ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Castle ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Castle ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Castle ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Castle MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Castle prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Castle, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Castle cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Castle result;
      
      private Castle PrepareBuilder() {
        if (resultIsReadOnly) {
          Castle original = result;
          result = new Castle();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Castle MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.Castle.Descriptor; }
      }
      
      public override Castle DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.Castle.DefaultInstance; }
      }
      
      public override Castle BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Castle) {
          return MergeFrom((Castle) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Castle other) {
        if (other == global::com.richardpianka.chess.network.Castle.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRook) {
          MergeRook(other.Rook);
        }
        if (other.HasKing) {
          MergeKing(other.King);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_castleFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _castleFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.Piece.Builder subBuilder = global::com.richardpianka.chess.network.Piece.CreateBuilder();
              if (result.hasRook) {
                subBuilder.MergeFrom(Rook);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Rook = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::com.richardpianka.chess.network.Piece.Builder subBuilder = global::com.richardpianka.chess.network.Piece.CreateBuilder();
              if (result.hasKing) {
                subBuilder.MergeFrom(King);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              King = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRook {
       get { return result.hasRook; }
      }
      public global::com.richardpianka.chess.network.Piece Rook {
        get { return result.Rook; }
        set { SetRook(value); }
      }
      public Builder SetRook(global::com.richardpianka.chess.network.Piece value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRook = true;
        result.rook_ = value;
        return this;
      }
      public Builder SetRook(global::com.richardpianka.chess.network.Piece.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRook = true;
        result.rook_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRook(global::com.richardpianka.chess.network.Piece value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRook &&
            result.rook_ != global::com.richardpianka.chess.network.Piece.DefaultInstance) {
            result.rook_ = global::com.richardpianka.chess.network.Piece.CreateBuilder(result.rook_).MergeFrom(value).BuildPartial();
        } else {
          result.rook_ = value;
        }
        result.hasRook = true;
        return this;
      }
      public Builder ClearRook() {
        PrepareBuilder();
        result.hasRook = false;
        result.rook_ = null;
        return this;
      }
      
      public bool HasKing {
       get { return result.hasKing; }
      }
      public global::com.richardpianka.chess.network.Piece King {
        get { return result.King; }
        set { SetKing(value); }
      }
      public Builder SetKing(global::com.richardpianka.chess.network.Piece value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasKing = true;
        result.king_ = value;
        return this;
      }
      public Builder SetKing(global::com.richardpianka.chess.network.Piece.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasKing = true;
        result.king_ = builderForValue.Build();
        return this;
      }
      public Builder MergeKing(global::com.richardpianka.chess.network.Piece value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasKing &&
            result.king_ != global::com.richardpianka.chess.network.Piece.DefaultInstance) {
            result.king_ = global::com.richardpianka.chess.network.Piece.CreateBuilder(result.king_).MergeFrom(value).BuildPartial();
        } else {
          result.king_ = value;
        }
        result.hasKing = true;
        return this;
      }
      public Builder ClearKing() {
        PrepareBuilder();
        result.hasKing = false;
        result.king_ = null;
        return this;
      }
    }
    static Castle() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Version : pb::GeneratedMessage<Version, Version.Builder> {
    private Version() { }
    private static readonly Version defaultInstance = new Version().MakeReadOnly();
    private static readonly string[] _versionFieldNames = new string[] { "VersionMajor", "VersionMinor", "VersionRevision" };
    private static readonly uint[] _versionFieldTags = new uint[] { 8, 16, 24 };
    public static Version DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Version DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Version ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Version__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Version, Version.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Version__FieldAccessorTable; }
    }
    
    public const int VersionMajorFieldNumber = 1;
    private bool hasVersionMajor;
    private uint versionMajor_ = 1;
    public bool HasVersionMajor {
      get { return hasVersionMajor; }
    }
    [global::System.CLSCompliant(false)]
    public uint VersionMajor {
      get { return versionMajor_; }
    }
    
    public const int VersionMinorFieldNumber = 2;
    private bool hasVersionMinor;
    private uint versionMinor_;
    public bool HasVersionMinor {
      get { return hasVersionMinor; }
    }
    [global::System.CLSCompliant(false)]
    public uint VersionMinor {
      get { return versionMinor_; }
    }
    
    public const int VersionRevisionFieldNumber = 3;
    private bool hasVersionRevision;
    private uint versionRevision_;
    public bool HasVersionRevision {
      get { return hasVersionRevision; }
    }
    [global::System.CLSCompliant(false)]
    public uint VersionRevision {
      get { return versionRevision_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _versionFieldNames;
      if (hasVersionMajor) {
        output.WriteUInt32(1, field_names[0], VersionMajor);
      }
      if (hasVersionMinor) {
        output.WriteUInt32(2, field_names[1], VersionMinor);
      }
      if (hasVersionRevision) {
        output.WriteUInt32(3, field_names[2], VersionRevision);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasVersionMajor) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, VersionMajor);
        }
        if (hasVersionMinor) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, VersionMinor);
        }
        if (hasVersionRevision) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, VersionRevision);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Version ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Version ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Version ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Version ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Version ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Version ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Version ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Version ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Version ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Version ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Version MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Version prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Version, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Version cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Version result;
      
      private Version PrepareBuilder() {
        if (resultIsReadOnly) {
          Version original = result;
          result = new Version();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Version MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.Version.Descriptor; }
      }
      
      public override Version DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.Version.DefaultInstance; }
      }
      
      public override Version BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Version) {
          return MergeFrom((Version) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Version other) {
        if (other == global::com.richardpianka.chess.network.Version.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasVersionMajor) {
          VersionMajor = other.VersionMajor;
        }
        if (other.HasVersionMinor) {
          VersionMinor = other.VersionMinor;
        }
        if (other.HasVersionRevision) {
          VersionRevision = other.VersionRevision;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_versionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _versionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasVersionMajor = input.ReadUInt32(ref result.versionMajor_);
              break;
            }
            case 16: {
              result.hasVersionMinor = input.ReadUInt32(ref result.versionMinor_);
              break;
            }
            case 24: {
              result.hasVersionRevision = input.ReadUInt32(ref result.versionRevision_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasVersionMajor {
        get { return result.hasVersionMajor; }
      }
      [global::System.CLSCompliant(false)]
      public uint VersionMajor {
        get { return result.VersionMajor; }
        set { SetVersionMajor(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetVersionMajor(uint value) {
        PrepareBuilder();
        result.hasVersionMajor = true;
        result.versionMajor_ = value;
        return this;
      }
      public Builder ClearVersionMajor() {
        PrepareBuilder();
        result.hasVersionMajor = false;
        result.versionMajor_ = 1;
        return this;
      }
      
      public bool HasVersionMinor {
        get { return result.hasVersionMinor; }
      }
      [global::System.CLSCompliant(false)]
      public uint VersionMinor {
        get { return result.VersionMinor; }
        set { SetVersionMinor(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetVersionMinor(uint value) {
        PrepareBuilder();
        result.hasVersionMinor = true;
        result.versionMinor_ = value;
        return this;
      }
      public Builder ClearVersionMinor() {
        PrepareBuilder();
        result.hasVersionMinor = false;
        result.versionMinor_ = 0;
        return this;
      }
      
      public bool HasVersionRevision {
        get { return result.hasVersionRevision; }
      }
      [global::System.CLSCompliant(false)]
      public uint VersionRevision {
        get { return result.VersionRevision; }
        set { SetVersionRevision(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetVersionRevision(uint value) {
        PrepareBuilder();
        result.hasVersionRevision = true;
        result.versionRevision_ = value;
        return this;
      }
      public Builder ClearVersionRevision() {
        PrepareBuilder();
        result.hasVersionRevision = false;
        result.versionRevision_ = 0;
        return this;
      }
    }
    static Version() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Room : pb::GeneratedMessage<Room, Room.Builder> {
    private Room() { }
    private static readonly Room defaultInstance = new Room().MakeReadOnly();
    private static readonly string[] _roomFieldNames = new string[] { "Flags", "Name" };
    private static readonly uint[] _roomFieldTags = new uint[] { 16, 10 };
    public static Room DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Room DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Room ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Room__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Room, Room.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Room__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int FlagsFieldNumber = 2;
    private bool hasFlags;
    private global::com.richardpianka.chess.network.RoomFlags flags_ = global::com.richardpianka.chess.network.RoomFlags.Public;
    public bool HasFlags {
      get { return hasFlags; }
    }
    public global::com.richardpianka.chess.network.RoomFlags Flags {
      get { return flags_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        if (!hasFlags) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _roomFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[1], Name);
      }
      if (hasFlags) {
        output.WriteEnum(2, field_names[0], (int) Flags, Flags);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasFlags) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Flags);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Room ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Room ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Room ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Room ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Room ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Room ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Room ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Room ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Room ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Room ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Room MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Room prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Room, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Room cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Room result;
      
      private Room PrepareBuilder() {
        if (resultIsReadOnly) {
          Room original = result;
          result = new Room();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Room MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.Room.Descriptor; }
      }
      
      public override Room DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.Room.DefaultInstance; }
      }
      
      public override Room BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Room) {
          return MergeFrom((Room) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Room other) {
        if (other == global::com.richardpianka.chess.network.Room.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasFlags) {
          Flags = other.Flags;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_roomFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _roomFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.flags_, out unknown)) {
                result.hasFlags = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasFlags {
       get { return result.hasFlags; }
      }
      public global::com.richardpianka.chess.network.RoomFlags Flags {
        get { return result.Flags; }
        set { SetFlags(value); }
      }
      public Builder SetFlags(global::com.richardpianka.chess.network.RoomFlags value) {
        PrepareBuilder();
        result.hasFlags = true;
        result.flags_ = value;
        return this;
      }
      public Builder ClearFlags() {
        PrepareBuilder();
        result.hasFlags = false;
        result.flags_ = global::com.richardpianka.chess.network.RoomFlags.Public;
        return this;
      }
    }
    static Room() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Record : pb::GeneratedMessage<Record, Record.Builder> {
    private Record() { }
    private static readonly Record defaultInstance = new Record().MakeReadOnly();
    private static readonly string[] _recordFieldNames = new string[] { "Disconnects", "Losses", "Stalemates", "Wins" };
    private static readonly uint[] _recordFieldTags = new uint[] { 32, 16, 24, 8 };
    public static Record DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Record DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Record ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Record__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Record, Record.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Record__FieldAccessorTable; }
    }
    
    public const int WinsFieldNumber = 1;
    private bool hasWins;
    private uint wins_;
    public bool HasWins {
      get { return hasWins; }
    }
    [global::System.CLSCompliant(false)]
    public uint Wins {
      get { return wins_; }
    }
    
    public const int LossesFieldNumber = 2;
    private bool hasLosses;
    private uint losses_;
    public bool HasLosses {
      get { return hasLosses; }
    }
    [global::System.CLSCompliant(false)]
    public uint Losses {
      get { return losses_; }
    }
    
    public const int StalematesFieldNumber = 3;
    private bool hasStalemates;
    private uint stalemates_;
    public bool HasStalemates {
      get { return hasStalemates; }
    }
    [global::System.CLSCompliant(false)]
    public uint Stalemates {
      get { return stalemates_; }
    }
    
    public const int DisconnectsFieldNumber = 4;
    private bool hasDisconnects;
    private uint disconnects_;
    public bool HasDisconnects {
      get { return hasDisconnects; }
    }
    [global::System.CLSCompliant(false)]
    public uint Disconnects {
      get { return disconnects_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasWins) return false;
        if (!hasLosses) return false;
        if (!hasStalemates) return false;
        if (!hasDisconnects) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _recordFieldNames;
      if (hasWins) {
        output.WriteUInt32(1, field_names[3], Wins);
      }
      if (hasLosses) {
        output.WriteUInt32(2, field_names[1], Losses);
      }
      if (hasStalemates) {
        output.WriteUInt32(3, field_names[2], Stalemates);
      }
      if (hasDisconnects) {
        output.WriteUInt32(4, field_names[0], Disconnects);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasWins) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Wins);
        }
        if (hasLosses) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, Losses);
        }
        if (hasStalemates) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, Stalemates);
        }
        if (hasDisconnects) {
          size += pb::CodedOutputStream.ComputeUInt32Size(4, Disconnects);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Record ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Record ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Record ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Record ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Record ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Record ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Record ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Record ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Record ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Record ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Record MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Record prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Record, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Record cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Record result;
      
      private Record PrepareBuilder() {
        if (resultIsReadOnly) {
          Record original = result;
          result = new Record();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Record MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.Record.Descriptor; }
      }
      
      public override Record DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.Record.DefaultInstance; }
      }
      
      public override Record BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Record) {
          return MergeFrom((Record) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Record other) {
        if (other == global::com.richardpianka.chess.network.Record.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasWins) {
          Wins = other.Wins;
        }
        if (other.HasLosses) {
          Losses = other.Losses;
        }
        if (other.HasStalemates) {
          Stalemates = other.Stalemates;
        }
        if (other.HasDisconnects) {
          Disconnects = other.Disconnects;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_recordFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _recordFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasWins = input.ReadUInt32(ref result.wins_);
              break;
            }
            case 16: {
              result.hasLosses = input.ReadUInt32(ref result.losses_);
              break;
            }
            case 24: {
              result.hasStalemates = input.ReadUInt32(ref result.stalemates_);
              break;
            }
            case 32: {
              result.hasDisconnects = input.ReadUInt32(ref result.disconnects_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasWins {
        get { return result.hasWins; }
      }
      [global::System.CLSCompliant(false)]
      public uint Wins {
        get { return result.Wins; }
        set { SetWins(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetWins(uint value) {
        PrepareBuilder();
        result.hasWins = true;
        result.wins_ = value;
        return this;
      }
      public Builder ClearWins() {
        PrepareBuilder();
        result.hasWins = false;
        result.wins_ = 0;
        return this;
      }
      
      public bool HasLosses {
        get { return result.hasLosses; }
      }
      [global::System.CLSCompliant(false)]
      public uint Losses {
        get { return result.Losses; }
        set { SetLosses(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetLosses(uint value) {
        PrepareBuilder();
        result.hasLosses = true;
        result.losses_ = value;
        return this;
      }
      public Builder ClearLosses() {
        PrepareBuilder();
        result.hasLosses = false;
        result.losses_ = 0;
        return this;
      }
      
      public bool HasStalemates {
        get { return result.hasStalemates; }
      }
      [global::System.CLSCompliant(false)]
      public uint Stalemates {
        get { return result.Stalemates; }
        set { SetStalemates(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetStalemates(uint value) {
        PrepareBuilder();
        result.hasStalemates = true;
        result.stalemates_ = value;
        return this;
      }
      public Builder ClearStalemates() {
        PrepareBuilder();
        result.hasStalemates = false;
        result.stalemates_ = 0;
        return this;
      }
      
      public bool HasDisconnects {
        get { return result.hasDisconnects; }
      }
      [global::System.CLSCompliant(false)]
      public uint Disconnects {
        get { return result.Disconnects; }
        set { SetDisconnects(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetDisconnects(uint value) {
        PrepareBuilder();
        result.hasDisconnects = true;
        result.disconnects_ = value;
        return this;
      }
      public Builder ClearDisconnects() {
        PrepareBuilder();
        result.hasDisconnects = false;
        result.disconnects_ = 0;
        return this;
      }
    }
    static Record() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class User : pb::GeneratedMessage<User, User.Builder> {
    private User() { }
    private static readonly User defaultInstance = new User().MakeReadOnly();
    private static readonly string[] _userFieldNames = new string[] { "Flags", "Name", "Record" };
    private static readonly uint[] _userFieldTags = new uint[] { 16, 10, 26 };
    public static User DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override User DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override User ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_User__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<User, User.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_User__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int FlagsFieldNumber = 2;
    private bool hasFlags;
    private global::com.richardpianka.chess.network.UserFlags flags_ = global::com.richardpianka.chess.network.UserFlags.Pedestrian;
    public bool HasFlags {
      get { return hasFlags; }
    }
    public global::com.richardpianka.chess.network.UserFlags Flags {
      get { return flags_; }
    }
    
    public const int RecordFieldNumber = 3;
    private bool hasRecord;
    private global::com.richardpianka.chess.network.Record record_;
    public bool HasRecord {
      get { return hasRecord; }
    }
    public global::com.richardpianka.chess.network.Record Record {
      get { return record_ ?? global::com.richardpianka.chess.network.Record.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        if (!hasFlags) return false;
        if (!hasRecord) return false;
        if (!Record.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _userFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[1], Name);
      }
      if (hasFlags) {
        output.WriteEnum(2, field_names[0], (int) Flags, Flags);
      }
      if (hasRecord) {
        output.WriteMessage(3, field_names[2], Record);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasFlags) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Flags);
        }
        if (hasRecord) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Record);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static User ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static User ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static User ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static User ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static User ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static User ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static User ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static User ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static User ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static User ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private User MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(User prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<User, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(User cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private User result;
      
      private User PrepareBuilder() {
        if (resultIsReadOnly) {
          User original = result;
          result = new User();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override User MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.User.Descriptor; }
      }
      
      public override User DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.User.DefaultInstance; }
      }
      
      public override User BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is User) {
          return MergeFrom((User) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(User other) {
        if (other == global::com.richardpianka.chess.network.User.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasFlags) {
          Flags = other.Flags;
        }
        if (other.HasRecord) {
          MergeRecord(other.Record);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_userFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _userFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.flags_, out unknown)) {
                result.hasFlags = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 26: {
              global::com.richardpianka.chess.network.Record.Builder subBuilder = global::com.richardpianka.chess.network.Record.CreateBuilder();
              if (result.hasRecord) {
                subBuilder.MergeFrom(Record);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Record = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasFlags {
       get { return result.hasFlags; }
      }
      public global::com.richardpianka.chess.network.UserFlags Flags {
        get { return result.Flags; }
        set { SetFlags(value); }
      }
      public Builder SetFlags(global::com.richardpianka.chess.network.UserFlags value) {
        PrepareBuilder();
        result.hasFlags = true;
        result.flags_ = value;
        return this;
      }
      public Builder ClearFlags() {
        PrepareBuilder();
        result.hasFlags = false;
        result.flags_ = global::com.richardpianka.chess.network.UserFlags.Pedestrian;
        return this;
      }
      
      public bool HasRecord {
       get { return result.hasRecord; }
      }
      public global::com.richardpianka.chess.network.Record Record {
        get { return result.Record; }
        set { SetRecord(value); }
      }
      public Builder SetRecord(global::com.richardpianka.chess.network.Record value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRecord = true;
        result.record_ = value;
        return this;
      }
      public Builder SetRecord(global::com.richardpianka.chess.network.Record.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRecord = true;
        result.record_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRecord(global::com.richardpianka.chess.network.Record value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRecord &&
            result.record_ != global::com.richardpianka.chess.network.Record.DefaultInstance) {
            result.record_ = global::com.richardpianka.chess.network.Record.CreateBuilder(result.record_).MergeFrom(value).BuildPartial();
        } else {
          result.record_ = value;
        }
        result.hasRecord = true;
        return this;
      }
      public Builder ClearRecord() {
        PrepareBuilder();
        result.hasRecord = false;
        result.record_ = null;
        return this;
      }
    }
    static User() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Game : pb::GeneratedMessage<Game, Game.Builder> {
    private Game() { }
    private static readonly Game defaultInstance = new Game().MakeReadOnly();
    private static readonly string[] _gameFieldNames = new string[] { "MetaData", "Name", "Password", "Private" };
    private static readonly uint[] _gameFieldTags = new uint[] { 34, 10, 18, 24 };
    public static Game DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Game DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Game ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Game__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Game, Game.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_Game__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int PasswordFieldNumber = 2;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public const int PrivateFieldNumber = 3;
    private bool hasPrivate;
    private bool private_;
    public bool HasPrivate {
      get { return hasPrivate; }
    }
    public bool Private {
      get { return private_; }
    }
    
    public const int MetaDataFieldNumber = 4;
    private bool hasMetaData;
    private global::com.richardpianka.chess.network.GameMetadata metaData_;
    public bool HasMetaData {
      get { return hasMetaData; }
    }
    public global::com.richardpianka.chess.network.GameMetadata MetaData {
      get { return metaData_ ?? global::com.richardpianka.chess.network.GameMetadata.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        if (!hasPrivate) return false;
        if (HasMetaData) {
          if (!MetaData.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gameFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[1], Name);
      }
      if (hasPassword) {
        output.WriteString(2, field_names[2], Password);
      }
      if (hasPrivate) {
        output.WriteBool(3, field_names[3], Private);
      }
      if (hasMetaData) {
        output.WriteMessage(4, field_names[0], MetaData);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasPassword) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Password);
        }
        if (hasPrivate) {
          size += pb::CodedOutputStream.ComputeBoolSize(3, Private);
        }
        if (hasMetaData) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, MetaData);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Game ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Game ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Game ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Game ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Game ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Game ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Game ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Game ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Game ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Game ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Game MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Game prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Game, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Game cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Game result;
      
      private Game PrepareBuilder() {
        if (resultIsReadOnly) {
          Game original = result;
          result = new Game();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Game MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.Game.Descriptor; }
      }
      
      public override Game DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.Game.DefaultInstance; }
      }
      
      public override Game BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Game) {
          return MergeFrom((Game) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Game other) {
        if (other == global::com.richardpianka.chess.network.Game.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        if (other.HasPrivate) {
          Private = other.Private;
        }
        if (other.HasMetaData) {
          MergeMetaData(other.MetaData);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
            case 24: {
              result.hasPrivate = input.ReadBool(ref result.private_);
              break;
            }
            case 34: {
              global::com.richardpianka.chess.network.GameMetadata.Builder subBuilder = global::com.richardpianka.chess.network.GameMetadata.CreateBuilder();
              if (result.hasMetaData) {
                subBuilder.MergeFrom(MetaData);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              MetaData = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
      
      public bool HasPrivate {
        get { return result.hasPrivate; }
      }
      public bool Private {
        get { return result.Private; }
        set { SetPrivate(value); }
      }
      public Builder SetPrivate(bool value) {
        PrepareBuilder();
        result.hasPrivate = true;
        result.private_ = value;
        return this;
      }
      public Builder ClearPrivate() {
        PrepareBuilder();
        result.hasPrivate = false;
        result.private_ = false;
        return this;
      }
      
      public bool HasMetaData {
       get { return result.hasMetaData; }
      }
      public global::com.richardpianka.chess.network.GameMetadata MetaData {
        get { return result.MetaData; }
        set { SetMetaData(value); }
      }
      public Builder SetMetaData(global::com.richardpianka.chess.network.GameMetadata value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMetaData = true;
        result.metaData_ = value;
        return this;
      }
      public Builder SetMetaData(global::com.richardpianka.chess.network.GameMetadata.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMetaData = true;
        result.metaData_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMetaData(global::com.richardpianka.chess.network.GameMetadata value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMetaData &&
            result.metaData_ != global::com.richardpianka.chess.network.GameMetadata.DefaultInstance) {
            result.metaData_ = global::com.richardpianka.chess.network.GameMetadata.CreateBuilder(result.metaData_).MergeFrom(value).BuildPartial();
        } else {
          result.metaData_ = value;
        }
        result.hasMetaData = true;
        return this;
      }
      public Builder ClearMetaData() {
        PrepareBuilder();
        result.hasMetaData = false;
        result.metaData_ = null;
        return this;
      }
    }
    static Game() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GameMetadata : pb::GeneratedMessage<GameMetadata, GameMetadata.Builder> {
    private GameMetadata() { }
    private static readonly GameMetadata defaultInstance = new GameMetadata().MakeReadOnly();
    private static readonly string[] _gameMetadataFieldNames = new string[] { "Created", "Joined", "UserTime" };
    private static readonly uint[] _gameMetadataFieldTags = new uint[] { 10, 18, 26 };
    public static GameMetadata DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameMetadata DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameMetadata ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_GameMetadata__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameMetadata, GameMetadata.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_GameMetadata__FieldAccessorTable; }
    }
    
    public const int CreatedFieldNumber = 1;
    private bool hasCreated;
    private global::com.richardpianka.chess.network.User created_;
    public bool HasCreated {
      get { return hasCreated; }
    }
    public global::com.richardpianka.chess.network.User Created {
      get { return created_ ?? global::com.richardpianka.chess.network.User.DefaultInstance; }
    }
    
    public const int JoinedFieldNumber = 2;
    private bool hasJoined;
    private global::com.richardpianka.chess.network.User joined_;
    public bool HasJoined {
      get { return hasJoined; }
    }
    public global::com.richardpianka.chess.network.User Joined {
      get { return joined_ ?? global::com.richardpianka.chess.network.User.DefaultInstance; }
    }
    
    public const int UserTimeFieldNumber = 3;
    private bool hasUserTime;
    private global::com.richardpianka.chess.network.UserTime userTime_;
    public bool HasUserTime {
      get { return hasUserTime; }
    }
    public global::com.richardpianka.chess.network.UserTime UserTime {
      get { return userTime_ ?? global::com.richardpianka.chess.network.UserTime.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasCreated) {
          if (!Created.IsInitialized) return false;
        }
        if (HasJoined) {
          if (!Joined.IsInitialized) return false;
        }
        if (HasUserTime) {
          if (!UserTime.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gameMetadataFieldNames;
      if (hasCreated) {
        output.WriteMessage(1, field_names[0], Created);
      }
      if (hasJoined) {
        output.WriteMessage(2, field_names[1], Joined);
      }
      if (hasUserTime) {
        output.WriteMessage(3, field_names[2], UserTime);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCreated) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Created);
        }
        if (hasJoined) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Joined);
        }
        if (hasUserTime) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, UserTime);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GameMetadata ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameMetadata ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameMetadata ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameMetadata ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameMetadata ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameMetadata ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameMetadata ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameMetadata ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameMetadata ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameMetadata ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameMetadata MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameMetadata prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GameMetadata, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameMetadata cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameMetadata result;
      
      private GameMetadata PrepareBuilder() {
        if (resultIsReadOnly) {
          GameMetadata original = result;
          result = new GameMetadata();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameMetadata MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.GameMetadata.Descriptor; }
      }
      
      public override GameMetadata DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.GameMetadata.DefaultInstance; }
      }
      
      public override GameMetadata BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameMetadata) {
          return MergeFrom((GameMetadata) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameMetadata other) {
        if (other == global::com.richardpianka.chess.network.GameMetadata.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCreated) {
          MergeCreated(other.Created);
        }
        if (other.HasJoined) {
          MergeJoined(other.Joined);
        }
        if (other.HasUserTime) {
          MergeUserTime(other.UserTime);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameMetadataFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameMetadataFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.User.Builder subBuilder = global::com.richardpianka.chess.network.User.CreateBuilder();
              if (result.hasCreated) {
                subBuilder.MergeFrom(Created);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Created = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::com.richardpianka.chess.network.User.Builder subBuilder = global::com.richardpianka.chess.network.User.CreateBuilder();
              if (result.hasJoined) {
                subBuilder.MergeFrom(Joined);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Joined = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::com.richardpianka.chess.network.UserTime.Builder subBuilder = global::com.richardpianka.chess.network.UserTime.CreateBuilder();
              if (result.hasUserTime) {
                subBuilder.MergeFrom(UserTime);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              UserTime = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCreated {
       get { return result.hasCreated; }
      }
      public global::com.richardpianka.chess.network.User Created {
        get { return result.Created; }
        set { SetCreated(value); }
      }
      public Builder SetCreated(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCreated = true;
        result.created_ = value;
        return this;
      }
      public Builder SetCreated(global::com.richardpianka.chess.network.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCreated = true;
        result.created_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCreated(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCreated &&
            result.created_ != global::com.richardpianka.chess.network.User.DefaultInstance) {
            result.created_ = global::com.richardpianka.chess.network.User.CreateBuilder(result.created_).MergeFrom(value).BuildPartial();
        } else {
          result.created_ = value;
        }
        result.hasCreated = true;
        return this;
      }
      public Builder ClearCreated() {
        PrepareBuilder();
        result.hasCreated = false;
        result.created_ = null;
        return this;
      }
      
      public bool HasJoined {
       get { return result.hasJoined; }
      }
      public global::com.richardpianka.chess.network.User Joined {
        get { return result.Joined; }
        set { SetJoined(value); }
      }
      public Builder SetJoined(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoined = true;
        result.joined_ = value;
        return this;
      }
      public Builder SetJoined(global::com.richardpianka.chess.network.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoined = true;
        result.joined_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoined(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoined &&
            result.joined_ != global::com.richardpianka.chess.network.User.DefaultInstance) {
            result.joined_ = global::com.richardpianka.chess.network.User.CreateBuilder(result.joined_).MergeFrom(value).BuildPartial();
        } else {
          result.joined_ = value;
        }
        result.hasJoined = true;
        return this;
      }
      public Builder ClearJoined() {
        PrepareBuilder();
        result.hasJoined = false;
        result.joined_ = null;
        return this;
      }
      
      public bool HasUserTime {
       get { return result.hasUserTime; }
      }
      public global::com.richardpianka.chess.network.UserTime UserTime {
        get { return result.UserTime; }
        set { SetUserTime(value); }
      }
      public Builder SetUserTime(global::com.richardpianka.chess.network.UserTime value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUserTime = true;
        result.userTime_ = value;
        return this;
      }
      public Builder SetUserTime(global::com.richardpianka.chess.network.UserTime.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasUserTime = true;
        result.userTime_ = builderForValue.Build();
        return this;
      }
      public Builder MergeUserTime(global::com.richardpianka.chess.network.UserTime value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasUserTime &&
            result.userTime_ != global::com.richardpianka.chess.network.UserTime.DefaultInstance) {
            result.userTime_ = global::com.richardpianka.chess.network.UserTime.CreateBuilder(result.userTime_).MergeFrom(value).BuildPartial();
        } else {
          result.userTime_ = value;
        }
        result.hasUserTime = true;
        return this;
      }
      public Builder ClearUserTime() {
        PrepareBuilder();
        result.hasUserTime = false;
        result.userTime_ = null;
        return this;
      }
    }
    static GameMetadata() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class UserTime : pb::GeneratedMessage<UserTime, UserTime.Builder> {
    private UserTime() { }
    private static readonly UserTime defaultInstance = new UserTime().MakeReadOnly();
    private static readonly string[] _userTimeFieldNames = new string[] { "SecondsPerUser", "Timed" };
    private static readonly uint[] _userTimeFieldTags = new uint[] { 16, 8 };
    public static UserTime DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override UserTime DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override UserTime ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_UserTime__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<UserTime, UserTime.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_UserTime__FieldAccessorTable; }
    }
    
    public const int TimedFieldNumber = 1;
    private bool hasTimed;
    private bool timed_;
    public bool HasTimed {
      get { return hasTimed; }
    }
    public bool Timed {
      get { return timed_; }
    }
    
    public const int SecondsPerUserFieldNumber = 2;
    private bool hasSecondsPerUser;
    private uint secondsPerUser_;
    public bool HasSecondsPerUser {
      get { return hasSecondsPerUser; }
    }
    [global::System.CLSCompliant(false)]
    public uint SecondsPerUser {
      get { return secondsPerUser_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasTimed) return false;
        if (!hasSecondsPerUser) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _userTimeFieldNames;
      if (hasTimed) {
        output.WriteBool(1, field_names[1], Timed);
      }
      if (hasSecondsPerUser) {
        output.WriteUInt32(2, field_names[0], SecondsPerUser);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasTimed) {
          size += pb::CodedOutputStream.ComputeBoolSize(1, Timed);
        }
        if (hasSecondsPerUser) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, SecondsPerUser);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static UserTime ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static UserTime ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static UserTime ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static UserTime ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static UserTime ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static UserTime ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static UserTime ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static UserTime ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static UserTime ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static UserTime ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private UserTime MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(UserTime prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<UserTime, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(UserTime cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private UserTime result;
      
      private UserTime PrepareBuilder() {
        if (resultIsReadOnly) {
          UserTime original = result;
          result = new UserTime();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override UserTime MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.UserTime.Descriptor; }
      }
      
      public override UserTime DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.UserTime.DefaultInstance; }
      }
      
      public override UserTime BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is UserTime) {
          return MergeFrom((UserTime) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(UserTime other) {
        if (other == global::com.richardpianka.chess.network.UserTime.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTimed) {
          Timed = other.Timed;
        }
        if (other.HasSecondsPerUser) {
          SecondsPerUser = other.SecondsPerUser;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_userTimeFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _userTimeFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasTimed = input.ReadBool(ref result.timed_);
              break;
            }
            case 16: {
              result.hasSecondsPerUser = input.ReadUInt32(ref result.secondsPerUser_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTimed {
        get { return result.hasTimed; }
      }
      public bool Timed {
        get { return result.Timed; }
        set { SetTimed(value); }
      }
      public Builder SetTimed(bool value) {
        PrepareBuilder();
        result.hasTimed = true;
        result.timed_ = value;
        return this;
      }
      public Builder ClearTimed() {
        PrepareBuilder();
        result.hasTimed = false;
        result.timed_ = false;
        return this;
      }
      
      public bool HasSecondsPerUser {
        get { return result.hasSecondsPerUser; }
      }
      [global::System.CLSCompliant(false)]
      public uint SecondsPerUser {
        get { return result.SecondsPerUser; }
        set { SetSecondsPerUser(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetSecondsPerUser(uint value) {
        PrepareBuilder();
        result.hasSecondsPerUser = true;
        result.secondsPerUser_ = value;
        return this;
      }
      public Builder ClearSecondsPerUser() {
        PrepareBuilder();
        result.hasSecondsPerUser = false;
        result.secondsPerUser_ = 0;
        return this;
      }
    }
    static UserTime() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class HandshakeRequest : pb::GeneratedMessage<HandshakeRequest, HandshakeRequest.Builder> {
    private HandshakeRequest() { }
    private static readonly HandshakeRequest defaultInstance = new HandshakeRequest().MakeReadOnly();
    private static readonly string[] _handshakeRequestFieldNames = new string[] { "Version" };
    private static readonly uint[] _handshakeRequestFieldTags = new uint[] { 10 };
    public static HandshakeRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HandshakeRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HandshakeRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_HandshakeRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HandshakeRequest, HandshakeRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_HandshakeRequest__FieldAccessorTable; }
    }
    
    public const int VersionFieldNumber = 1;
    private bool hasVersion;
    private global::com.richardpianka.chess.network.Version version_;
    public bool HasVersion {
      get { return hasVersion; }
    }
    public global::com.richardpianka.chess.network.Version Version {
      get { return version_ ?? global::com.richardpianka.chess.network.Version.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasVersion) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _handshakeRequestFieldNames;
      if (hasVersion) {
        output.WriteMessage(1, field_names[0], Version);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasVersion) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Version);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static HandshakeRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HandshakeRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HandshakeRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HandshakeRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HandshakeRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HandshakeRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<HandshakeRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HandshakeRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HandshakeRequest result;
      
      private HandshakeRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          HandshakeRequest original = result;
          result = new HandshakeRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HandshakeRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.HandshakeRequest.Descriptor; }
      }
      
      public override HandshakeRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.HandshakeRequest.DefaultInstance; }
      }
      
      public override HandshakeRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HandshakeRequest) {
          return MergeFrom((HandshakeRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HandshakeRequest other) {
        if (other == global::com.richardpianka.chess.network.HandshakeRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasVersion) {
          MergeVersion(other.Version);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_handshakeRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _handshakeRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.Version.Builder subBuilder = global::com.richardpianka.chess.network.Version.CreateBuilder();
              if (result.hasVersion) {
                subBuilder.MergeFrom(Version);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Version = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasVersion {
       get { return result.hasVersion; }
      }
      public global::com.richardpianka.chess.network.Version Version {
        get { return result.Version; }
        set { SetVersion(value); }
      }
      public Builder SetVersion(global::com.richardpianka.chess.network.Version value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasVersion = true;
        result.version_ = value;
        return this;
      }
      public Builder SetVersion(global::com.richardpianka.chess.network.Version.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasVersion = true;
        result.version_ = builderForValue.Build();
        return this;
      }
      public Builder MergeVersion(global::com.richardpianka.chess.network.Version value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasVersion &&
            result.version_ != global::com.richardpianka.chess.network.Version.DefaultInstance) {
            result.version_ = global::com.richardpianka.chess.network.Version.CreateBuilder(result.version_).MergeFrom(value).BuildPartial();
        } else {
          result.version_ = value;
        }
        result.hasVersion = true;
        return this;
      }
      public Builder ClearVersion() {
        PrepareBuilder();
        result.hasVersion = false;
        result.version_ = null;
        return this;
      }
    }
    static HandshakeRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class HandshakeResponse : pb::GeneratedMessage<HandshakeResponse, HandshakeResponse.Builder> {
    private HandshakeResponse() { }
    private static readonly HandshakeResponse defaultInstance = new HandshakeResponse().MakeReadOnly();
    private static readonly string[] _handshakeResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _handshakeResponseFieldTags = new uint[] { 8 };
    public static HandshakeResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HandshakeResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HandshakeResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_HandshakeResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HandshakeResponse, HandshakeResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_HandshakeResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::com.richardpianka.chess.network.Result result_ = global::com.richardpianka.chess.network.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::com.richardpianka.chess.network.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _handshakeResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static HandshakeResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HandshakeResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HandshakeResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HandshakeResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HandshakeResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HandshakeResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<HandshakeResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HandshakeResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HandshakeResponse result;
      
      private HandshakeResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          HandshakeResponse original = result;
          result = new HandshakeResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HandshakeResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.HandshakeResponse.Descriptor; }
      }
      
      public override HandshakeResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.HandshakeResponse.DefaultInstance; }
      }
      
      public override HandshakeResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HandshakeResponse) {
          return MergeFrom((HandshakeResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HandshakeResponse other) {
        if (other == global::com.richardpianka.chess.network.HandshakeResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_handshakeResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _handshakeResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::com.richardpianka.chess.network.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::com.richardpianka.chess.network.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::com.richardpianka.chess.network.Result.Success;
        return this;
      }
    }
    static HandshakeResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class IdentifyRequest : pb::GeneratedMessage<IdentifyRequest, IdentifyRequest.Builder> {
    private IdentifyRequest() { }
    private static readonly IdentifyRequest defaultInstance = new IdentifyRequest().MakeReadOnly();
    private static readonly string[] _identifyRequestFieldNames = new string[] { "Password", "Username" };
    private static readonly uint[] _identifyRequestFieldTags = new uint[] { 18, 10 };
    public static IdentifyRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override IdentifyRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override IdentifyRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_IdentifyRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<IdentifyRequest, IdentifyRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_IdentifyRequest__FieldAccessorTable; }
    }
    
    public const int UsernameFieldNumber = 1;
    private bool hasUsername;
    private string username_ = "";
    public bool HasUsername {
      get { return hasUsername; }
    }
    public string Username {
      get { return username_; }
    }
    
    public const int PasswordFieldNumber = 2;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasUsername) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _identifyRequestFieldNames;
      if (hasUsername) {
        output.WriteString(1, field_names[1], Username);
      }
      if (hasPassword) {
        output.WriteString(2, field_names[0], Password);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasUsername) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Username);
        }
        if (hasPassword) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Password);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static IdentifyRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static IdentifyRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static IdentifyRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static IdentifyRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private IdentifyRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(IdentifyRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<IdentifyRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(IdentifyRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private IdentifyRequest result;
      
      private IdentifyRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          IdentifyRequest original = result;
          result = new IdentifyRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override IdentifyRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.IdentifyRequest.Descriptor; }
      }
      
      public override IdentifyRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.IdentifyRequest.DefaultInstance; }
      }
      
      public override IdentifyRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is IdentifyRequest) {
          return MergeFrom((IdentifyRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(IdentifyRequest other) {
        if (other == global::com.richardpianka.chess.network.IdentifyRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasUsername) {
          Username = other.Username;
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_identifyRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _identifyRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasUsername = input.ReadString(ref result.username_);
              break;
            }
            case 18: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasUsername {
        get { return result.hasUsername; }
      }
      public string Username {
        get { return result.Username; }
        set { SetUsername(value); }
      }
      public Builder SetUsername(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUsername = true;
        result.username_ = value;
        return this;
      }
      public Builder ClearUsername() {
        PrepareBuilder();
        result.hasUsername = false;
        result.username_ = "";
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
    }
    static IdentifyRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class IdentifyResponse : pb::GeneratedMessage<IdentifyResponse, IdentifyResponse.Builder> {
    private IdentifyResponse() { }
    private static readonly IdentifyResponse defaultInstance = new IdentifyResponse().MakeReadOnly();
    private static readonly string[] _identifyResponseFieldNames = new string[] { "Message", "Result" };
    private static readonly uint[] _identifyResponseFieldTags = new uint[] { 18, 8 };
    public static IdentifyResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override IdentifyResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override IdentifyResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_IdentifyResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<IdentifyResponse, IdentifyResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_IdentifyResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::com.richardpianka.chess.network.Result result_ = global::com.richardpianka.chess.network.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::com.richardpianka.chess.network.Result Result {
      get { return result_; }
    }
    
    public const int MessageFieldNumber = 2;
    private bool hasMessage;
    private string message_ = "";
    public bool HasMessage {
      get { return hasMessage; }
    }
    public string Message {
      get { return message_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _identifyResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[1], (int) Result, Result);
      }
      if (hasMessage) {
        output.WriteString(2, field_names[0], Message);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Message);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static IdentifyResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static IdentifyResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static IdentifyResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static IdentifyResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private IdentifyResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(IdentifyResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<IdentifyResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(IdentifyResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private IdentifyResponse result;
      
      private IdentifyResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          IdentifyResponse original = result;
          result = new IdentifyResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override IdentifyResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.IdentifyResponse.Descriptor; }
      }
      
      public override IdentifyResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.IdentifyResponse.DefaultInstance; }
      }
      
      public override IdentifyResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is IdentifyResponse) {
          return MergeFrom((IdentifyResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(IdentifyResponse other) {
        if (other == global::com.richardpianka.chess.network.IdentifyResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        if (other.HasMessage) {
          Message = other.Message;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_identifyResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _identifyResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              result.hasMessage = input.ReadString(ref result.message_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::com.richardpianka.chess.network.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::com.richardpianka.chess.network.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::com.richardpianka.chess.network.Result.Success;
        return this;
      }
      
      public bool HasMessage {
        get { return result.hasMessage; }
      }
      public string Message {
        get { return result.Message; }
        set { SetMessage(value); }
      }
      public Builder SetMessage(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessage = true;
        result.message_ = value;
        return this;
      }
      public Builder ClearMessage() {
        PrepareBuilder();
        result.hasMessage = false;
        result.message_ = "";
        return this;
      }
    }
    static IdentifyResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinChatRequest : pb::GeneratedMessage<JoinChatRequest, JoinChatRequest.Builder> {
    private JoinChatRequest() { }
    private static readonly JoinChatRequest defaultInstance = new JoinChatRequest().MakeReadOnly();
    private static readonly string[] _joinChatRequestFieldNames = new string[] {  };
    private static readonly uint[] _joinChatRequestFieldTags = new uint[] {  };
    public static JoinChatRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinChatRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinChatRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinChatRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinChatRequest, JoinChatRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinChatRequest__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinChatRequestFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinChatRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinChatRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinChatRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinChatRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinChatRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinChatRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinChatRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinChatRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinChatRequest result;
      
      private JoinChatRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinChatRequest original = result;
          result = new JoinChatRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinChatRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.JoinChatRequest.Descriptor; }
      }
      
      public override JoinChatRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.JoinChatRequest.DefaultInstance; }
      }
      
      public override JoinChatRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinChatRequest) {
          return MergeFrom((JoinChatRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinChatRequest other) {
        if (other == global::com.richardpianka.chess.network.JoinChatRequest.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinChatRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinChatRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static JoinChatRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinChatResponse : pb::GeneratedMessage<JoinChatResponse, JoinChatResponse.Builder> {
    private JoinChatResponse() { }
    private static readonly JoinChatResponse defaultInstance = new JoinChatResponse().MakeReadOnly();
    private static readonly string[] _joinChatResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _joinChatResponseFieldTags = new uint[] { 8 };
    public static JoinChatResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinChatResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinChatResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinChatResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinChatResponse, JoinChatResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinChatResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::com.richardpianka.chess.network.Result result_ = global::com.richardpianka.chess.network.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::com.richardpianka.chess.network.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinChatResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinChatResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinChatResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinChatResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinChatResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinChatResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinChatResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinChatResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinChatResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinChatResponse result;
      
      private JoinChatResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinChatResponse original = result;
          result = new JoinChatResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinChatResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.JoinChatResponse.Descriptor; }
      }
      
      public override JoinChatResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.JoinChatResponse.DefaultInstance; }
      }
      
      public override JoinChatResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinChatResponse) {
          return MergeFrom((JoinChatResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinChatResponse other) {
        if (other == global::com.richardpianka.chess.network.JoinChatResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinChatResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinChatResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::com.richardpianka.chess.network.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::com.richardpianka.chess.network.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::com.richardpianka.chess.network.Result.Success;
        return this;
      }
    }
    static JoinChatResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class RoomListRequest : pb::GeneratedMessage<RoomListRequest, RoomListRequest.Builder> {
    private RoomListRequest() { }
    private static readonly RoomListRequest defaultInstance = new RoomListRequest().MakeReadOnly();
    private static readonly string[] _roomListRequestFieldNames = new string[] {  };
    private static readonly uint[] _roomListRequestFieldTags = new uint[] {  };
    public static RoomListRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override RoomListRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override RoomListRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_RoomListRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<RoomListRequest, RoomListRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_RoomListRequest__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _roomListRequestFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static RoomListRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static RoomListRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static RoomListRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static RoomListRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RoomListRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private RoomListRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(RoomListRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<RoomListRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(RoomListRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private RoomListRequest result;
      
      private RoomListRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          RoomListRequest original = result;
          result = new RoomListRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override RoomListRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.RoomListRequest.Descriptor; }
      }
      
      public override RoomListRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.RoomListRequest.DefaultInstance; }
      }
      
      public override RoomListRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is RoomListRequest) {
          return MergeFrom((RoomListRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(RoomListRequest other) {
        if (other == global::com.richardpianka.chess.network.RoomListRequest.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_roomListRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _roomListRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static RoomListRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class RoomListResponse : pb::GeneratedMessage<RoomListResponse, RoomListResponse.Builder> {
    private RoomListResponse() { }
    private static readonly RoomListResponse defaultInstance = new RoomListResponse().MakeReadOnly();
    private static readonly string[] _roomListResponseFieldNames = new string[] { "Rooms" };
    private static readonly uint[] _roomListResponseFieldTags = new uint[] { 10 };
    public static RoomListResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override RoomListResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override RoomListResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_RoomListResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<RoomListResponse, RoomListResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_RoomListResponse__FieldAccessorTable; }
    }
    
    public const int RoomsFieldNumber = 1;
    private pbc::PopsicleList<global::com.richardpianka.chess.network.Room> rooms_ = new pbc::PopsicleList<global::com.richardpianka.chess.network.Room>();
    public scg::IList<global::com.richardpianka.chess.network.Room> RoomsList {
      get { return rooms_; }
    }
    public int RoomsCount {
      get { return rooms_.Count; }
    }
    public global::com.richardpianka.chess.network.Room GetRooms(int index) {
      return rooms_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::com.richardpianka.chess.network.Room element in RoomsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _roomListResponseFieldNames;
      if (rooms_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], rooms_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::com.richardpianka.chess.network.Room element in RoomsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static RoomListResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static RoomListResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static RoomListResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static RoomListResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RoomListResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private RoomListResponse MakeReadOnly() {
      rooms_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(RoomListResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<RoomListResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(RoomListResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private RoomListResponse result;
      
      private RoomListResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          RoomListResponse original = result;
          result = new RoomListResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override RoomListResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.RoomListResponse.Descriptor; }
      }
      
      public override RoomListResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.RoomListResponse.DefaultInstance; }
      }
      
      public override RoomListResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is RoomListResponse) {
          return MergeFrom((RoomListResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(RoomListResponse other) {
        if (other == global::com.richardpianka.chess.network.RoomListResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.rooms_.Count != 0) {
          result.rooms_.Add(other.rooms_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_roomListResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _roomListResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.rooms_, global::com.richardpianka.chess.network.Room.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::com.richardpianka.chess.network.Room> RoomsList {
        get { return PrepareBuilder().rooms_; }
      }
      public int RoomsCount {
        get { return result.RoomsCount; }
      }
      public global::com.richardpianka.chess.network.Room GetRooms(int index) {
        return result.GetRooms(index);
      }
      public Builder SetRooms(int index, global::com.richardpianka.chess.network.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rooms_[index] = value;
        return this;
      }
      public Builder SetRooms(int index, global::com.richardpianka.chess.network.Room.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rooms_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddRooms(global::com.richardpianka.chess.network.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rooms_.Add(value);
        return this;
      }
      public Builder AddRooms(global::com.richardpianka.chess.network.Room.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rooms_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeRooms(scg::IEnumerable<global::com.richardpianka.chess.network.Room> values) {
        PrepareBuilder();
        result.rooms_.Add(values);
        return this;
      }
      public Builder ClearRooms() {
        PrepareBuilder();
        result.rooms_.Clear();
        return this;
      }
    }
    static RoomListResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinRoomRequest : pb::GeneratedMessage<JoinRoomRequest, JoinRoomRequest.Builder> {
    private JoinRoomRequest() { }
    private static readonly JoinRoomRequest defaultInstance = new JoinRoomRequest().MakeReadOnly();
    private static readonly string[] _joinRoomRequestFieldNames = new string[] { "Room" };
    private static readonly uint[] _joinRoomRequestFieldTags = new uint[] { 10 };
    public static JoinRoomRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinRoomRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinRoomRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinRoomRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinRoomRequest, JoinRoomRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinRoomRequest__FieldAccessorTable; }
    }
    
    public const int RoomFieldNumber = 1;
    private bool hasRoom;
    private global::com.richardpianka.chess.network.Room room_;
    public bool HasRoom {
      get { return hasRoom; }
    }
    public global::com.richardpianka.chess.network.Room Room {
      get { return room_ ?? global::com.richardpianka.chess.network.Room.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRoom) return false;
        if (!Room.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinRoomRequestFieldNames;
      if (hasRoom) {
        output.WriteMessage(1, field_names[0], Room);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRoom) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Room);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinRoomRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinRoomRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinRoomRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinRoomRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinRoomRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinRoomRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinRoomRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinRoomRequest result;
      
      private JoinRoomRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinRoomRequest original = result;
          result = new JoinRoomRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinRoomRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.JoinRoomRequest.Descriptor; }
      }
      
      public override JoinRoomRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.JoinRoomRequest.DefaultInstance; }
      }
      
      public override JoinRoomRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinRoomRequest) {
          return MergeFrom((JoinRoomRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinRoomRequest other) {
        if (other == global::com.richardpianka.chess.network.JoinRoomRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRoom) {
          MergeRoom(other.Room);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinRoomRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinRoomRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.Room.Builder subBuilder = global::com.richardpianka.chess.network.Room.CreateBuilder();
              if (result.hasRoom) {
                subBuilder.MergeFrom(Room);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Room = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRoom {
       get { return result.hasRoom; }
      }
      public global::com.richardpianka.chess.network.Room Room {
        get { return result.Room; }
        set { SetRoom(value); }
      }
      public Builder SetRoom(global::com.richardpianka.chess.network.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRoom = true;
        result.room_ = value;
        return this;
      }
      public Builder SetRoom(global::com.richardpianka.chess.network.Room.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRoom = true;
        result.room_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRoom(global::com.richardpianka.chess.network.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRoom &&
            result.room_ != global::com.richardpianka.chess.network.Room.DefaultInstance) {
            result.room_ = global::com.richardpianka.chess.network.Room.CreateBuilder(result.room_).MergeFrom(value).BuildPartial();
        } else {
          result.room_ = value;
        }
        result.hasRoom = true;
        return this;
      }
      public Builder ClearRoom() {
        PrepareBuilder();
        result.hasRoom = false;
        result.room_ = null;
        return this;
      }
    }
    static JoinRoomRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinRoomResponse : pb::GeneratedMessage<JoinRoomResponse, JoinRoomResponse.Builder> {
    private JoinRoomResponse() { }
    private static readonly JoinRoomResponse defaultInstance = new JoinRoomResponse().MakeReadOnly();
    private static readonly string[] _joinRoomResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _joinRoomResponseFieldTags = new uint[] { 8 };
    public static JoinRoomResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinRoomResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinRoomResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinRoomResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinRoomResponse, JoinRoomResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinRoomResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::com.richardpianka.chess.network.Result result_ = global::com.richardpianka.chess.network.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::com.richardpianka.chess.network.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinRoomResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinRoomResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinRoomResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinRoomResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinRoomResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinRoomResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinRoomResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinRoomResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinRoomResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinRoomResponse result;
      
      private JoinRoomResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinRoomResponse original = result;
          result = new JoinRoomResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinRoomResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.JoinRoomResponse.Descriptor; }
      }
      
      public override JoinRoomResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.JoinRoomResponse.DefaultInstance; }
      }
      
      public override JoinRoomResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinRoomResponse) {
          return MergeFrom((JoinRoomResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinRoomResponse other) {
        if (other == global::com.richardpianka.chess.network.JoinRoomResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinRoomResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinRoomResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::com.richardpianka.chess.network.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::com.richardpianka.chess.network.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::com.richardpianka.chess.network.Result.Success;
        return this;
      }
    }
    static JoinRoomResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class SpeakRequest : pb::GeneratedMessage<SpeakRequest, SpeakRequest.Builder> {
    private SpeakRequest() { }
    private static readonly SpeakRequest defaultInstance = new SpeakRequest().MakeReadOnly();
    private static readonly string[] _speakRequestFieldNames = new string[] { "Message", "Mode", "Recipient" };
    private static readonly uint[] _speakRequestFieldTags = new uint[] { 18, 8, 26 };
    public static SpeakRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SpeakRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SpeakRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_SpeakRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SpeakRequest, SpeakRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_SpeakRequest__FieldAccessorTable; }
    }
    
    public const int ModeFieldNumber = 1;
    private bool hasMode;
    private global::com.richardpianka.chess.network.SpeakMode mode_ = global::com.richardpianka.chess.network.SpeakMode.Normal;
    public bool HasMode {
      get { return hasMode; }
    }
    public global::com.richardpianka.chess.network.SpeakMode Mode {
      get { return mode_; }
    }
    
    public const int MessageFieldNumber = 2;
    private bool hasMessage;
    private string message_ = "";
    public bool HasMessage {
      get { return hasMessage; }
    }
    public string Message {
      get { return message_; }
    }
    
    public const int RecipientFieldNumber = 3;
    private bool hasRecipient;
    private global::com.richardpianka.chess.network.User recipient_;
    public bool HasRecipient {
      get { return hasRecipient; }
    }
    public global::com.richardpianka.chess.network.User Recipient {
      get { return recipient_ ?? global::com.richardpianka.chess.network.User.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasMode) return false;
        if (!hasMessage) return false;
        if (HasRecipient) {
          if (!Recipient.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _speakRequestFieldNames;
      if (hasMode) {
        output.WriteEnum(1, field_names[1], (int) Mode, Mode);
      }
      if (hasMessage) {
        output.WriteString(2, field_names[0], Message);
      }
      if (hasRecipient) {
        output.WriteMessage(3, field_names[2], Recipient);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasMode) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Mode);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Message);
        }
        if (hasRecipient) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Recipient);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SpeakRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SpeakRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SpeakRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SpeakRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpeakRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SpeakRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SpeakRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<SpeakRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SpeakRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SpeakRequest result;
      
      private SpeakRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          SpeakRequest original = result;
          result = new SpeakRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SpeakRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.SpeakRequest.Descriptor; }
      }
      
      public override SpeakRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.SpeakRequest.DefaultInstance; }
      }
      
      public override SpeakRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SpeakRequest) {
          return MergeFrom((SpeakRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SpeakRequest other) {
        if (other == global::com.richardpianka.chess.network.SpeakRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasMode) {
          Mode = other.Mode;
        }
        if (other.HasMessage) {
          Message = other.Message;
        }
        if (other.HasRecipient) {
          MergeRecipient(other.Recipient);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_speakRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _speakRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.mode_, out unknown)) {
                result.hasMode = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              result.hasMessage = input.ReadString(ref result.message_);
              break;
            }
            case 26: {
              global::com.richardpianka.chess.network.User.Builder subBuilder = global::com.richardpianka.chess.network.User.CreateBuilder();
              if (result.hasRecipient) {
                subBuilder.MergeFrom(Recipient);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Recipient = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasMode {
       get { return result.hasMode; }
      }
      public global::com.richardpianka.chess.network.SpeakMode Mode {
        get { return result.Mode; }
        set { SetMode(value); }
      }
      public Builder SetMode(global::com.richardpianka.chess.network.SpeakMode value) {
        PrepareBuilder();
        result.hasMode = true;
        result.mode_ = value;
        return this;
      }
      public Builder ClearMode() {
        PrepareBuilder();
        result.hasMode = false;
        result.mode_ = global::com.richardpianka.chess.network.SpeakMode.Normal;
        return this;
      }
      
      public bool HasMessage {
        get { return result.hasMessage; }
      }
      public string Message {
        get { return result.Message; }
        set { SetMessage(value); }
      }
      public Builder SetMessage(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessage = true;
        result.message_ = value;
        return this;
      }
      public Builder ClearMessage() {
        PrepareBuilder();
        result.hasMessage = false;
        result.message_ = "";
        return this;
      }
      
      public bool HasRecipient {
       get { return result.hasRecipient; }
      }
      public global::com.richardpianka.chess.network.User Recipient {
        get { return result.Recipient; }
        set { SetRecipient(value); }
      }
      public Builder SetRecipient(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRecipient = true;
        result.recipient_ = value;
        return this;
      }
      public Builder SetRecipient(global::com.richardpianka.chess.network.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRecipient = true;
        result.recipient_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRecipient(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRecipient &&
            result.recipient_ != global::com.richardpianka.chess.network.User.DefaultInstance) {
            result.recipient_ = global::com.richardpianka.chess.network.User.CreateBuilder(result.recipient_).MergeFrom(value).BuildPartial();
        } else {
          result.recipient_ = value;
        }
        result.hasRecipient = true;
        return this;
      }
      public Builder ClearRecipient() {
        PrepareBuilder();
        result.hasRecipient = false;
        result.recipient_ = null;
        return this;
      }
    }
    static SpeakRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class OperatorRequest : pb::GeneratedMessage<OperatorRequest, OperatorRequest.Builder> {
    private OperatorRequest() { }
    private static readonly OperatorRequest defaultInstance = new OperatorRequest().MakeReadOnly();
    private static readonly string[] _operatorRequestFieldNames = new string[] { "Action", "User" };
    private static readonly uint[] _operatorRequestFieldTags = new uint[] { 8, 18 };
    public static OperatorRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override OperatorRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override OperatorRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_OperatorRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<OperatorRequest, OperatorRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_OperatorRequest__FieldAccessorTable; }
    }
    
    public const int ActionFieldNumber = 1;
    private bool hasAction;
    private global::com.richardpianka.chess.network.OperatorAction action_ = global::com.richardpianka.chess.network.OperatorAction.Designate;
    public bool HasAction {
      get { return hasAction; }
    }
    public global::com.richardpianka.chess.network.OperatorAction Action {
      get { return action_; }
    }
    
    public const int UserFieldNumber = 2;
    private bool hasUser;
    private global::com.richardpianka.chess.network.User user_;
    public bool HasUser {
      get { return hasUser; }
    }
    public global::com.richardpianka.chess.network.User User {
      get { return user_ ?? global::com.richardpianka.chess.network.User.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasAction) return false;
        if (HasUser) {
          if (!User.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _operatorRequestFieldNames;
      if (hasAction) {
        output.WriteEnum(1, field_names[0], (int) Action, Action);
      }
      if (hasUser) {
        output.WriteMessage(2, field_names[1], User);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasAction) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Action);
        }
        if (hasUser) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, User);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static OperatorRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static OperatorRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static OperatorRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static OperatorRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OperatorRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private OperatorRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(OperatorRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<OperatorRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(OperatorRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private OperatorRequest result;
      
      private OperatorRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          OperatorRequest original = result;
          result = new OperatorRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override OperatorRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.OperatorRequest.Descriptor; }
      }
      
      public override OperatorRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.OperatorRequest.DefaultInstance; }
      }
      
      public override OperatorRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is OperatorRequest) {
          return MergeFrom((OperatorRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(OperatorRequest other) {
        if (other == global::com.richardpianka.chess.network.OperatorRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasAction) {
          Action = other.Action;
        }
        if (other.HasUser) {
          MergeUser(other.User);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_operatorRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _operatorRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.action_, out unknown)) {
                result.hasAction = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              global::com.richardpianka.chess.network.User.Builder subBuilder = global::com.richardpianka.chess.network.User.CreateBuilder();
              if (result.hasUser) {
                subBuilder.MergeFrom(User);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              User = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasAction {
       get { return result.hasAction; }
      }
      public global::com.richardpianka.chess.network.OperatorAction Action {
        get { return result.Action; }
        set { SetAction(value); }
      }
      public Builder SetAction(global::com.richardpianka.chess.network.OperatorAction value) {
        PrepareBuilder();
        result.hasAction = true;
        result.action_ = value;
        return this;
      }
      public Builder ClearAction() {
        PrepareBuilder();
        result.hasAction = false;
        result.action_ = global::com.richardpianka.chess.network.OperatorAction.Designate;
        return this;
      }
      
      public bool HasUser {
       get { return result.hasUser; }
      }
      public global::com.richardpianka.chess.network.User User {
        get { return result.User; }
        set { SetUser(value); }
      }
      public Builder SetUser(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = value;
        return this;
      }
      public Builder SetUser(global::com.richardpianka.chess.network.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = builderForValue.Build();
        return this;
      }
      public Builder MergeUser(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasUser &&
            result.user_ != global::com.richardpianka.chess.network.User.DefaultInstance) {
            result.user_ = global::com.richardpianka.chess.network.User.CreateBuilder(result.user_).MergeFrom(value).BuildPartial();
        } else {
          result.user_ = value;
        }
        result.hasUser = true;
        return this;
      }
      public Builder ClearUser() {
        PrepareBuilder();
        result.hasUser = false;
        result.user_ = null;
        return this;
      }
    }
    static OperatorRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class OperatorResponse : pb::GeneratedMessage<OperatorResponse, OperatorResponse.Builder> {
    private OperatorResponse() { }
    private static readonly OperatorResponse defaultInstance = new OperatorResponse().MakeReadOnly();
    private static readonly string[] _operatorResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _operatorResponseFieldTags = new uint[] { 8 };
    public static OperatorResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override OperatorResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override OperatorResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_OperatorResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<OperatorResponse, OperatorResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_OperatorResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::com.richardpianka.chess.network.Result result_ = global::com.richardpianka.chess.network.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::com.richardpianka.chess.network.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _operatorResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static OperatorResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static OperatorResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static OperatorResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static OperatorResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OperatorResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private OperatorResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(OperatorResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<OperatorResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(OperatorResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private OperatorResponse result;
      
      private OperatorResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          OperatorResponse original = result;
          result = new OperatorResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override OperatorResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.OperatorResponse.Descriptor; }
      }
      
      public override OperatorResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.OperatorResponse.DefaultInstance; }
      }
      
      public override OperatorResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is OperatorResponse) {
          return MergeFrom((OperatorResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(OperatorResponse other) {
        if (other == global::com.richardpianka.chess.network.OperatorResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_operatorResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _operatorResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::com.richardpianka.chess.network.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::com.richardpianka.chess.network.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::com.richardpianka.chess.network.Result.Success;
        return this;
      }
    }
    static OperatorResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ChatRoomEvent : pb::GeneratedMessage<ChatRoomEvent, ChatRoomEvent.Builder> {
    private ChatRoomEvent() { }
    private static readonly ChatRoomEvent defaultInstance = new ChatRoomEvent().MakeReadOnly();
    private static readonly string[] _chatRoomEventFieldNames = new string[] { "Room", "Users" };
    private static readonly uint[] _chatRoomEventFieldTags = new uint[] { 10, 18 };
    public static ChatRoomEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ChatRoomEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ChatRoomEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_ChatRoomEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ChatRoomEvent, ChatRoomEvent.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_ChatRoomEvent__FieldAccessorTable; }
    }
    
    public const int RoomFieldNumber = 1;
    private bool hasRoom;
    private global::com.richardpianka.chess.network.Room room_;
    public bool HasRoom {
      get { return hasRoom; }
    }
    public global::com.richardpianka.chess.network.Room Room {
      get { return room_ ?? global::com.richardpianka.chess.network.Room.DefaultInstance; }
    }
    
    public const int UsersFieldNumber = 2;
    private pbc::PopsicleList<global::com.richardpianka.chess.network.User> users_ = new pbc::PopsicleList<global::com.richardpianka.chess.network.User>();
    public scg::IList<global::com.richardpianka.chess.network.User> UsersList {
      get { return users_; }
    }
    public int UsersCount {
      get { return users_.Count; }
    }
    public global::com.richardpianka.chess.network.User GetUsers(int index) {
      return users_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRoom) return false;
        if (!Room.IsInitialized) return false;
        foreach (global::com.richardpianka.chess.network.User element in UsersList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _chatRoomEventFieldNames;
      if (hasRoom) {
        output.WriteMessage(1, field_names[0], Room);
      }
      if (users_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], users_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRoom) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Room);
        }
        foreach (global::com.richardpianka.chess.network.User element in UsersList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ChatRoomEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ChatRoomEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ChatRoomEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatRoomEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ChatRoomEvent MakeReadOnly() {
      users_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ChatRoomEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ChatRoomEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ChatRoomEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ChatRoomEvent result;
      
      private ChatRoomEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          ChatRoomEvent original = result;
          result = new ChatRoomEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ChatRoomEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.ChatRoomEvent.Descriptor; }
      }
      
      public override ChatRoomEvent DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.ChatRoomEvent.DefaultInstance; }
      }
      
      public override ChatRoomEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ChatRoomEvent) {
          return MergeFrom((ChatRoomEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ChatRoomEvent other) {
        if (other == global::com.richardpianka.chess.network.ChatRoomEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRoom) {
          MergeRoom(other.Room);
        }
        if (other.users_.Count != 0) {
          result.users_.Add(other.users_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_chatRoomEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _chatRoomEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.Room.Builder subBuilder = global::com.richardpianka.chess.network.Room.CreateBuilder();
              if (result.hasRoom) {
                subBuilder.MergeFrom(Room);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Room = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.users_, global::com.richardpianka.chess.network.User.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRoom {
       get { return result.hasRoom; }
      }
      public global::com.richardpianka.chess.network.Room Room {
        get { return result.Room; }
        set { SetRoom(value); }
      }
      public Builder SetRoom(global::com.richardpianka.chess.network.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRoom = true;
        result.room_ = value;
        return this;
      }
      public Builder SetRoom(global::com.richardpianka.chess.network.Room.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRoom = true;
        result.room_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRoom(global::com.richardpianka.chess.network.Room value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRoom &&
            result.room_ != global::com.richardpianka.chess.network.Room.DefaultInstance) {
            result.room_ = global::com.richardpianka.chess.network.Room.CreateBuilder(result.room_).MergeFrom(value).BuildPartial();
        } else {
          result.room_ = value;
        }
        result.hasRoom = true;
        return this;
      }
      public Builder ClearRoom() {
        PrepareBuilder();
        result.hasRoom = false;
        result.room_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::com.richardpianka.chess.network.User> UsersList {
        get { return PrepareBuilder().users_; }
      }
      public int UsersCount {
        get { return result.UsersCount; }
      }
      public global::com.richardpianka.chess.network.User GetUsers(int index) {
        return result.GetUsers(index);
      }
      public Builder SetUsers(int index, global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.users_[index] = value;
        return this;
      }
      public Builder SetUsers(int index, global::com.richardpianka.chess.network.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.users_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddUsers(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.users_.Add(value);
        return this;
      }
      public Builder AddUsers(global::com.richardpianka.chess.network.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.users_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeUsers(scg::IEnumerable<global::com.richardpianka.chess.network.User> values) {
        PrepareBuilder();
        result.users_.Add(values);
        return this;
      }
      public Builder ClearUsers() {
        PrepareBuilder();
        result.users_.Clear();
        return this;
      }
    }
    static ChatRoomEvent() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ChatUserEvent : pb::GeneratedMessage<ChatUserEvent, ChatUserEvent.Builder> {
    private ChatUserEvent() { }
    private static readonly ChatUserEvent defaultInstance = new ChatUserEvent().MakeReadOnly();
    private static readonly string[] _chatUserEventFieldNames = new string[] { "Message", "Status", "User" };
    private static readonly uint[] _chatUserEventFieldTags = new uint[] { 26, 16, 10 };
    public static ChatUserEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ChatUserEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ChatUserEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_ChatUserEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ChatUserEvent, ChatUserEvent.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_ChatUserEvent__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public static class Types {
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
      public enum UserStatus {
        Joined = 0,
        Left = 1,
        Update = 2,
      }
      
    }
    #endregion
    
    public const int UserFieldNumber = 1;
    private bool hasUser;
    private global::com.richardpianka.chess.network.User user_;
    public bool HasUser {
      get { return hasUser; }
    }
    public global::com.richardpianka.chess.network.User User {
      get { return user_ ?? global::com.richardpianka.chess.network.User.DefaultInstance; }
    }
    
    public const int StatusFieldNumber = 2;
    private bool hasStatus;
    private global::com.richardpianka.chess.network.ChatUserEvent.Types.UserStatus status_ = global::com.richardpianka.chess.network.ChatUserEvent.Types.UserStatus.Joined;
    public bool HasStatus {
      get { return hasStatus; }
    }
    public global::com.richardpianka.chess.network.ChatUserEvent.Types.UserStatus Status {
      get { return status_; }
    }
    
    public const int MessageFieldNumber = 3;
    private bool hasMessage;
    private string message_ = "";
    public bool HasMessage {
      get { return hasMessage; }
    }
    public string Message {
      get { return message_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasUser) return false;
        if (!hasStatus) return false;
        if (!User.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _chatUserEventFieldNames;
      if (hasUser) {
        output.WriteMessage(1, field_names[2], User);
      }
      if (hasStatus) {
        output.WriteEnum(2, field_names[1], (int) Status, Status);
      }
      if (hasMessage) {
        output.WriteString(3, field_names[0], Message);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasUser) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, User);
        }
        if (hasStatus) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Status);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Message);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ChatUserEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ChatUserEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ChatUserEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatUserEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ChatUserEvent MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ChatUserEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ChatUserEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ChatUserEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ChatUserEvent result;
      
      private ChatUserEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          ChatUserEvent original = result;
          result = new ChatUserEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ChatUserEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.ChatUserEvent.Descriptor; }
      }
      
      public override ChatUserEvent DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.ChatUserEvent.DefaultInstance; }
      }
      
      public override ChatUserEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ChatUserEvent) {
          return MergeFrom((ChatUserEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ChatUserEvent other) {
        if (other == global::com.richardpianka.chess.network.ChatUserEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasUser) {
          MergeUser(other.User);
        }
        if (other.HasStatus) {
          Status = other.Status;
        }
        if (other.HasMessage) {
          Message = other.Message;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_chatUserEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _chatUserEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.User.Builder subBuilder = global::com.richardpianka.chess.network.User.CreateBuilder();
              if (result.hasUser) {
                subBuilder.MergeFrom(User);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              User = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.status_, out unknown)) {
                result.hasStatus = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 26: {
              result.hasMessage = input.ReadString(ref result.message_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasUser {
       get { return result.hasUser; }
      }
      public global::com.richardpianka.chess.network.User User {
        get { return result.User; }
        set { SetUser(value); }
      }
      public Builder SetUser(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = value;
        return this;
      }
      public Builder SetUser(global::com.richardpianka.chess.network.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = builderForValue.Build();
        return this;
      }
      public Builder MergeUser(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasUser &&
            result.user_ != global::com.richardpianka.chess.network.User.DefaultInstance) {
            result.user_ = global::com.richardpianka.chess.network.User.CreateBuilder(result.user_).MergeFrom(value).BuildPartial();
        } else {
          result.user_ = value;
        }
        result.hasUser = true;
        return this;
      }
      public Builder ClearUser() {
        PrepareBuilder();
        result.hasUser = false;
        result.user_ = null;
        return this;
      }
      
      public bool HasStatus {
       get { return result.hasStatus; }
      }
      public global::com.richardpianka.chess.network.ChatUserEvent.Types.UserStatus Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(global::com.richardpianka.chess.network.ChatUserEvent.Types.UserStatus value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = global::com.richardpianka.chess.network.ChatUserEvent.Types.UserStatus.Joined;
        return this;
      }
      
      public bool HasMessage {
        get { return result.hasMessage; }
      }
      public string Message {
        get { return result.Message; }
        set { SetMessage(value); }
      }
      public Builder SetMessage(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessage = true;
        result.message_ = value;
        return this;
      }
      public Builder ClearMessage() {
        PrepareBuilder();
        result.hasMessage = false;
        result.message_ = "";
        return this;
      }
    }
    static ChatUserEvent() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ChatSpeakEvent : pb::GeneratedMessage<ChatSpeakEvent, ChatSpeakEvent.Builder> {
    private ChatSpeakEvent() { }
    private static readonly ChatSpeakEvent defaultInstance = new ChatSpeakEvent().MakeReadOnly();
    private static readonly string[] _chatSpeakEventFieldNames = new string[] { "Message", "Mode", "User" };
    private static readonly uint[] _chatSpeakEventFieldTags = new uint[] { 18, 24, 10 };
    public static ChatSpeakEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ChatSpeakEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ChatSpeakEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_ChatSpeakEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ChatSpeakEvent, ChatSpeakEvent.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_ChatSpeakEvent__FieldAccessorTable; }
    }
    
    public const int UserFieldNumber = 1;
    private bool hasUser;
    private global::com.richardpianka.chess.network.User user_;
    public bool HasUser {
      get { return hasUser; }
    }
    public global::com.richardpianka.chess.network.User User {
      get { return user_ ?? global::com.richardpianka.chess.network.User.DefaultInstance; }
    }
    
    public const int MessageFieldNumber = 2;
    private bool hasMessage;
    private string message_ = "";
    public bool HasMessage {
      get { return hasMessage; }
    }
    public string Message {
      get { return message_; }
    }
    
    public const int ModeFieldNumber = 3;
    private bool hasMode;
    private global::com.richardpianka.chess.network.SpeakMode mode_ = global::com.richardpianka.chess.network.SpeakMode.Normal;
    public bool HasMode {
      get { return hasMode; }
    }
    public global::com.richardpianka.chess.network.SpeakMode Mode {
      get { return mode_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasUser) return false;
        if (!hasMessage) return false;
        if (!hasMode) return false;
        if (!User.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _chatSpeakEventFieldNames;
      if (hasUser) {
        output.WriteMessage(1, field_names[2], User);
      }
      if (hasMessage) {
        output.WriteString(2, field_names[0], Message);
      }
      if (hasMode) {
        output.WriteEnum(3, field_names[1], (int) Mode, Mode);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasUser) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, User);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Message);
        }
        if (hasMode) {
          size += pb::CodedOutputStream.ComputeEnumSize(3, (int) Mode);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ChatSpeakEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ChatSpeakEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ChatSpeakEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ChatSpeakEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ChatSpeakEvent MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ChatSpeakEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ChatSpeakEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ChatSpeakEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ChatSpeakEvent result;
      
      private ChatSpeakEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          ChatSpeakEvent original = result;
          result = new ChatSpeakEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ChatSpeakEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.ChatSpeakEvent.Descriptor; }
      }
      
      public override ChatSpeakEvent DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.ChatSpeakEvent.DefaultInstance; }
      }
      
      public override ChatSpeakEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ChatSpeakEvent) {
          return MergeFrom((ChatSpeakEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ChatSpeakEvent other) {
        if (other == global::com.richardpianka.chess.network.ChatSpeakEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasUser) {
          MergeUser(other.User);
        }
        if (other.HasMessage) {
          Message = other.Message;
        }
        if (other.HasMode) {
          Mode = other.Mode;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_chatSpeakEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _chatSpeakEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.User.Builder subBuilder = global::com.richardpianka.chess.network.User.CreateBuilder();
              if (result.hasUser) {
                subBuilder.MergeFrom(User);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              User = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              result.hasMessage = input.ReadString(ref result.message_);
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.mode_, out unknown)) {
                result.hasMode = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasUser {
       get { return result.hasUser; }
      }
      public global::com.richardpianka.chess.network.User User {
        get { return result.User; }
        set { SetUser(value); }
      }
      public Builder SetUser(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = value;
        return this;
      }
      public Builder SetUser(global::com.richardpianka.chess.network.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = builderForValue.Build();
        return this;
      }
      public Builder MergeUser(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasUser &&
            result.user_ != global::com.richardpianka.chess.network.User.DefaultInstance) {
            result.user_ = global::com.richardpianka.chess.network.User.CreateBuilder(result.user_).MergeFrom(value).BuildPartial();
        } else {
          result.user_ = value;
        }
        result.hasUser = true;
        return this;
      }
      public Builder ClearUser() {
        PrepareBuilder();
        result.hasUser = false;
        result.user_ = null;
        return this;
      }
      
      public bool HasMessage {
        get { return result.hasMessage; }
      }
      public string Message {
        get { return result.Message; }
        set { SetMessage(value); }
      }
      public Builder SetMessage(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessage = true;
        result.message_ = value;
        return this;
      }
      public Builder ClearMessage() {
        PrepareBuilder();
        result.hasMessage = false;
        result.message_ = "";
        return this;
      }
      
      public bool HasMode {
       get { return result.hasMode; }
      }
      public global::com.richardpianka.chess.network.SpeakMode Mode {
        get { return result.Mode; }
        set { SetMode(value); }
      }
      public Builder SetMode(global::com.richardpianka.chess.network.SpeakMode value) {
        PrepareBuilder();
        result.hasMode = true;
        result.mode_ = value;
        return this;
      }
      public Builder ClearMode() {
        PrepareBuilder();
        result.hasMode = false;
        result.mode_ = global::com.richardpianka.chess.network.SpeakMode.Normal;
        return this;
      }
    }
    static ChatSpeakEvent() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GameListRequest : pb::GeneratedMessage<GameListRequest, GameListRequest.Builder> {
    private GameListRequest() { }
    private static readonly GameListRequest defaultInstance = new GameListRequest().MakeReadOnly();
    private static readonly string[] _gameListRequestFieldNames = new string[] {  };
    private static readonly uint[] _gameListRequestFieldTags = new uint[] {  };
    public static GameListRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameListRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameListRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_GameListRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameListRequest, GameListRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_GameListRequest__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gameListRequestFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GameListRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameListRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameListRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameListRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameListRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameListRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameListRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameListRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameListRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameListRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameListRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameListRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GameListRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameListRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameListRequest result;
      
      private GameListRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          GameListRequest original = result;
          result = new GameListRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameListRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.GameListRequest.Descriptor; }
      }
      
      public override GameListRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.GameListRequest.DefaultInstance; }
      }
      
      public override GameListRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameListRequest) {
          return MergeFrom((GameListRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameListRequest other) {
        if (other == global::com.richardpianka.chess.network.GameListRequest.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameListRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameListRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static GameListRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GameListResponse : pb::GeneratedMessage<GameListResponse, GameListResponse.Builder> {
    private GameListResponse() { }
    private static readonly GameListResponse defaultInstance = new GameListResponse().MakeReadOnly();
    private static readonly string[] _gameListResponseFieldNames = new string[] { "Games" };
    private static readonly uint[] _gameListResponseFieldTags = new uint[] { 10 };
    public static GameListResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameListResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameListResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_GameListResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameListResponse, GameListResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_GameListResponse__FieldAccessorTable; }
    }
    
    public const int GamesFieldNumber = 1;
    private pbc::PopsicleList<global::com.richardpianka.chess.network.Game> games_ = new pbc::PopsicleList<global::com.richardpianka.chess.network.Game>();
    public scg::IList<global::com.richardpianka.chess.network.Game> GamesList {
      get { return games_; }
    }
    public int GamesCount {
      get { return games_.Count; }
    }
    public global::com.richardpianka.chess.network.Game GetGames(int index) {
      return games_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::com.richardpianka.chess.network.Game element in GamesList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gameListResponseFieldNames;
      if (games_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], games_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::com.richardpianka.chess.network.Game element in GamesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GameListResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameListResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameListResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameListResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameListResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameListResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameListResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameListResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameListResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameListResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameListResponse MakeReadOnly() {
      games_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameListResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GameListResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameListResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameListResponse result;
      
      private GameListResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          GameListResponse original = result;
          result = new GameListResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameListResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.GameListResponse.Descriptor; }
      }
      
      public override GameListResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.GameListResponse.DefaultInstance; }
      }
      
      public override GameListResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameListResponse) {
          return MergeFrom((GameListResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameListResponse other) {
        if (other == global::com.richardpianka.chess.network.GameListResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.games_.Count != 0) {
          result.games_.Add(other.games_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameListResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameListResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.games_, global::com.richardpianka.chess.network.Game.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::com.richardpianka.chess.network.Game> GamesList {
        get { return PrepareBuilder().games_; }
      }
      public int GamesCount {
        get { return result.GamesCount; }
      }
      public global::com.richardpianka.chess.network.Game GetGames(int index) {
        return result.GetGames(index);
      }
      public Builder SetGames(int index, global::com.richardpianka.chess.network.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.games_[index] = value;
        return this;
      }
      public Builder SetGames(int index, global::com.richardpianka.chess.network.Game.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.games_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddGames(global::com.richardpianka.chess.network.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.games_.Add(value);
        return this;
      }
      public Builder AddGames(global::com.richardpianka.chess.network.Game.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.games_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeGames(scg::IEnumerable<global::com.richardpianka.chess.network.Game> values) {
        PrepareBuilder();
        result.games_.Add(values);
        return this;
      }
      public Builder ClearGames() {
        PrepareBuilder();
        result.games_.Clear();
        return this;
      }
    }
    static GameListResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class CreateGameRequest : pb::GeneratedMessage<CreateGameRequest, CreateGameRequest.Builder> {
    private CreateGameRequest() { }
    private static readonly CreateGameRequest defaultInstance = new CreateGameRequest().MakeReadOnly();
    private static readonly string[] _createGameRequestFieldNames = new string[] { "Name", "Password" };
    private static readonly uint[] _createGameRequestFieldTags = new uint[] { 10, 18 };
    public static CreateGameRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CreateGameRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CreateGameRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_CreateGameRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CreateGameRequest, CreateGameRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_CreateGameRequest__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int PasswordFieldNumber = 2;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _createGameRequestFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[0], Name);
      }
      if (hasPassword) {
        output.WriteString(2, field_names[1], Password);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Name);
        }
        if (hasPassword) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Password);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CreateGameRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CreateGameRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CreateGameRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CreateGameRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CreateGameRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CreateGameRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<CreateGameRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CreateGameRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CreateGameRequest result;
      
      private CreateGameRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          CreateGameRequest original = result;
          result = new CreateGameRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CreateGameRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.CreateGameRequest.Descriptor; }
      }
      
      public override CreateGameRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.CreateGameRequest.DefaultInstance; }
      }
      
      public override CreateGameRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CreateGameRequest) {
          return MergeFrom((CreateGameRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CreateGameRequest other) {
        if (other == global::com.richardpianka.chess.network.CreateGameRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_createGameRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _createGameRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
    }
    static CreateGameRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class CreateGameResponse : pb::GeneratedMessage<CreateGameResponse, CreateGameResponse.Builder> {
    private CreateGameResponse() { }
    private static readonly CreateGameResponse defaultInstance = new CreateGameResponse().MakeReadOnly();
    private static readonly string[] _createGameResponseFieldNames = new string[] { "Game", "Message", "Result" };
    private static readonly uint[] _createGameResponseFieldTags = new uint[] { 18, 26, 8 };
    public static CreateGameResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CreateGameResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CreateGameResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_CreateGameResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CreateGameResponse, CreateGameResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_CreateGameResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::com.richardpianka.chess.network.Result result_ = global::com.richardpianka.chess.network.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::com.richardpianka.chess.network.Result Result {
      get { return result_; }
    }
    
    public const int GameFieldNumber = 2;
    private bool hasGame;
    private global::com.richardpianka.chess.network.Game game_;
    public bool HasGame {
      get { return hasGame; }
    }
    public global::com.richardpianka.chess.network.Game Game {
      get { return game_ ?? global::com.richardpianka.chess.network.Game.DefaultInstance; }
    }
    
    public const int MessageFieldNumber = 3;
    private bool hasMessage;
    private string message_ = "";
    public bool HasMessage {
      get { return hasMessage; }
    }
    public string Message {
      get { return message_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        if (HasGame) {
          if (!Game.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _createGameResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[2], (int) Result, Result);
      }
      if (hasGame) {
        output.WriteMessage(2, field_names[0], Game);
      }
      if (hasMessage) {
        output.WriteString(3, field_names[1], Message);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        if (hasGame) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Game);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Message);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CreateGameResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CreateGameResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CreateGameResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CreateGameResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CreateGameResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CreateGameResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<CreateGameResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CreateGameResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CreateGameResponse result;
      
      private CreateGameResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          CreateGameResponse original = result;
          result = new CreateGameResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CreateGameResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.CreateGameResponse.Descriptor; }
      }
      
      public override CreateGameResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.CreateGameResponse.DefaultInstance; }
      }
      
      public override CreateGameResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CreateGameResponse) {
          return MergeFrom((CreateGameResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CreateGameResponse other) {
        if (other == global::com.richardpianka.chess.network.CreateGameResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        if (other.HasGame) {
          MergeGame(other.Game);
        }
        if (other.HasMessage) {
          Message = other.Message;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_createGameResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _createGameResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              global::com.richardpianka.chess.network.Game.Builder subBuilder = global::com.richardpianka.chess.network.Game.CreateBuilder();
              if (result.hasGame) {
                subBuilder.MergeFrom(Game);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Game = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              result.hasMessage = input.ReadString(ref result.message_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::com.richardpianka.chess.network.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::com.richardpianka.chess.network.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::com.richardpianka.chess.network.Result.Success;
        return this;
      }
      
      public bool HasGame {
       get { return result.hasGame; }
      }
      public global::com.richardpianka.chess.network.Game Game {
        get { return result.Game; }
        set { SetGame(value); }
      }
      public Builder SetGame(global::com.richardpianka.chess.network.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGame = true;
        result.game_ = value;
        return this;
      }
      public Builder SetGame(global::com.richardpianka.chess.network.Game.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGame = true;
        result.game_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGame(global::com.richardpianka.chess.network.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGame &&
            result.game_ != global::com.richardpianka.chess.network.Game.DefaultInstance) {
            result.game_ = global::com.richardpianka.chess.network.Game.CreateBuilder(result.game_).MergeFrom(value).BuildPartial();
        } else {
          result.game_ = value;
        }
        result.hasGame = true;
        return this;
      }
      public Builder ClearGame() {
        PrepareBuilder();
        result.hasGame = false;
        result.game_ = null;
        return this;
      }
      
      public bool HasMessage {
        get { return result.hasMessage; }
      }
      public string Message {
        get { return result.Message; }
        set { SetMessage(value); }
      }
      public Builder SetMessage(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMessage = true;
        result.message_ = value;
        return this;
      }
      public Builder ClearMessage() {
        PrepareBuilder();
        result.hasMessage = false;
        result.message_ = "";
        return this;
      }
    }
    static CreateGameResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinGameRequest : pb::GeneratedMessage<JoinGameRequest, JoinGameRequest.Builder> {
    private JoinGameRequest() { }
    private static readonly JoinGameRequest defaultInstance = new JoinGameRequest().MakeReadOnly();
    private static readonly string[] _joinGameRequestFieldNames = new string[] { "Game", "Password" };
    private static readonly uint[] _joinGameRequestFieldTags = new uint[] { 10, 18 };
    public static JoinGameRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinGameRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinGameRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinGameRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinGameRequest, JoinGameRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinGameRequest__FieldAccessorTable; }
    }
    
    public const int GameFieldNumber = 1;
    private bool hasGame;
    private global::com.richardpianka.chess.network.Game game_;
    public bool HasGame {
      get { return hasGame; }
    }
    public global::com.richardpianka.chess.network.Game Game {
      get { return game_ ?? global::com.richardpianka.chess.network.Game.DefaultInstance; }
    }
    
    public const int PasswordFieldNumber = 2;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasGame) return false;
        if (!Game.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinGameRequestFieldNames;
      if (hasGame) {
        output.WriteMessage(1, field_names[0], Game);
      }
      if (hasPassword) {
        output.WriteString(2, field_names[1], Password);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasGame) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Game);
        }
        if (hasPassword) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Password);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinGameRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinGameRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinGameRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinGameRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinGameRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinGameRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinGameRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinGameRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinGameRequest result;
      
      private JoinGameRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinGameRequest original = result;
          result = new JoinGameRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinGameRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.JoinGameRequest.Descriptor; }
      }
      
      public override JoinGameRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.JoinGameRequest.DefaultInstance; }
      }
      
      public override JoinGameRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinGameRequest) {
          return MergeFrom((JoinGameRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinGameRequest other) {
        if (other == global::com.richardpianka.chess.network.JoinGameRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasGame) {
          MergeGame(other.Game);
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinGameRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinGameRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.Game.Builder subBuilder = global::com.richardpianka.chess.network.Game.CreateBuilder();
              if (result.hasGame) {
                subBuilder.MergeFrom(Game);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Game = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasGame {
       get { return result.hasGame; }
      }
      public global::com.richardpianka.chess.network.Game Game {
        get { return result.Game; }
        set { SetGame(value); }
      }
      public Builder SetGame(global::com.richardpianka.chess.network.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGame = true;
        result.game_ = value;
        return this;
      }
      public Builder SetGame(global::com.richardpianka.chess.network.Game.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGame = true;
        result.game_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGame(global::com.richardpianka.chess.network.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGame &&
            result.game_ != global::com.richardpianka.chess.network.Game.DefaultInstance) {
            result.game_ = global::com.richardpianka.chess.network.Game.CreateBuilder(result.game_).MergeFrom(value).BuildPartial();
        } else {
          result.game_ = value;
        }
        result.hasGame = true;
        return this;
      }
      public Builder ClearGame() {
        PrepareBuilder();
        result.hasGame = false;
        result.game_ = null;
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
    }
    static JoinGameRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class JoinGameResponse : pb::GeneratedMessage<JoinGameResponse, JoinGameResponse.Builder> {
    private JoinGameResponse() { }
    private static readonly JoinGameResponse defaultInstance = new JoinGameResponse().MakeReadOnly();
    private static readonly string[] _joinGameResponseFieldNames = new string[] { "Game", "Result" };
    private static readonly uint[] _joinGameResponseFieldTags = new uint[] { 10, 16 };
    public static JoinGameResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override JoinGameResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override JoinGameResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinGameResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<JoinGameResponse, JoinGameResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_JoinGameResponse__FieldAccessorTable; }
    }
    
    public const int GameFieldNumber = 1;
    private bool hasGame;
    private global::com.richardpianka.chess.network.Game game_;
    public bool HasGame {
      get { return hasGame; }
    }
    public global::com.richardpianka.chess.network.Game Game {
      get { return game_ ?? global::com.richardpianka.chess.network.Game.DefaultInstance; }
    }
    
    public const int ResultFieldNumber = 2;
    private bool hasResult;
    private global::com.richardpianka.chess.network.Result result_ = global::com.richardpianka.chess.network.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::com.richardpianka.chess.network.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasGame) return false;
        if (!hasResult) return false;
        if (!Game.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _joinGameResponseFieldNames;
      if (hasGame) {
        output.WriteMessage(1, field_names[0], Game);
      }
      if (hasResult) {
        output.WriteEnum(2, field_names[1], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasGame) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Game);
        }
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static JoinGameResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static JoinGameResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static JoinGameResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static JoinGameResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private JoinGameResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(JoinGameResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<JoinGameResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(JoinGameResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private JoinGameResponse result;
      
      private JoinGameResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          JoinGameResponse original = result;
          result = new JoinGameResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override JoinGameResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.JoinGameResponse.Descriptor; }
      }
      
      public override JoinGameResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.JoinGameResponse.DefaultInstance; }
      }
      
      public override JoinGameResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is JoinGameResponse) {
          return MergeFrom((JoinGameResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(JoinGameResponse other) {
        if (other == global::com.richardpianka.chess.network.JoinGameResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasGame) {
          MergeGame(other.Game);
        }
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_joinGameResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _joinGameResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.Game.Builder subBuilder = global::com.richardpianka.chess.network.Game.CreateBuilder();
              if (result.hasGame) {
                subBuilder.MergeFrom(Game);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Game = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasGame {
       get { return result.hasGame; }
      }
      public global::com.richardpianka.chess.network.Game Game {
        get { return result.Game; }
        set { SetGame(value); }
      }
      public Builder SetGame(global::com.richardpianka.chess.network.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGame = true;
        result.game_ = value;
        return this;
      }
      public Builder SetGame(global::com.richardpianka.chess.network.Game.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGame = true;
        result.game_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGame(global::com.richardpianka.chess.network.Game value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGame &&
            result.game_ != global::com.richardpianka.chess.network.Game.DefaultInstance) {
            result.game_ = global::com.richardpianka.chess.network.Game.CreateBuilder(result.game_).MergeFrom(value).BuildPartial();
        } else {
          result.game_ = value;
        }
        result.hasGame = true;
        return this;
      }
      public Builder ClearGame() {
        PrepareBuilder();
        result.hasGame = false;
        result.game_ = null;
        return this;
      }
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::com.richardpianka.chess.network.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::com.richardpianka.chess.network.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::com.richardpianka.chess.network.Result.Success;
        return this;
      }
    }
    static JoinGameResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class LeaveGameRequest : pb::GeneratedMessage<LeaveGameRequest, LeaveGameRequest.Builder> {
    private LeaveGameRequest() { }
    private static readonly LeaveGameRequest defaultInstance = new LeaveGameRequest().MakeReadOnly();
    private static readonly string[] _leaveGameRequestFieldNames = new string[] {  };
    private static readonly uint[] _leaveGameRequestFieldTags = new uint[] {  };
    public static LeaveGameRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override LeaveGameRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override LeaveGameRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_LeaveGameRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<LeaveGameRequest, LeaveGameRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_LeaveGameRequest__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _leaveGameRequestFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static LeaveGameRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LeaveGameRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LeaveGameRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LeaveGameRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LeaveGameRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LeaveGameRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static LeaveGameRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static LeaveGameRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static LeaveGameRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LeaveGameRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private LeaveGameRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(LeaveGameRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<LeaveGameRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(LeaveGameRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private LeaveGameRequest result;
      
      private LeaveGameRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          LeaveGameRequest original = result;
          result = new LeaveGameRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override LeaveGameRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.LeaveGameRequest.Descriptor; }
      }
      
      public override LeaveGameRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.LeaveGameRequest.DefaultInstance; }
      }
      
      public override LeaveGameRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is LeaveGameRequest) {
          return MergeFrom((LeaveGameRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(LeaveGameRequest other) {
        if (other == global::com.richardpianka.chess.network.LeaveGameRequest.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_leaveGameRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _leaveGameRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static LeaveGameRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class StartGameRequest : pb::GeneratedMessage<StartGameRequest, StartGameRequest.Builder> {
    private StartGameRequest() { }
    private static readonly StartGameRequest defaultInstance = new StartGameRequest().MakeReadOnly();
    private static readonly string[] _startGameRequestFieldNames = new string[] {  };
    private static readonly uint[] _startGameRequestFieldTags = new uint[] {  };
    public static StartGameRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override StartGameRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override StartGameRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_StartGameRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<StartGameRequest, StartGameRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_StartGameRequest__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _startGameRequestFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static StartGameRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static StartGameRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static StartGameRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static StartGameRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static StartGameRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static StartGameRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static StartGameRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static StartGameRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static StartGameRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static StartGameRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private StartGameRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(StartGameRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<StartGameRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(StartGameRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private StartGameRequest result;
      
      private StartGameRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          StartGameRequest original = result;
          result = new StartGameRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override StartGameRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.StartGameRequest.Descriptor; }
      }
      
      public override StartGameRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.StartGameRequest.DefaultInstance; }
      }
      
      public override StartGameRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is StartGameRequest) {
          return MergeFrom((StartGameRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(StartGameRequest other) {
        if (other == global::com.richardpianka.chess.network.StartGameRequest.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_startGameRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _startGameRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static StartGameRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class StartGameResponse : pb::GeneratedMessage<StartGameResponse, StartGameResponse.Builder> {
    private StartGameResponse() { }
    private static readonly StartGameResponse defaultInstance = new StartGameResponse().MakeReadOnly();
    private static readonly string[] _startGameResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _startGameResponseFieldTags = new uint[] { 8 };
    public static StartGameResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override StartGameResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override StartGameResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_StartGameResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<StartGameResponse, StartGameResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_StartGameResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::com.richardpianka.chess.network.Result result_ = global::com.richardpianka.chess.network.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::com.richardpianka.chess.network.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _startGameResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static StartGameResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static StartGameResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static StartGameResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static StartGameResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static StartGameResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static StartGameResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static StartGameResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static StartGameResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static StartGameResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static StartGameResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private StartGameResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(StartGameResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<StartGameResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(StartGameResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private StartGameResponse result;
      
      private StartGameResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          StartGameResponse original = result;
          result = new StartGameResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override StartGameResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.StartGameResponse.Descriptor; }
      }
      
      public override StartGameResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.StartGameResponse.DefaultInstance; }
      }
      
      public override StartGameResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is StartGameResponse) {
          return MergeFrom((StartGameResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(StartGameResponse other) {
        if (other == global::com.richardpianka.chess.network.StartGameResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_startGameResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _startGameResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::com.richardpianka.chess.network.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::com.richardpianka.chess.network.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::com.richardpianka.chess.network.Result.Success;
        return this;
      }
    }
    static StartGameResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GameStartedEvent : pb::GeneratedMessage<GameStartedEvent, GameStartedEvent.Builder> {
    private GameStartedEvent() { }
    private static readonly GameStartedEvent defaultInstance = new GameStartedEvent().MakeReadOnly();
    private static readonly string[] _gameStartedEventFieldNames = new string[] { "Color" };
    private static readonly uint[] _gameStartedEventFieldTags = new uint[] { 8 };
    public static GameStartedEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameStartedEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameStartedEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_GameStartedEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameStartedEvent, GameStartedEvent.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_GameStartedEvent__FieldAccessorTable; }
    }
    
    public const int ColorFieldNumber = 1;
    private bool hasColor;
    private global::com.richardpianka.chess.network.Color color_ = global::com.richardpianka.chess.network.Color.White;
    public bool HasColor {
      get { return hasColor; }
    }
    public global::com.richardpianka.chess.network.Color Color {
      get { return color_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasColor) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gameStartedEventFieldNames;
      if (hasColor) {
        output.WriteEnum(1, field_names[0], (int) Color, Color);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasColor) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Color);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GameStartedEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameStartedEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameStartedEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameStartedEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameStartedEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameStartedEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameStartedEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameStartedEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameStartedEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameStartedEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameStartedEvent MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameStartedEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GameStartedEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameStartedEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameStartedEvent result;
      
      private GameStartedEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          GameStartedEvent original = result;
          result = new GameStartedEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameStartedEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.GameStartedEvent.Descriptor; }
      }
      
      public override GameStartedEvent DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.GameStartedEvent.DefaultInstance; }
      }
      
      public override GameStartedEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameStartedEvent) {
          return MergeFrom((GameStartedEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameStartedEvent other) {
        if (other == global::com.richardpianka.chess.network.GameStartedEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasColor) {
          Color = other.Color;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameStartedEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameStartedEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.color_, out unknown)) {
                result.hasColor = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasColor {
       get { return result.hasColor; }
      }
      public global::com.richardpianka.chess.network.Color Color {
        get { return result.Color; }
        set { SetColor(value); }
      }
      public Builder SetColor(global::com.richardpianka.chess.network.Color value) {
        PrepareBuilder();
        result.hasColor = true;
        result.color_ = value;
        return this;
      }
      public Builder ClearColor() {
        PrepareBuilder();
        result.hasColor = false;
        result.color_ = global::com.richardpianka.chess.network.Color.White;
        return this;
      }
    }
    static GameStartedEvent() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class MovePieceRequest : pb::GeneratedMessage<MovePieceRequest, MovePieceRequest.Builder> {
    private MovePieceRequest() { }
    private static readonly MovePieceRequest defaultInstance = new MovePieceRequest().MakeReadOnly();
    private static readonly string[] _movePieceRequestFieldNames = new string[] { "Move" };
    private static readonly uint[] _movePieceRequestFieldTags = new uint[] { 10 };
    public static MovePieceRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MovePieceRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MovePieceRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_MovePieceRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MovePieceRequest, MovePieceRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_MovePieceRequest__FieldAccessorTable; }
    }
    
    public const int MoveFieldNumber = 1;
    private bool hasMove;
    private global::com.richardpianka.chess.network.Move move_;
    public bool HasMove {
      get { return hasMove; }
    }
    public global::com.richardpianka.chess.network.Move Move {
      get { return move_ ?? global::com.richardpianka.chess.network.Move.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasMove) return false;
        if (!Move.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _movePieceRequestFieldNames;
      if (hasMove) {
        output.WriteMessage(1, field_names[0], Move);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasMove) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Move);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static MovePieceRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MovePieceRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MovePieceRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MovePieceRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MovePieceRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MovePieceRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MovePieceRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MovePieceRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MovePieceRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MovePieceRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MovePieceRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MovePieceRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<MovePieceRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MovePieceRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MovePieceRequest result;
      
      private MovePieceRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          MovePieceRequest original = result;
          result = new MovePieceRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MovePieceRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.MovePieceRequest.Descriptor; }
      }
      
      public override MovePieceRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.MovePieceRequest.DefaultInstance; }
      }
      
      public override MovePieceRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MovePieceRequest) {
          return MergeFrom((MovePieceRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MovePieceRequest other) {
        if (other == global::com.richardpianka.chess.network.MovePieceRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasMove) {
          MergeMove(other.Move);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_movePieceRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _movePieceRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.Move.Builder subBuilder = global::com.richardpianka.chess.network.Move.CreateBuilder();
              if (result.hasMove) {
                subBuilder.MergeFrom(Move);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Move = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasMove {
       get { return result.hasMove; }
      }
      public global::com.richardpianka.chess.network.Move Move {
        get { return result.Move; }
        set { SetMove(value); }
      }
      public Builder SetMove(global::com.richardpianka.chess.network.Move value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMove = true;
        result.move_ = value;
        return this;
      }
      public Builder SetMove(global::com.richardpianka.chess.network.Move.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMove = true;
        result.move_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMove(global::com.richardpianka.chess.network.Move value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMove &&
            result.move_ != global::com.richardpianka.chess.network.Move.DefaultInstance) {
            result.move_ = global::com.richardpianka.chess.network.Move.CreateBuilder(result.move_).MergeFrom(value).BuildPartial();
        } else {
          result.move_ = value;
        }
        result.hasMove = true;
        return this;
      }
      public Builder ClearMove() {
        PrepareBuilder();
        result.hasMove = false;
        result.move_ = null;
        return this;
      }
    }
    static MovePieceRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class MovePieceResponse : pb::GeneratedMessage<MovePieceResponse, MovePieceResponse.Builder> {
    private MovePieceResponse() { }
    private static readonly MovePieceResponse defaultInstance = new MovePieceResponse().MakeReadOnly();
    private static readonly string[] _movePieceResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _movePieceResponseFieldTags = new uint[] { 8 };
    public static MovePieceResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MovePieceResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MovePieceResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_MovePieceResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MovePieceResponse, MovePieceResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_MovePieceResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::com.richardpianka.chess.network.Result result_ = global::com.richardpianka.chess.network.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::com.richardpianka.chess.network.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _movePieceResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static MovePieceResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MovePieceResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MovePieceResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MovePieceResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MovePieceResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MovePieceResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MovePieceResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MovePieceResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MovePieceResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MovePieceResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MovePieceResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MovePieceResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<MovePieceResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MovePieceResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MovePieceResponse result;
      
      private MovePieceResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          MovePieceResponse original = result;
          result = new MovePieceResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MovePieceResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.MovePieceResponse.Descriptor; }
      }
      
      public override MovePieceResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.MovePieceResponse.DefaultInstance; }
      }
      
      public override MovePieceResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MovePieceResponse) {
          return MergeFrom((MovePieceResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MovePieceResponse other) {
        if (other == global::com.richardpianka.chess.network.MovePieceResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_movePieceResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _movePieceResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::com.richardpianka.chess.network.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::com.richardpianka.chess.network.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::com.richardpianka.chess.network.Result.Success;
        return this;
      }
    }
    static MovePieceResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class MovePieceEvent : pb::GeneratedMessage<MovePieceEvent, MovePieceEvent.Builder> {
    private MovePieceEvent() { }
    private static readonly MovePieceEvent defaultInstance = new MovePieceEvent().MakeReadOnly();
    private static readonly string[] _movePieceEventFieldNames = new string[] { "Move" };
    private static readonly uint[] _movePieceEventFieldTags = new uint[] { 10 };
    public static MovePieceEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MovePieceEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MovePieceEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_MovePieceEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MovePieceEvent, MovePieceEvent.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_MovePieceEvent__FieldAccessorTable; }
    }
    
    public const int MoveFieldNumber = 1;
    private bool hasMove;
    private global::com.richardpianka.chess.network.Move move_;
    public bool HasMove {
      get { return hasMove; }
    }
    public global::com.richardpianka.chess.network.Move Move {
      get { return move_ ?? global::com.richardpianka.chess.network.Move.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasMove) return false;
        if (!Move.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _movePieceEventFieldNames;
      if (hasMove) {
        output.WriteMessage(1, field_names[0], Move);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasMove) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Move);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static MovePieceEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MovePieceEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MovePieceEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MovePieceEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MovePieceEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MovePieceEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MovePieceEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MovePieceEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MovePieceEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MovePieceEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MovePieceEvent MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MovePieceEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<MovePieceEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MovePieceEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MovePieceEvent result;
      
      private MovePieceEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          MovePieceEvent original = result;
          result = new MovePieceEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MovePieceEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.MovePieceEvent.Descriptor; }
      }
      
      public override MovePieceEvent DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.MovePieceEvent.DefaultInstance; }
      }
      
      public override MovePieceEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MovePieceEvent) {
          return MergeFrom((MovePieceEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MovePieceEvent other) {
        if (other == global::com.richardpianka.chess.network.MovePieceEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasMove) {
          MergeMove(other.Move);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_movePieceEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _movePieceEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.Move.Builder subBuilder = global::com.richardpianka.chess.network.Move.CreateBuilder();
              if (result.hasMove) {
                subBuilder.MergeFrom(Move);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Move = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasMove {
       get { return result.hasMove; }
      }
      public global::com.richardpianka.chess.network.Move Move {
        get { return result.Move; }
        set { SetMove(value); }
      }
      public Builder SetMove(global::com.richardpianka.chess.network.Move value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMove = true;
        result.move_ = value;
        return this;
      }
      public Builder SetMove(global::com.richardpianka.chess.network.Move.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMove = true;
        result.move_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMove(global::com.richardpianka.chess.network.Move value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMove &&
            result.move_ != global::com.richardpianka.chess.network.Move.DefaultInstance) {
            result.move_ = global::com.richardpianka.chess.network.Move.CreateBuilder(result.move_).MergeFrom(value).BuildPartial();
        } else {
          result.move_ = value;
        }
        result.hasMove = true;
        return this;
      }
      public Builder ClearMove() {
        PrepareBuilder();
        result.hasMove = false;
        result.move_ = null;
        return this;
      }
    }
    static MovePieceEvent() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class SpecialMovePieceRequest : pb::GeneratedMessage<SpecialMovePieceRequest, SpecialMovePieceRequest.Builder> {
    private SpecialMovePieceRequest() { }
    private static readonly SpecialMovePieceRequest defaultInstance = new SpecialMovePieceRequest().MakeReadOnly();
    private static readonly string[] _specialMovePieceRequestFieldNames = new string[] { "Move" };
    private static readonly uint[] _specialMovePieceRequestFieldTags = new uint[] { 10 };
    public static SpecialMovePieceRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SpecialMovePieceRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SpecialMovePieceRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_SpecialMovePieceRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SpecialMovePieceRequest, SpecialMovePieceRequest.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_SpecialMovePieceRequest__FieldAccessorTable; }
    }
    
    public const int MoveFieldNumber = 1;
    private bool hasMove;
    private global::com.richardpianka.chess.network.SpecialMove move_;
    public bool HasMove {
      get { return hasMove; }
    }
    public global::com.richardpianka.chess.network.SpecialMove Move {
      get { return move_ ?? global::com.richardpianka.chess.network.SpecialMove.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasMove) return false;
        if (!Move.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _specialMovePieceRequestFieldNames;
      if (hasMove) {
        output.WriteMessage(1, field_names[0], Move);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasMove) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Move);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SpecialMovePieceRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpecialMovePieceRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpecialMovePieceRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpecialMovePieceRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpecialMovePieceRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpecialMovePieceRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SpecialMovePieceRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SpecialMovePieceRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SpecialMovePieceRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpecialMovePieceRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SpecialMovePieceRequest MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SpecialMovePieceRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<SpecialMovePieceRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SpecialMovePieceRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SpecialMovePieceRequest result;
      
      private SpecialMovePieceRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          SpecialMovePieceRequest original = result;
          result = new SpecialMovePieceRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SpecialMovePieceRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.SpecialMovePieceRequest.Descriptor; }
      }
      
      public override SpecialMovePieceRequest DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.SpecialMovePieceRequest.DefaultInstance; }
      }
      
      public override SpecialMovePieceRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SpecialMovePieceRequest) {
          return MergeFrom((SpecialMovePieceRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SpecialMovePieceRequest other) {
        if (other == global::com.richardpianka.chess.network.SpecialMovePieceRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasMove) {
          MergeMove(other.Move);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_specialMovePieceRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _specialMovePieceRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.SpecialMove.Builder subBuilder = global::com.richardpianka.chess.network.SpecialMove.CreateBuilder();
              if (result.hasMove) {
                subBuilder.MergeFrom(Move);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Move = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasMove {
       get { return result.hasMove; }
      }
      public global::com.richardpianka.chess.network.SpecialMove Move {
        get { return result.Move; }
        set { SetMove(value); }
      }
      public Builder SetMove(global::com.richardpianka.chess.network.SpecialMove value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMove = true;
        result.move_ = value;
        return this;
      }
      public Builder SetMove(global::com.richardpianka.chess.network.SpecialMove.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMove = true;
        result.move_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMove(global::com.richardpianka.chess.network.SpecialMove value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMove &&
            result.move_ != global::com.richardpianka.chess.network.SpecialMove.DefaultInstance) {
            result.move_ = global::com.richardpianka.chess.network.SpecialMove.CreateBuilder(result.move_).MergeFrom(value).BuildPartial();
        } else {
          result.move_ = value;
        }
        result.hasMove = true;
        return this;
      }
      public Builder ClearMove() {
        PrepareBuilder();
        result.hasMove = false;
        result.move_ = null;
        return this;
      }
    }
    static SpecialMovePieceRequest() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class SpecialMovePieceResponse : pb::GeneratedMessage<SpecialMovePieceResponse, SpecialMovePieceResponse.Builder> {
    private SpecialMovePieceResponse() { }
    private static readonly SpecialMovePieceResponse defaultInstance = new SpecialMovePieceResponse().MakeReadOnly();
    private static readonly string[] _specialMovePieceResponseFieldNames = new string[] { "Result" };
    private static readonly uint[] _specialMovePieceResponseFieldTags = new uint[] { 8 };
    public static SpecialMovePieceResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SpecialMovePieceResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SpecialMovePieceResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_SpecialMovePieceResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SpecialMovePieceResponse, SpecialMovePieceResponse.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_SpecialMovePieceResponse__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private global::com.richardpianka.chess.network.Result result_ = global::com.richardpianka.chess.network.Result.Success;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::com.richardpianka.chess.network.Result Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _specialMovePieceResponseFieldNames;
      if (hasResult) {
        output.WriteEnum(1, field_names[0], (int) Result, Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SpecialMovePieceResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpecialMovePieceResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpecialMovePieceResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpecialMovePieceResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpecialMovePieceResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpecialMovePieceResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SpecialMovePieceResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SpecialMovePieceResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SpecialMovePieceResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpecialMovePieceResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SpecialMovePieceResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SpecialMovePieceResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<SpecialMovePieceResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SpecialMovePieceResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SpecialMovePieceResponse result;
      
      private SpecialMovePieceResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          SpecialMovePieceResponse original = result;
          result = new SpecialMovePieceResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SpecialMovePieceResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.SpecialMovePieceResponse.Descriptor; }
      }
      
      public override SpecialMovePieceResponse DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.SpecialMovePieceResponse.DefaultInstance; }
      }
      
      public override SpecialMovePieceResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SpecialMovePieceResponse) {
          return MergeFrom((SpecialMovePieceResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SpecialMovePieceResponse other) {
        if (other == global::com.richardpianka.chess.network.SpecialMovePieceResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_specialMovePieceResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _specialMovePieceResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.result_, out unknown)) {
                result.hasResult = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::com.richardpianka.chess.network.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::com.richardpianka.chess.network.Result value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = global::com.richardpianka.chess.network.Result.Success;
        return this;
      }
    }
    static SpecialMovePieceResponse() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class SpecialMovePieceEvent : pb::GeneratedMessage<SpecialMovePieceEvent, SpecialMovePieceEvent.Builder> {
    private SpecialMovePieceEvent() { }
    private static readonly SpecialMovePieceEvent defaultInstance = new SpecialMovePieceEvent().MakeReadOnly();
    private static readonly string[] _specialMovePieceEventFieldNames = new string[] { "Move" };
    private static readonly uint[] _specialMovePieceEventFieldTags = new uint[] { 10 };
    public static SpecialMovePieceEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SpecialMovePieceEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SpecialMovePieceEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_SpecialMovePieceEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SpecialMovePieceEvent, SpecialMovePieceEvent.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_SpecialMovePieceEvent__FieldAccessorTable; }
    }
    
    public const int MoveFieldNumber = 1;
    private bool hasMove;
    private global::com.richardpianka.chess.network.SpecialMove move_;
    public bool HasMove {
      get { return hasMove; }
    }
    public global::com.richardpianka.chess.network.SpecialMove Move {
      get { return move_ ?? global::com.richardpianka.chess.network.SpecialMove.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasMove) return false;
        if (!Move.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _specialMovePieceEventFieldNames;
      if (hasMove) {
        output.WriteMessage(1, field_names[0], Move);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasMove) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Move);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SpecialMovePieceEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpecialMovePieceEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpecialMovePieceEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SpecialMovePieceEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SpecialMovePieceEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpecialMovePieceEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SpecialMovePieceEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SpecialMovePieceEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SpecialMovePieceEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SpecialMovePieceEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SpecialMovePieceEvent MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SpecialMovePieceEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<SpecialMovePieceEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SpecialMovePieceEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SpecialMovePieceEvent result;
      
      private SpecialMovePieceEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          SpecialMovePieceEvent original = result;
          result = new SpecialMovePieceEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SpecialMovePieceEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.SpecialMovePieceEvent.Descriptor; }
      }
      
      public override SpecialMovePieceEvent DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.SpecialMovePieceEvent.DefaultInstance; }
      }
      
      public override SpecialMovePieceEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SpecialMovePieceEvent) {
          return MergeFrom((SpecialMovePieceEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SpecialMovePieceEvent other) {
        if (other == global::com.richardpianka.chess.network.SpecialMovePieceEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasMove) {
          MergeMove(other.Move);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_specialMovePieceEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _specialMovePieceEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.richardpianka.chess.network.SpecialMove.Builder subBuilder = global::com.richardpianka.chess.network.SpecialMove.CreateBuilder();
              if (result.hasMove) {
                subBuilder.MergeFrom(Move);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Move = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasMove {
       get { return result.hasMove; }
      }
      public global::com.richardpianka.chess.network.SpecialMove Move {
        get { return result.Move; }
        set { SetMove(value); }
      }
      public Builder SetMove(global::com.richardpianka.chess.network.SpecialMove value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMove = true;
        result.move_ = value;
        return this;
      }
      public Builder SetMove(global::com.richardpianka.chess.network.SpecialMove.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMove = true;
        result.move_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMove(global::com.richardpianka.chess.network.SpecialMove value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMove &&
            result.move_ != global::com.richardpianka.chess.network.SpecialMove.DefaultInstance) {
            result.move_ = global::com.richardpianka.chess.network.SpecialMove.CreateBuilder(result.move_).MergeFrom(value).BuildPartial();
        } else {
          result.move_ = value;
        }
        result.hasMove = true;
        return this;
      }
      public Builder ClearMove() {
        PrepareBuilder();
        result.hasMove = false;
        result.move_ = null;
        return this;
      }
    }
    static SpecialMovePieceEvent() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GameStatusEvent : pb::GeneratedMessage<GameStatusEvent, GameStatusEvent.Builder> {
    private GameStatusEvent() { }
    private static readonly GameStatusEvent defaultInstance = new GameStatusEvent().MakeReadOnly();
    private static readonly string[] _gameStatusEventFieldNames = new string[] { "Status", "User" };
    private static readonly uint[] _gameStatusEventFieldTags = new uint[] { 8, 18 };
    public static GameStatusEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameStatusEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameStatusEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_GameStatusEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameStatusEvent, GameStatusEvent.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_GameStatusEvent__FieldAccessorTable; }
    }
    
    public const int StatusFieldNumber = 1;
    private bool hasStatus;
    private global::com.richardpianka.chess.network.GameStatus status_ = global::com.richardpianka.chess.network.GameStatus.Play;
    public bool HasStatus {
      get { return hasStatus; }
    }
    public global::com.richardpianka.chess.network.GameStatus Status {
      get { return status_; }
    }
    
    public const int UserFieldNumber = 2;
    private bool hasUser;
    private global::com.richardpianka.chess.network.User user_;
    public bool HasUser {
      get { return hasUser; }
    }
    public global::com.richardpianka.chess.network.User User {
      get { return user_ ?? global::com.richardpianka.chess.network.User.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasUser) {
          if (!User.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gameStatusEventFieldNames;
      if (hasStatus) {
        output.WriteEnum(1, field_names[0], (int) Status, Status);
      }
      if (hasUser) {
        output.WriteMessage(2, field_names[1], User);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasStatus) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Status);
        }
        if (hasUser) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, User);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GameStatusEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameStatusEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameStatusEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameStatusEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameStatusEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameStatusEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameStatusEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameStatusEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameStatusEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameStatusEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameStatusEvent MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameStatusEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GameStatusEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameStatusEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameStatusEvent result;
      
      private GameStatusEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          GameStatusEvent original = result;
          result = new GameStatusEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameStatusEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.GameStatusEvent.Descriptor; }
      }
      
      public override GameStatusEvent DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.GameStatusEvent.DefaultInstance; }
      }
      
      public override GameStatusEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameStatusEvent) {
          return MergeFrom((GameStatusEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameStatusEvent other) {
        if (other == global::com.richardpianka.chess.network.GameStatusEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStatus) {
          Status = other.Status;
        }
        if (other.HasUser) {
          MergeUser(other.User);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameStatusEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameStatusEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.status_, out unknown)) {
                result.hasStatus = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              global::com.richardpianka.chess.network.User.Builder subBuilder = global::com.richardpianka.chess.network.User.CreateBuilder();
              if (result.hasUser) {
                subBuilder.MergeFrom(User);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              User = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStatus {
       get { return result.hasStatus; }
      }
      public global::com.richardpianka.chess.network.GameStatus Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(global::com.richardpianka.chess.network.GameStatus value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = global::com.richardpianka.chess.network.GameStatus.Play;
        return this;
      }
      
      public bool HasUser {
       get { return result.hasUser; }
      }
      public global::com.richardpianka.chess.network.User User {
        get { return result.User; }
        set { SetUser(value); }
      }
      public Builder SetUser(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = value;
        return this;
      }
      public Builder SetUser(global::com.richardpianka.chess.network.User.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasUser = true;
        result.user_ = builderForValue.Build();
        return this;
      }
      public Builder MergeUser(global::com.richardpianka.chess.network.User value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasUser &&
            result.user_ != global::com.richardpianka.chess.network.User.DefaultInstance) {
            result.user_ = global::com.richardpianka.chess.network.User.CreateBuilder(result.user_).MergeFrom(value).BuildPartial();
        } else {
          result.user_ = value;
        }
        result.hasUser = true;
        return this;
      }
      public Builder ClearUser() {
        PrepareBuilder();
        result.hasUser = false;
        result.user_ = null;
        return this;
      }
    }
    static GameStatusEvent() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class TimeLeftEvent : pb::GeneratedMessage<TimeLeftEvent, TimeLeftEvent.Builder> {
    private TimeLeftEvent() { }
    private static readonly TimeLeftEvent defaultInstance = new TimeLeftEvent().MakeReadOnly();
    private static readonly string[] _timeLeftEventFieldNames = new string[] { "BlackSeconds", "WhiteSeconds" };
    private static readonly uint[] _timeLeftEventFieldTags = new uint[] { 16, 8 };
    public static TimeLeftEvent DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override TimeLeftEvent DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TimeLeftEvent ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_TimeLeftEvent__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<TimeLeftEvent, TimeLeftEvent.Builder> InternalFieldAccessors {
      get { return global::com.richardpianka.chess.network.Contracts.internal__static_com_richardpianka_chess_network_TimeLeftEvent__FieldAccessorTable; }
    }
    
    public const int WhiteSecondsFieldNumber = 1;
    private bool hasWhiteSeconds;
    private uint whiteSeconds_;
    public bool HasWhiteSeconds {
      get { return hasWhiteSeconds; }
    }
    [global::System.CLSCompliant(false)]
    public uint WhiteSeconds {
      get { return whiteSeconds_; }
    }
    
    public const int BlackSecondsFieldNumber = 2;
    private bool hasBlackSeconds;
    private uint blackSeconds_;
    public bool HasBlackSeconds {
      get { return hasBlackSeconds; }
    }
    [global::System.CLSCompliant(false)]
    public uint BlackSeconds {
      get { return blackSeconds_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasWhiteSeconds) return false;
        if (!hasBlackSeconds) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _timeLeftEventFieldNames;
      if (hasWhiteSeconds) {
        output.WriteUInt32(1, field_names[1], WhiteSeconds);
      }
      if (hasBlackSeconds) {
        output.WriteUInt32(2, field_names[0], BlackSeconds);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasWhiteSeconds) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, WhiteSeconds);
        }
        if (hasBlackSeconds) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, BlackSeconds);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static TimeLeftEvent ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TimeLeftEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TimeLeftEvent ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TimeLeftEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TimeLeftEvent ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TimeLeftEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static TimeLeftEvent ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static TimeLeftEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static TimeLeftEvent ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TimeLeftEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TimeLeftEvent MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(TimeLeftEvent prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<TimeLeftEvent, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TimeLeftEvent cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TimeLeftEvent result;
      
      private TimeLeftEvent PrepareBuilder() {
        if (resultIsReadOnly) {
          TimeLeftEvent original = result;
          result = new TimeLeftEvent();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TimeLeftEvent MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::com.richardpianka.chess.network.TimeLeftEvent.Descriptor; }
      }
      
      public override TimeLeftEvent DefaultInstanceForType {
        get { return global::com.richardpianka.chess.network.TimeLeftEvent.DefaultInstance; }
      }
      
      public override TimeLeftEvent BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is TimeLeftEvent) {
          return MergeFrom((TimeLeftEvent) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TimeLeftEvent other) {
        if (other == global::com.richardpianka.chess.network.TimeLeftEvent.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasWhiteSeconds) {
          WhiteSeconds = other.WhiteSeconds;
        }
        if (other.HasBlackSeconds) {
          BlackSeconds = other.BlackSeconds;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_timeLeftEventFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _timeLeftEventFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasWhiteSeconds = input.ReadUInt32(ref result.whiteSeconds_);
              break;
            }
            case 16: {
              result.hasBlackSeconds = input.ReadUInt32(ref result.blackSeconds_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasWhiteSeconds {
        get { return result.hasWhiteSeconds; }
      }
      [global::System.CLSCompliant(false)]
      public uint WhiteSeconds {
        get { return result.WhiteSeconds; }
        set { SetWhiteSeconds(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetWhiteSeconds(uint value) {
        PrepareBuilder();
        result.hasWhiteSeconds = true;
        result.whiteSeconds_ = value;
        return this;
      }
      public Builder ClearWhiteSeconds() {
        PrepareBuilder();
        result.hasWhiteSeconds = false;
        result.whiteSeconds_ = 0;
        return this;
      }
      
      public bool HasBlackSeconds {
        get { return result.hasBlackSeconds; }
      }
      [global::System.CLSCompliant(false)]
      public uint BlackSeconds {
        get { return result.BlackSeconds; }
        set { SetBlackSeconds(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetBlackSeconds(uint value) {
        PrepareBuilder();
        result.hasBlackSeconds = true;
        result.blackSeconds_ = value;
        return this;
      }
      public Builder ClearBlackSeconds() {
        PrepareBuilder();
        result.hasBlackSeconds = false;
        result.blackSeconds_ = 0;
        return this;
      }
    }
    static TimeLeftEvent() {
      object.ReferenceEquals(global::com.richardpianka.chess.network.Contracts.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
